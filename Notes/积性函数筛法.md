[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 积性函数筛法

## 杜教筛

### 快速复习

（不再赘述，自行复习）

##### 1. 数论分块

##### 2. 积性函数

### 杜教筛

##### 1. 杜教筛是干什么的

设积性函数 $f(i)$，我们的问题是求：
$$
\sum_{i = 1}^{n} f(i)
$$
换句话说，我们的问题是求**积性函数的前缀和**。利用杜教筛可以在优于线性时间的复杂度内解决这个问题。

##### 2. 一般形式

设数论函数 $f(i)$，定义它的前缀和为：
$$
S(i) = \sum_{i = 1}^{n} f(i)
$$
如果有下面这个式子：
$$
\sum_{i = 1}^{n} (f * g)(i)
$$
即 $f$ 卷上 $g$ 的前缀和，那么我们有：
$$
\begin{align*}
\sum_{i = 1}^{n} \sum_{d \mid i} f(i) g(\frac {i} {d})
=&
\sum_{i = 1}^{n} g(i) \sum_{j = 1}^{\left\lfloor \frac {n} {i} \right\rfloor} d(j)
\end{align*}
$$
该等式表示枚举 $g$ 的参数 $i$，再枚举 $i$ 的倍数 $j$，考虑 $(f * g)(ij)$ 对答案的贡献。注意到：
$$
\begin{align*}
\sum_{i = 1}^{n} \sum_{d \mid i} f(i) g(\frac {i} {d})
=&
\sum_{i = 1}^{n} g(i) \sum_{j = 1}^{\left\lfloor \frac {n} {i} \right\rfloor} d(j)
\\=&
\sum_{i = 1}^{n} g(i) S(\left\lfloor \frac {n} {i} \right\rfloor)
\end{align*}
$$
即我们得到了：
$$
\sum_{i = 1}^{n} g(i) S(\left\lfloor \frac {n} {i} \right\rfloor) = \sum_{i = 1}^{n} (f * g)(i)
$$

将左式拆开移项到右式，可得：
$$
g(1) S(n) = \sum_{i = 1}^{n} (f * g)(i) - \sum_{i = 2}^{n} g(i) S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
如果卷积的前缀和以及 $g$ 都易于计算，那么我们能够在更优的时间内解决这个问题。具体的分析我们将在下面以例题的形式呈现。

##### 3. e.g. [51NOD 1244 莫比乌斯函数之和](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1244)

给定一组询问 $(a, b)$，试求：
$$
\sum_{i = a}^{b} \mu(i)
$$

------

###### ①杜教筛

首先将问题转化为前缀和相减的形式，然后考虑对原式进行变化。

根据莫比乌斯等式，我们有：
$$
\sum_{d \mid n} \mu(d) = [n = 1]
$$
即：
$$
\mu * \mathrm{1} = \epsilon
$$
我们取 $g = \mathrm{1}$（$\mathrm{1}$ 是常函数），代入一般形式可得：
$$
\begin{align*}
S(n) =& \sum_{i = 1}^{n} \epsilon(i) - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
\\=&
1 - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
\end{align*}
$$
对右侧进行数论分块，递归进行计算即可。

###### ②时间复杂度

设用于计算前缀和的表达式为：
$$
S(n) = H(n) - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
考虑到实际情况，我们不妨假设计算 $H(n)$ 的时间复杂度为 $O(1)$。

在求解 $S(\left\lfloor \frac {n} {i} \right\rfloor)$ 时，我们会做相同的工作，去求解 $S\left(\left\lfloor \frac {\left\lfloor \frac {n} {i} \right\rfloor} {j} \right\rfloor\right)$；类似地，在更深层的递归我们也会求结构类似的式子。注意到该式等于 $S(\left\lfloor \frac {n} {ij} \right\rfloor)$，类似地在更深层递归会求解 $S(\left\lfloor \frac {n} {ijk \cdots} \right\rfloor)$。由此我们可以得出：**根据数论分块，调用 $S(x)$ 时参数 $x$ 的取值总共就只有 $O(\sqrt n)$ 种，不会因为递归调用而变多**。但是注意，如果我们不记忆化的话，我们是有可能重复计算的。因此我们需要用哈希表进行记忆化，这里假设哈希表的时间复杂度为 $O(1)$。

对于 $S(n)$，我们要花上 $O(\sqrt n)$ 的时间复杂度去枚举转移，因此对于所有的调用，时间复杂度为：
$$
\sum_{i = 1}^{\sqrt n} \left( \sqrt i + \sqrt \frac {n} {i} \right)
$$
上式中的 $i$ 和 $\frac {n} {i}$ 表示数论分块的 $O(\sqrt n)$ 种取值，$\sqrt i$ 和 $\sqrt \frac {n} {i}$ 表示计算它们需要的时间。我们用积分粗糙地代替前缀和：
$$
\int_0^{\sqrt n} \sqrt i ~ \mathrm{d}i + \int_0^{\sqrt n} \sqrt \frac {n} {i} ~ \mathrm{d}i
$$

$$
\frac {2} {3} \sqrt n^{\frac {3} {2}} + 2 \sqrt n (\sqrt n)^{\frac {1} {2}}
$$

计算得时间复杂度为 $O(n^\frac {3} {4})$。

------

$O(n^{\frac {3} {4}})$ 还是太大，怎么办？当 $n$ 较小的时候，我们是可以用线性筛预处理的。所以我们需要预处理到一个合适的值，使得总时间复杂度最小。

假设我们预处理到阈值 $k$。根据前面的分析，我们在杜教筛中的数论分块只需要计算大于 $k$ 的部分：
$$
O(k + \sum_{i = 1}^{\frac {n} {k}} \sqrt \frac {n} {i})
$$
根号表示数论分块需要的时间复杂度。

把前缀和用积分粗糙处理，那么上式等于：
$$
O(k + 2 \sqrt n (\frac {n} {k})^{\frac {1} {2}}) = O(k + \frac {n} {\sqrt k})
$$
令 $k = \frac {n} {\sqrt k}$，即 $k = n^{\frac {2} {3}}$，时间复杂度最优，为 $O(n^{\frac {2} {3}})$。

###### ③实现

实现时，**必须使用 Hash 表记忆化**。**注意数论分块的循环变量要开 $\mathrm{long~long}$！**实际操作时，**必须**使用线性筛筛出前面较小的部分，Hash 表也要尽量开大点。

```c++
LL sieve(LL n)
{
	if (n <= threshold) return mu[n];
	LL ans;
	if ((ans = hash.query(n)) != -1) return ans;
	ans = 1;
	for (LL i = 2, t; i <= n; i = t + 1)
	{
		t = n / (n / i);
		ans -= (t - i + 1) * sieve(n / i);
	}
	hash.insert(n, ans);
	return ans;
}
```

##### 4. e.g. [51NOD 1244 欧拉函数之和](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1239)

给定一组询问 $n$，试求：
$$
\sum_{i = 1}^{n} \varphi(i)
$$

------

我们知道：
$$
\sum_{d \mid n} \varphi(d) = n
$$
即：
$$
\varphi * \mathrm{1} =\mathrm{id}
$$
代入杜教筛：
$$
S(n) = \sum_{i = 1}^{n} i - \sum_{i = 2}^{n} 1 \cdot S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
即：
$$
S(n) = \frac {n (n + 1)} {2} - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
用上面的方法即可。

```c++
LL sieve(LL n)
{
	if (n <= threshold) return phi[n];
	if (map.count(n)) return map[n];
	LL ans = (n & 1) ? (n % mod * (((n + 1) >> 1) % mod)) : ((n >> 1) % mod * ((n + 1) % mod));
	for (LL i = 2, t; i <= n; i = t + 1)
	{
		t = n / (n / i);
		ans = (ans - (t - i + 1) % mod * sieve(n / i)) % mod + mod;
	}
	return map[n] = ans % mod;
}
```
## Min_25 筛

