[TOC]

# 2-SAT 问题

## SAT 问题

&emsp;&emsp;SAT 问题全称为*适定性问题（Satisfiability Problem，SAT Problem）*，笼统地说，适定性问题的目标就是确定是否可以满足所有的条件。

&emsp;&emsp;具体地说，SAT 一般指：有 $n​$ 个集合，元素最多的集合中有 $k​$ 个元素，现用逻辑运算的形式给出一些取元素的规则，要你判断是否可行，甚至要求给出可行方案。由于每个集合里面最多有 $k​$ 个元素，因此我们称其为 $k​$-SAT 问题，而 2-SAT 问题指的就是 $k = 2​$ 时的 SAT 问题。

&emsp;&emsp;已经证明，当 $k \ge 3$ 时，$k$-SAT 问题是 NP 完全问题。而我们将要讨论的 2-SAT 问题中的**每个集合都恰好有 2 个元素，且这两个元素不允许同时取出，往往也不允许两个元素同时不取**。

## 2-SAT 问题

##### 1. 一般模型

&emsp;&emsp;有 $n$ 道题，每道题你可以选择做与不做。现在告诉你：要做第 $2$ 道题就必须做第 $1$ 道题，要做第 $3$ 道题就必须做第二道题……如何给出一个做题方案，使得上面的条件都满足呢？

&emsp;&emsp;我们把每道题看成一个集合，集合中有两个元素：选与不选，则原问题转换为 2-SAT 问题。像这样，**给定 $n$ 个物品，有选与不选两种决策，能且只能选其中一种决策，是一种典型的 2-SAT 的模型**。

##### 2. 拆点

&emsp;&emsp;我们将[上面的问题](#1.-一般模型)转换为了 2-SAT 问题，那么 2-SAT 问题该如何求解呢？

&emsp;&emsp;虽然只有 $n$ 道题，但是我们一共有 $2n$ 个决策（每道题选或不选），我们将每个决策都看作一个点，则共有 $2n$ 个点，我们用 $yes_i$ 和 $no_i$ 表示选或不选第 $i$ 道题对应的结点。

&emsp;&emsp;那么我们的问题就变成了选 $n$ 个点，并且不能同时选 $yes_i$ 和 $no_i$，问满足条件的方案。

##### 3. 连边

&emsp;&emsp;如果我们做了第二题，即选择了 $yes_2$，我们能知道什么（限制条件为[前面举的例子](#1.-一般模型)）？我们可以知道：我们一定选择了 $yes_1$。像这样，如果我们能从选择一个点**推导**出我们**一定**选了另外一个点，我们就从它向另外一个点连一条**有向边**。

###### 原命题和逆否命题

&emsp;&emsp;众所周知，原命题等于逆否命题。对于**像上例中将选与不选的问题转换成 2-SAT 问题的，往往一个限制条件能够产生多个“推导”**：

> 原命题：&emsp;做第二道题 $\to$ 做第一道题。
>
> 逆否命题：不做第一题 $\to$ 不做第二题。

&emsp;&emsp;所以我们还需要再连一条边：从 $no_1$ 连向 $no_2$。其它限制条件类似。

###### 强连通分量

&emsp;&emsp;连边之后，我们得到了一张有向图，我们求出它的强连通分量。可以发现，对于一个强连通分量，如果我们选择它其中的一个点，那么我们一定选择了这个强连通分量的所有点。为什么呢？如果你选择了 $a$，那么你必须选择从 $a$ 出发能够到达的所有点，而在 $a$ 的强连通分量中从 $a$ 出发肯定能够到达强连通分量的所有点。

&emsp;&emsp;当然，反过来，如果我们没有选择强连通分量的一个点，那么整个强连通分量中的点我们都没有选。因此我们得到了在线性时间复杂度内判断 2-SAT 问题[^2sat]是否有解的方法：**若一个集合的两个元素在同一个强连通分量，那么 2-SAT 问题无解，否则一定存在解。**

[^2-sat]: 前面说了，我们讨论的 2-SAT 是指所有集合都恰好有 2 个元素，每个集合能且仅能选择一个元素。

##### 4. e.g. [ARC(AtCoder Regular Contest) 069F Flags](https://arc069.contest.atcoder.jp/tasks/arc069_d)

题目大意：要在一条直线上放 $n \pod {2 \le n \le 10^4}$ 个旗子，第 $i$ 个旗子可以放在 $x_i$ 或者 $y_i$ 处，求旗子间的最大间隔长度。放在同一位置的旗子视作间隔为 $0$。

------

&emsp;&emsp;由于每个旗子要么选 $x$，要么选 $y$，因此这是一个 2-SAT 问题，但是限制条件如何呢？

&emsp;&emsp;我们可以二分答案。对于两个不同的旗子 $i$，$j$，若 $x_i$ 离 $x_j$ 的距离小于答案，那么选了 $x_i$ 就一定不能选 $x_j$，选了 $x_j$ 就一定不能选 $x_i$，换句适合 2-SAT 的话说，选了 $x_i$ 就一定要选 $y_j$，选了 $y_j$ 就一定要选 $x_i$。其它情况类似。

&emsp;&emsp;那么我们考虑这么做：对于一个旗子 $x_i$，若对于一个 $x_j$ 满足 $|x_i - x_j| < ans$，那么我们从 $x_i$ 向 $y_j$ 连一条有向边；若对于一个 $x_j$ 满足 $|x_i - y_j| < ans$，那么我们从 $x_i$ 向 $x_j$ 连一条有向边。对于旗子 $y_i$ 类似。**特别地，$x_i$ 和 $y_i$ 之间不要连边，因为本身就不存在这个推导，再者这会导致它们在一个强连通分量中，造成无解；但由于自环不会影响强连通分量，因此 $x_i$ 和 $x_i$ 之间可以连边，为了方便，无需像 $x_i$ 和 $y_i$ 那样处理。**这样我们可以在 $O(n^2 \log n)$ 的时间复杂度内解决这个问题。

&emsp;&emsp;由于 $n$ 很大，因此考虑线段树优化连边。观察发现，如果我们把旗子的 $x$ 和 $y$ 分别从小到大排序，要连边的点将会是一段连续的区间，使用线段树优化连边即可。具体的实现可能有些复杂，需要对线段树优化连边有深刻理解，这里不再赘述，详见线段树优化连边。

```c++
bool check(int s)
{
	G.clear();
	G.resize(n << 2); // 4n - 2 个点
	buildx(1, n);
	buildy(1, n);

	int l = 1, r = 0;
	for (int i = 1; i <= n; i++) // 选了 x 后，某些不能选 x，等价于这些必须选 y
	{
		while (l <= n && points[i].x - points[l].x >= s) l++;
		while (r < n && points[r + 1].x - points[i].x < s) r++;
		linky(i, l, i - 1); // y 按 x 排序的顺序
		linky(i, i + 1, r);
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; i++) // 选了 x 后，某些不能选 y，等价于这些必须选 x
	{
		while (l <= n && points[i].x - points[idx[l]].y >= s) l++;
		while (r < n && points[idx[r + 1]].y - points[i].x < s) r++;
		linkx(i, l, r); // x 按 y 排序的顺序
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; i++) // 选了 y 后，某些不能选 x，等价于这些必须选 y
	{
		while (l <= n && points[idx[i]].y - points[l].x >= s) l++;
		while (r < n && points[r + 1].x - points[idx[i]].y < s) r++;
		linky(idx[i] + n, l, r); // x 按 y 排序的顺序
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; i++) // 选了 y 后，某些不能选 y，等价于这些必须选 x
	{
		while (l <= n && points[idx[i]].y - points[idx[l]].y >= s) l++;
		while (r < n && points[idx[r + 1]].y - points[idx[i]].y < s) r++;
		linkx(idx[i] + n, l, i - 1); // x 按 y 排序的顺序
		linkx(idx[i] + n, i + 1, r);
	}

	stamp = 0;
	stack[0] = 0;
	N = 0;
	memset(dfn, 0, sizeof(dfn));
	memset(low, 0, sizeof(low));
	for (int i = 1, to = 4 * n - 2; i <= to; i++)
		if (!dfn[i])
			Tarjan(i);

	for (int i = 1; i <= n; i++)
		if (belong[i] == belong[i + n])
			return false;
	return true;
}
```

##### 5. 构造方案

&emsp;&emsp;我们对当前的图缩点，得到一个 DAG，若有解，那么每一个点对应的强连通分量一定不会同时存在 $yes_i$ 和 $no_i$。现在我们考虑如何得到一个具体的方案。

###### 任意解

&emsp;&emsp;对于这个 DAG，**我们构造出它的反图**。（有缘再来学）

###### 字典序最小的解

&emsp;&emsp;以上方法不适用于构造字典序最小的解，我们只能贪心地去尝试让字典序最小。我们检查每一个还没有确定选谁的集合，并贪心地选择字典序小的元素，然后递归去选中能被推导出的元素。如果选择失败，我们撤销刚才的操作，尝试去选择字典序大的元素，如果还是失败，说明 2-SAT 问题无解。（训练指南上的方法）

&emsp;&emsp;时间复杂度 $O(nm)$。