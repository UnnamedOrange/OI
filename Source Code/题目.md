#####1. [JZOJ 4233](https://jzoj.net/senior/#main/show/4233)

- [x] 使用调整法求树的重心

      主要用到了定理：**树的重心每棵子树的大小一定小于等于 n / 2。**因此我们假设一个点为重心，然后判断是否有子树（包括自身这棵子树的其余部分）的大小**大于** n / 2，如果有，我们就假设那个新的点为重心。继续走，直到没有子树大小大于 n / 2，这时当前点就为重心。

      实际实现中，没有必要检查是否需要往上走（即检查自身对应子树的其余部分），因为我们肯定是从上而下走来的，所以肯定不会走回头路。

      ```c++
      INT adjust(INT root)
      {
      	INT maxIdx = 0;
      	for (int i = G.head[root]; i; i = G.edges[i].next)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to == parent[root])
      			continue;
      		if (size[to] > n / 2)
      		{
      			maxIdx = to;
      			break;
      		}
      	}
      	return maxIdx;
      }
      ```

      ```c++
      	INT center = 1;
      	while (INT t = adjust(center))
      		center = t;
      ```

      ​

      另一方面，这个做法对于求子树的重心就很有用（比如在点分治时），它只需要**从上往下走**（**因为起点为子树的根结点，所以不需要回头**）就可以了，而不需要一次额外的 DFS。


#####2. [JZOJ 1301](https://jzoj.net/senior/#main/show/1301)

- [x] 使用调整法求树的重心

      除了树的重心的求法，这道题还涉及两个重心的问题。首先，一棵树有两个重心的必要条件是这棵树的结点数为偶数；其次，它的充分条件是存在一条边，连接两棵大小相同的子树。因此，另一方面，**树的两个重心总是相邻的**。

      ```c++
      	INT center2 = 0;
      	if (!(n & 1))
      	{
      		for (int i = G.head[center]; i; i = G.edges[i].next)
      		{
      			const Edge& e = G.edges[i];
      			INT to = e.to;
      			if (to == parent[center])
      				continue;
      			if (size[to] == n / 2)
      			{
      				center2 = to;
      				break;
      			}
      		}
      		//center 是从上往下找过来的，所以不用找父结点
      		if (center2 && center > center2)
      			std::swap(center, center2);
      	}
      ```

      另外，我们的 center 是从根结点开始，肯定是从上往下调整的，所以 center2 一定不会是 center 的父结点。

##### 3. 树的重心知识点整理

定理 1：树的重心每棵子树的大小一定小于等于 n / 2。作用：判定一个点是否是重心。

定理 2：每棵子树的大小小于等于 n / 2 的结点为重心。作用：求重心。

定理 1 和定理 2 互为逆定理。

定理 3：设 f(x) = 树中所有点到 x 的距离和，则重心的 f 值最小（如果有两个重心，它们 f 值一样）。证明方法：在重心上反证，发现如果移动到相邻点，距离变大了。

定理 4：两棵树通过一条边相连成为一棵新树，新树重心一定在原来两棵树的重心的路径上。

#####4. 树的直径知识点整理

定理 1：以树上任意一个点为起点的最长路径，终点一定是直径的一个端点。

定理 2：对于两条相交的直径，它们不相交部分一定对称。

定理 3：两棵树用一条边合并，新树直径两端一定是原本两棵树直径的四个端点中的两个。

定理 3 的扩展：在树上，对于两个不相交的结点集合，每个集合知道一个最远点对，则两个集合的并的最远点对一定是这两个集合的最远点对的四个端点中的两个。

虚树的定义：在一棵树上，给定一个集合 S，将包含 S 的最小连通块叫做 S 的虚树。定理 3 的扩展中的最远点对可以看作集合对应的虚树的直径。

#####5. [JZOJ 4727](https://jzoj.net/senior/#main/show/4727)

- [x] 使用动态规划求树的直径，使用两次深搜的方法将以 1 为根的答案转移至以 i 为根。

######①求整棵树的直径

​	方法：处理出有根子树的最长链 `length[i][0]` 和次长链 `length[i][1]`，取 `length[i][0] + length[i][1]` 的最大值，设为 `d[i]`。

​	**注意：一定是取最大值，而不是根结点的最长链和次长链之和。**

######②求整棵树排除一棵子树后的直径

​	方法：首先想办法**把有根树的 length 转化为 length2。为了防止转移时转移到被排除的子树，还要同时记录子链是从哪里转移来的（who2）。由于我们需要最长和次长，同时有可能（最多）有一个不能进行转移，因此我们保存前三大的 length。**这种通过旋根把有根树的答案转换为无根树的答案往往都需要用这样的方法。

​	接下来，考虑如何求直径。我们定义 `d2[i][0 / 1]` 为以 i 为整棵树的根，不经过 i 的直径中最长和次长的长度（因此该直径一定在 i 的一棵子树内）。肯定我们还需要保存 d2 是对应的哪棵子树，用 where 表示。

​	现在的问题是，如何求 d2 呢？首先，对于边界情况 i = 1，d2 就是取其子树的 d 的最大值。考虑其它子树，发现只有两种可能，一是取其子树的 d，二是把其父结点看作一棵子树，所以首先用父结点的 d2 更新子树的 d2，然后考虑经过父结点的直径，取不经过当前结点的两条最长链之和更新 d2 即可。由于更新 length2 和 d2 均是从上至下的，因此可以放在一个深搜中。

​	需要注意的是，在进行下次 DFS 前，首先得保证当前结点已完全更新，所以得遍历两次边，先更新 d2 后再进行下一次 DFS。

      ```c++
      INT length2[maxn][3];
      INT who2[maxn][3];
      INT d2[maxn][3];
      INT where[maxn][3];
      void DFS2(INT node)
      {
      	if (node != 1)
      	{
      		INT l = length2[parent[node]][0];
      		INT w = who2[parent[node]][0];
      		if (w == node)
      		{
      			l = length2[parent[node]][1];
      			w = who2[parent[node]][1];
      		}
      		l += pCost[node];
      		update3(l, w, node, length2, who2);
    
      		w = parent[node];
      		//d2 实际上只需要最大和次大，这里只是为了方便，定义成了保存前三大
      		if (where[w][0] != node)
      			update3(d2[w][0], where[w][0], node, d2, where);
      		if (where[w][1] != node)
      			update3(d2[w][1], where[w][1], node, d2, where);
    
      		if (who2[w][0] == node)
      			l = length2[w][1] + length2[w][2];
      		else if (who2[w][1] == node)
      			l = length2[w][0] + length2[w][2];
      		else
      			l = length2[w][0] + length2[w][1];
      		update3(l, w, node, d2, where);
      	}
      	wander(G, node)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to != parent[node])
      			update3(d[to], to, node, d2, where);
      	}
      	wander(G, node)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to != parent[node]) DFS2(to);
      	}
      }
      ```
    
      ```c++
          INT ans = 0;
          for (int i = 2; i <= n; i++)
          {
              INT temp = 0;
              INT p = parent[i];
              if (i == who2[p][0])
                  temp = length2[p][1] + length2[p][2];
              else if (i == who2[p][1])
                  temp = length2[p][0] + length2[p][2];
              else
                  temp = length2[p][0] + length2[p][1];
    
              if (i == where[p][0])
                  temp = std::max(temp, d2[p][1]);
              else if (i == where[p][1])
                  temp = std::max(temp, d2[p][0]);
    
              temp += d[i];
              ans = std::max(ans, temp);
          }
          printOut(ans);
      ```


#####6. [JZOJ 1016](https://jzoj.net/senior/#main/show/1016)

- [x] 使用 DFS 序维护**子树的和**，进行**单点修改**

      应该是道裸题，不多说了。

##### 7. 欧拉序

######①欧拉序其实有两种

​	第一种欧拉序就是用来把 LCA 转成 RMQ 的欧拉序，序列长度为 2n - 1。有可能一个结点会出现多次，但是叶节点只会出现一次。回忆求 LCA 的过程，我们只取了第一次出现的位置作为区间的起点和终点，这可以作为更深的应用的一个参考。

​	第二种欧拉序是在结点进入时和结点离开时各加入一次序列，也就是说每个结点最多会且只会出现两次，序列长度为 2n。

######②第二种欧拉序的应用

​	考虑这样一个问题：对于一棵结点带权值的有根树，有两种操作，一种操作是给结点加上一个权值，另一种操作是求出两点之间的路径的权值和。

​	用 DFS 可以很方便快捷地解决这个问题。由于权值只有可能对子树造成贡献，因此在给一个结点加上一个权值时，就等同于给整棵子树加上一个权值，然后一个结点被加的权值之和就是该结点到根结点的路径的权值和，接下来怎么做就不需要多说了。具体的操作可以使用树状数组，用差分的思想把单点加，区间查改成区间加，单点查。但是这个方法有个问题，就是这个方法实际上是用到了“贡献”的思想，有时计算贡献会比直接加有大的局限性（见 8.）。

​	而使用第二种欧拉序则可以这么做：**在要被加的结点的起始位置加上权值，在结束位置减去权值**，则从根结点到某个结点的路径的权值之和就是**该点的起始位置的前缀和**。这样，操作就独立在了子树上，跟父结点无关了。

#####8. [JZOJ 4005](https://jzoj.net/senior/#main/show/4005)

- [ ] 维护欧拉序（2）

  （这道题没有数据，只是写了一个常数巨大的程序）

  首先，可以考虑交换操作，我们肯定是要用某种序列来维护这棵树，然后把树放在线段树上。由于颜色只有 10 种，因此可以每种颜色开一棵线段树，交换操作就可以交换线段树的区间。具体的，可以使用指针线段树，则交换的时间复杂度为 O(log n)。

  但是，如果我们使用 DFS 序，则会产生问题：DFS 序考虑的是对答案的贡献，因此移动子树后答案贡献将会变成新的父结点对这棵子树的答案贡献，也就是说，我们要维护的内容将会随着子树的交换而改变，而且很明显这个改变是难以维护的，所以这种方法不可取。

  如果使用欧拉序（2），问题就迎刃而解了。移动子树时就是移动的子树，不受父结点的影响，这就是上文所说的“独立性”和“局限性”。

  本题细节问题还有待研究。


#####9. 树链剖分

[较具体内容](http://blog.csdn.net/lycheng1215/article/details/78721561)

这里只给出一个众所周知的定理。

定理：如果 v 是 u 的子结点，且 (u, v) 是一条轻边，那么 size(v) < size(u) / 2。

#####10. [JZOJ 2256](https://jzoj.net/senior/#main/show/2256)

- [x] 树链剖分

  这道题直接树链剖分做就可以了，大概写了 30 min。


	至于线段树，之后再来讨论常用技巧。
#####11. [BZOJ 3626](http://www.lydsy.com/JudgeOnline/problem.php?id=3626)

- [ ] 树链剖分，离线算法

######①暴力做法

​	直接两两求 LCA。

######②问题转化

​	发现 LCA 以上的路径会有重叠，所以考虑这么一个做法：将 z 点到根结点的路径上的每个点的权值 +1（权值默认为 0），则一个询问的答案为所有被询问点到根结点的路径的权值之和的和。

​	**发现，用这种做法不可能将询问合并。**所以考虑一个类似但是相反的做法：将所有询问点到根结点的路径的每个点的权值 +1，最后询问 z 点到根结点的路径的权值之和。

​	应该注意这种性质：**所有的询问都是询问的区间，这给前缀和创造了可能。**

######③离线算法初窥

​	我们先考虑如何计算**单个**答案。

​	如果使用前缀和，很明显，可以先从 1 加到 l - 1，这个时候记录一下当前从 z 到根结点的权值和，再从 l 加到 r，再记录从 z 到根结点的权值和。两两相减就是答案。

​	再考虑多组数据，这个时候就很明显可以套用**离线算法**了。只需要考虑一个询问的起点和终点，分别记录一下这个时候的答案即可。

##### 12. 点分治（1）

###### ①概念

​	点分治是一种用在有根树上的分治算法，所以如果你手上拿的是一棵无根树，你需要先把它转换成有根树。

​	在点分治中，把操作分成两类，第一类是经过当前子树根结点（简称当前结点）的操作，第二类是不经过当前结点的操作。对于第一类操作，我们直接处理，对于第二类操作，我们到子树中去递归处理，这就叫做点分治。

​	递归子树时，子树应该是独立的，也就是说，可以把子树也视为无根树，然后再把它转换成有根树，这个过程和一开始对待整棵无根树的操作是一样的。

###### ②选择根结点

​	点分治时，对于第一类操作，我们往往会遍历完整棵树才能得到答案，因此树的形态很重要。

​	很明显，理想的树应该是一棵高度比较矮的树，而不理想的树可能就是一条链。如果根结点选取得不恰当，时间复杂度就会从理想的 O(n log n) 退化为 O(n$^2$)。

​	幸运的是，存在一种做法，使时间复杂度达到最坏 O(n log n)，那就是t每次都选择子树的重心作为新的根结点。可以证明，在最坏情况下时间复杂度是 O(n log n)（倍增证明法）。

​	可以使用调整法在 O(n log n) 的时间复杂度内求出每一棵子树的重心，然后用这些重心重新构成一棵树。这样的树叫做**重心树**，又叫**点分树**。这个概念的递归定义为：重心树的儿子都是重心树，重心树的根结点为原树的重心。

​	可以预处理重心树，这在多次点分治时可以节省大量时间。

##### 13. [JZOJ 1166](https://jzoj.net/senior/#main/show/1166)

- [x] 点分治入门

###### ①点分治范式

​	从这道题可以看出点分治的一些范式。

​	1> 分治范式：U - Extra

​		即用全集的答案减去不合法或重复的答案得到正确的答案的方法。

​	2> 代码

```c++
INT vis[maxn];
INT size[maxn];
INT buf[maxn];
void DFS(INT node, INT parent);
INT GetRoot(INT node, INT parent, INT s);
void solve(INT node);
```

​		以上三个函数是最基本的函数：solve 表示点分治过程，GetRoot 表示用调整法寻找重心，而 DFS 则用于初始化子树的数据，主要是 size 域，并且还要用来保存子树的结点集合 buf。

​		而 vis 域也是点分治的关键之一，**在选择了一个重心当作根结点后，该结点要被打上 vis 标记，相当于是把边拆开了。**

###### ②这道题的解法

​	首先，通过双指针扫描我们能够很方便地求出经过根结点的长度小于等于 len 的路径总数，但是这会包含在同一棵子树中的情况。**所以我们在进入子树时，要先排除子树对答案错误的贡献。**

```c++
void solve(INT node)
{
	buf[0] = 0;
	DFS(node, 0);
	if (ans)
	{
		std::sort(buf + 1, buf + 1 + buf[0], [](const INT& x, const INT& y) { return dis[x] < dis[y]; });
		INT j = 0;
		for (int i = buf[0]; i >= 1; i--)
		{
			while (j < i - 1 && dis[buf[i]] + dis[buf[j + 1]] <= len)
				j++;
			if (i == j)
				j--;
			ans -= j;
		}
	}

	node = GetRoot(node, 0, size[node]);
	vis[node] = true;
	dis[node] = 0;
	GetDis(node, 0);

	INT j = 0;
	std::sort(buf + 1, buf + 1 + buf[0], [](const INT& x, const INT& y) { return dis[x] < dis[y]; });
	for (int i = buf[0]; i >= 1; i--)
	{
		while (j < i - 1 && dis[buf[i]] + dis[buf[j + 1]] <= len)
			j++;
		if (i == j)
			j--;
		ans += j;
	}

	wander(G, node)
	{
		DEF(G);
		if (vis[to])
			continue;
		solve(to);
	}
}
```

​	在排除了所有的算重后，不难发现，我们求出来的是不重复不遗漏的。

##### 14. [JZOJ 3329](https://jzoj.net/senior/#main/show/3329)

- [x] 点分治入门 2，维护堆序序列

###### ①再次总结点分治的范式

```c++
void solve(INT node)
{
	DFS(node, 0);
	node = getRoot(node, 0, size[node]);
	dis[node] = 0;
	GetBuf(node, 0, 0, buf[node]);
	std::sort(buf[node].begin(), buf[node].end());

	vis[node] = true;
	wander(G, node)
	{
		DEF(G);
		if (vis[to])
			continue;
		solve(to);
	}
}
```

​	1> 第一步：通过深搜找到重心

​	2> 第二步：从重心开始遍历整棵新树，并且处理数据

​	3> 第三步：打标记，遍历子树

###### ②对于序列上的两个数之间的最大值

​	如果要排序，时间复杂度为 O(n$^2$ log n)，无法承受。可以先对序列进行排序，然后用大根堆来处理：发现，如果 (l, r) 还在堆中，那么 (l - 1, r) 仍然也应在堆中，所以可以在 (l, r) 出堆以后再将 (l - 1, r) 入堆。这样的时间复杂度将是 O(m log n) 的。对于 m 小的问题可以轻松解决。

​	回到这道题，思路也一样，对于每个根结点，它的所有结点到根结点的距离就是那个序列，只不过对于每个结点还需要额外保存一下子树信息，避免非法路径（即：经过根结点的路径不是两点间的简单路径的情况）。

​	这种用堆处理前 m 大的问题（m 较小）也是很常见的。

##### 15. [JZOJ 4503](https://jzoj.net/senior/#main/show/4503)

​	