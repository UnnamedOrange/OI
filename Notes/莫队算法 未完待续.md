[TOC]

#莫队算法

#####1. 一般的莫队算法

###### ①适用条件

​	在知道了 $ans_{l, r}$ 的情况下，如果我们能够计算出 $ans_{l - 1, r}$，$ans_{l + 1, r}$，$ans_{l, r - 1}$，$ans_{l, r + 1}$，那么就能使用莫队算法。

###### ②概念

​	莫队算法是一种==**离线算法**==。 其原理是改变询问的操作顺序，在满足适用条件的情况下==直接暴力扩张或收缩区间，就能在一个可行的时间复杂度内解决问题。==

###### ③方法

​	将所有询问==以**左端点所在块**为第一关键字，**右端点**为第二关键字==进行排序。

​	设区间扩张或收缩一个单位的时间复杂度为 $O(1)$，则时间复杂度为 $O(max(n, q) \sqrt {n})$。[^1]

[^1]: 在接下来说明块大小之前，我们先假设块大小为 $\sqrt {n}$。  

###### ④时间复杂度分析

​	当左端点所在块确定时，右端点单调，所以左端点在同一块内时移动右端点的时间复杂度为 $O(n)$，总共有 $O(\sqrt {n})$ 块，所以==向右移动右端点的总时间复杂度为 $O(n \sqrt {n})$。==

​	当左端点所在块变动时，移动右端点的时间复杂度为 $O(n)$，总共有 $O(\sqrt {n})$ 块，所以==向左移动右端点的总时间复杂度为 $O(n \sqrt {n})$。==

​	当左端点所在块确定时，移动一次左端点的时间复杂度为 $O(\sqrt {n})$ ，总共会有 $q$ 次移动，所以==块内移动左端点的总时间复杂度为 $O(q \sqrt {n})$。==

​	当左端点所在块变动时，相当于从左往右移动左端点，所以==块间移动左端点的总时间复杂度为 $O(n)$。==

​	所以整体的时间复杂度为 $O(max(n, q) \sqrt {n})$。

###### ⑤块大小

​	很明显，上面的时间复杂度不是很好，因为我们要取一个 $max$，也就是说时间复杂度可能是不正确的。

​	正确的块大小是：$\frac {n} {\sqrt {q}}$，则有 $\sqrt {q}$ 块。

​	在块大小为它的情况下，移动右端点的时间复杂度为 $O(n \sqrt {q})$；块内移动左端点的时间复杂度为 $O(n \sqrt {q})$；块间移动左端点的时间复杂度为 $O(n)$。

​	所以莫队算法的正确时间复杂度为 $O(n \sqrt {q})$。

​	==在一般情况下，莫队算法能过通过数据规模为 $10^5$ 的题。==

###### ⑥技巧

​	排序时，若两个询问在相同块，不要直接 $r$ 升序排序，而要这么做：==若 $l$ 为偶数（$l$ 从 $0$ 开始），则 $r$ 为升序；若 $l$ 为奇数，则 $r$ 为降序。==用这种方法能大幅降低程序的运行时间。原理很明显。

​	注意区间扩张和收缩处理时的区别。扩张时，先更改端点位置，再更新答案；收缩时，先更新答案，再更改端点位置。

​	可以将扩张和收缩写成一个函数。

###### ⑦参考代码

```c++
std::sort(idx + 1, idx + 1 + q,
	[](const INT& a, const INT& b)
{
	const Query& x = querys[a];
	const Query& y = querys[b];
	if (inBlocks[x.l] != inBlocks[y.l])
		return inBlocks[x.l] < inBlocks[y.l];
	else
		return inBlocks[x.l] & 1 ? x.r > y.r : x.r < y.r;
});
```

```c++
INT cntL = 1;
INT cntR = 1;
//手写边界的答案
for (int i = 1; i <= q; i++)
{
	Query& query = querys[idx[i]];
	INT l = query.l;
	INT r = query.r;
	INT& ans = query.ans;

	while (cntL > l)
	{
		cntL--;
		in(cntL);
	}
	while (cntR < r)
	{
		cntR++;
		in(cntR);
	}
	while (cntL < l)
	{
		out(cntL);
		cntL++;
	}
	while (cntR > r)
	{
		out(cntR);
		cntR--;
	}
	ans = sum;
}
```