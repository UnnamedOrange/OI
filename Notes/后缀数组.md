[TOC]

# 后缀数组

>   开局一个 Markdown，内容全靠编。——Orange

## 基数排序

在学习后缀数组前，需要先了解基数排序。

##### 1. 桶排序

利用数组，数组下标表示出现的数，每个位置保存对应的数出现的次数。因此桶排序又叫**计数排序**。

```c++
const int maxs = 1005;
void BinSort(int* a, int n)
{
	static int bin[maxs];
	for (int i = 0; i < n; i++)
		bin[a[i]]++;
	n = 0;
	for (int i = 0; i < maxs; i++)
		while (bin[i]--)
			a[n++] = i;
}
```

时间复杂度 $O(n + m)$，$m$ 表示可能出现的最大的数。

如果数的范围很小，使用桶排序是很快的，但如果数的范围太大，桶排序会不仅很慢，而且空间开不下。

##### 2. 基数排序

基数排序是对桶排序进行得一种改造，解决了对大整数进行排序的问题。

###### ①原理

|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  8   |  10  |  95  |  24  |  7   |  36  |  18  |  37  |

<center>需要排序的数</center>

------

我们进行多次操作。第一次操作时，我们只看个位，用类似于桶排序的方法，把第 1 个数到第 8 个数按照任意顺序放进它对应的**链表**中：


| head |      |      |      |
| :--: | :--: | :--: | :--: |
|  0   |  10  |      |      |
|  1   |      |      |      |
|  2   |      |      |      |
|  3   |      |      |      |
|  4   |  24  |      |      |
|  5   |  95  |      |      |
|  6   |  36  |      |      |
|  7   |  7   |  37  |      |
|  8   |  8   |  18  |      |
|  9   |      |      |      |

如果只看个位，有什么特征呢？从上到下输出个位，**一定是已经排好序的了**，因为这就是对个位的一个桶排序。

接下来我们看十位。与以上操作不同的是，我们并不按原序列的顺序从第 1 个数处理到第 8 个数，而是**根据上面的链表按个位从小到大一个一个地考虑**。（个位相同的数可以按任意顺序考虑）

| head |      |      |      |
| :--: | :--: | :--: | :--: |
|  0   |  7   |  8   |      |
|  1   |  10  |  18  |      |
|  2   |  24  |      |      |
|  3   |  36  |  37  |      |
|  4   |      |      |      |
|  5   |      |      |      |
|  6   |      |      |      |
|  7   |      |      |      |
|  8   |      |      |      |
|  9   |  95  |      |      |

不难发现，按从上至下，从左至右的顺序取出元素时，整个序列就变得有序了。**这是因为我们保证了先选择个位小的，再选择个位大的，这样就保证了个位小的先插入，所以十位相等的就是升序了。**

注意到，**排了两次序后，不止是十位有序，十位和个位组成的两位数也有序**。所以我们继续这个过程，前三位、前四位……依次都会有序，这就是基数排序。

###### ②实现

以上描述实现起来很麻烦：你不可能愿意去写一个常数巨大又容易 RE 的链表。所以需要对这个过程进行一些绝妙的改进。

改进的方法便是引入排名（rank）：

| head |       |       |      |
| :--: | :---: | :---: | :--: |
|  0   | 10(1) |       |      |
|  1   |       |       |      |
|  2   |       |       |      |
|  3   |       |       |      |
|  4   | 24(2) |       |      |
|  5   | 95(3) |       |      |
|  6   | 36(4) |       |      |
|  7   | 7(5)  | 37(6) |      |
|  8   | 8(7)  | 18(8) |      |
|  9   |       |       |      |

每个数右边括号里的内容便是它的排名（下标从 1 开始）。

|      |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| num  |  8   |  10  |  95  |  24  |  7   |  36  |  18  |  37  |
| rank |  7   |  1   |  3   |  2   |  5   |  4   |  8   |  6   |

不难发现，**按照排名的顺序插入链表，正好就是我们需要的插入顺序**。如何求得排名呢？**只需要一个桶就好了**：

|      | 出现次数 | 前缀和 |
| :--: | :------: | :----: |
|  0   |    1     |   1    |
|  1   |    0     |   1    |
|  2   |    0     |   1    |
|  3   |    0     |   1    |
|  4   |    1     |   2    |
|  5   |    1     |   3    |
|  6   |    1     |   4    |
|  7   |    2     |   6    |
|  8   |    2     |   8    |
|  9   |    0     |   8    |

即：**每个数的出现次数（桶）的前缀和便是对应数的最高排名**。只需要再扫描一次原数组，就能求得所有数的排名了。利用排名可以计算出新的数组：如果进行了足够多次这样的操作，得到的便是排序的结果；如果排序还没有结束，得到的正好就是下一次操作时元素插入链表的顺序。

为了方便，下标从 0 开始。

```c++
const int maxn = int(1e5) + 5;
const int base = 65536;
const int mask = base - 1;
void RadixSort(int* a, int n)
{
	static int buffer[base];
	static int temp[maxn];
	for (int i = 0, move = 0; i < 2; i++, move += 16) // 使用二进制
	{
		memset(buffer, 0, sizeof(buffer));
		for (int j = 0; j < n; j++)
			buffer[(a[j] >> move) & mask]++;
		for (int j = 1; j < base; j++)
			buffer[j] += buffer[j - 1];
		for (int j = n - 1; ~j; j--) // note
			temp[--buffer[(a[j] >> move) & mask]] = a[j];
		// rank[a[j]] = --buffer[(a[j] >> move) & mask]
		memcpy(a, temp, n * sizeof(int)); // 现在 a 的 (i + 1) * move 位之前是升序
	}
}
```

以上代码有一些要注意的地方。

为什么要用二进制？二进制快啊。这样给了我们一个启示：**基数排序的进位制是由我们自己决定的，每一次的进位制还可以不一样，因此我们还可以给 $n$ 元组排序。**

为什么 note 处需要倒着枚举呢？我们假设已经进行了一次排序了，一次排序后，低位是升序的。进行第二次排序时，对于高位相同的数，低位应该是升序，但代码实现上只有直接 --buffer 是最简单的，而这样写就只能从后向前枚举，保证在最终结果中，对于高位相同的数，低位小的 rank 比低位大的 rank 小。

需要注意的是，**得到的 rank 始终是 $0 \sim n - 1$ 的一个排列**。

## 后缀数组（Suffix Array，SA）

##### 1. 常用定义

子串（$\mathrm{substring}$）：一个字符串的一个连续的部分被称为它的一个子串。可以用左右端点来描述一个字符串的子串。

母串：子串对应的原字符串。注意，子串可以等于母串。

后缀（$\mathrm{suffix}$）：如果一个子串的右端点是它的母串的结尾，则称这个子串是母串的后缀。

后缀的整数表示：如果知道母串，显然它的任意一个后缀都可以通过一个整数表示，其含义是后缀在母串中的左端点。

字符串的大小比较：按字典序对字符串进行比较。

##### 2. 后缀数组的定义

将长度为 $n$ 的字符串 $\mathrm{str}$ 的所有后缀进行排序，我们将会得到 $n$ 个字符串，它们都是 $\mathrm{str}$ 的后缀。将这 $n$ 个后缀排序后得到的数组称为后缀数组，其中所有后缀都是用整数表示的。

##### 3. 求得后缀数组的暴力方法

直接 sort 排序。遗憾的是，时间复杂度并不是 $O(n \log n)$ 的，而是 $O(n^2 \log n)$ 的，因为比较字符串需要花去 $O(n)$ 的时间。

##### 4. 后缀数组的倍增算法

该算法基于这样一个事实：有两个长度相同的字符串 $a$，$b$，我们把它们拆成长度相同的两份 $(a_1, a_2)$，$(b_1, b_2)$，如果有：

```c++
a1 < b1 || (a1 == b1 && a2 < b2)
```

我们便能得到 $a < b$。

接下来，我们用字符串 $\mathrm{aabaaaab}$ 为例，求得它的后缀数组。

------

使用以上方法进行比较，通过倍增，我们便能比较出所有的后缀。倍增的边界一定是单个元素，怎么表示呢？**我们使用 rank**：

|      |  a   |  a   |  b   |  a   |  a   |  a   |  a   |  b   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| rank |  1   |  1   |  2   |  1   |  1   |  1   |  1   |  2   |

我们自然是可以求得倍增一次后的结果的：

|          |  a   |  a   |  b   |  a   |  a   |  a   |  a   |  b   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   rank   |  1   |  1   |  2   |  1   |  1   |  1   |  1   |  2   |
| 倍增一次 |  aa  |  ab  |  ba  |  aa  |  aa  |  aa  |  ab  |  b   |
| new rank |  1   |  2   |  4   |  1   |  1   |  1   |  2   |  3   |

倍增后，最后一个元素后面没有字符，这没有关系，我们仍然保留它。细想，如果继续倍增，字符串会越来越长，而长度较短的后缀的结果也会确定。当倍增长度足够长时，所有后缀的 rank 也就确定了。

|                   |  a   |  a   |  b   |  a   |  a   |  a   |  a   |  b   |
| :---------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|     new rank      |  1   |  2   |  4   |  1   |  1   |  1   |  2   |  3   |
|     倍增两次      | aaba | abaa | baaa | aaaa | aaab | aab  |  ab  |  b   |
| new rank 倍增一次 | 1 4  | 2 1  | 4 1  | 1 1  | 1 2  | 1 3  |  2   |  3   |
|  brand new rank   |  4   |  6   |  8   |  1   |  2   |  3   |  5   |  7   |

震惊！现在的 brand new rank 已经是一个排列了，说明**每个后缀的前四个字符已经不存在一样的了**。此时，每个后缀的前四个字符就可以代表整个后缀，也就是说，**brand new rank 就是原串的每个后缀在后缀数组中的排名，我们已经可以退出倍增了**。

注意到，比较字符串时，我们并不是比较的字符串，而是比较的倍增后的 new rank 的二元组，这保证了比较的速度。另外，可以发现我们的操作都是对排名的操作。

倍增的具体方法见图[^图片来源]：

[^图片来源]: [后缀数组 （Suffix Array）](https://zhuanlan.zhihu.com/p/21283102)

![1](https://pic1.zhimg.com/80/597e0965909bf18b6564ba1c8163957b_hd.jpg)

![2](https://pic1.zhimg.com/80/322e44d1a3d29535836eebb819b5e9af_hd.jpg)

![3](https://pic1.zhimg.com/80/322e44d1a3d29535836eebb819b5e9af_hd.jpg)

##### 5. 实现

后缀数组的倍增算法是理解起来十分容易但实现起来十分困难的典例。由于有了倍增，不考虑内部操作，算法的时间复杂度为 $O(n \log n)$。如果使用快速排序，那么算法的时间复杂度为 $O(n \log^2 n)$。由于我们实际上是对一个二元组进行排序，因此我们可以使用基数排序，时间复杂度为 $O(n \log n)$。

```c++
int n;
char str[maxn];
int buf_size = 128;
int buf[maxn];
int SA[maxn]; // SA: 第 i 大的是谁，rank: i 是第几大；rank 的 rank 是 SA
int x[maxn], y[maxn];
void GetSA()
{
	int *rank = x, *SA_second = y;

	for (int i = 0; i < n; i++)
		rank[i] = str[i];

	for (int i = 0; i < buf_size; i++) buf[i] = 0;
	for (int i = 0; i < n; i++) buf[rank[i]]++;
	for (int i = 1; i < buf_size; i++) buf[i] += buf[i - 1];
	for (int i = n - 1; ~i; i--)
		SA[--buf[rank[i]]] = i; // 离散：(SA[--buf[rank[i]]] = rank[i])：rank[i]->i

	for (int k = 1; k <= n; k <<= 1)
	{
		int t = 0;
		for (int i = n - k; i < n; i++) // 尾部“没有”第二关键字的元素，它们的排名设为最小
			SA_second[t++] = i;
		for (int i = 0; i < n; i++)
			if (SA[i] >= k) SA_second[t++] = SA[i] - k;
		// 从小到大枚举第二关键字对应的字符串的右端点 SA[i]

		// 对 rank 排序，按照第二关键字从小到大放入 buf，保证出来时第一关键字相同的第二关键字有序
		for (int i = 0; i < buf_size; i++) buf[i] = 0;
		for (int i = 0; i < n; i++) buf[rank[SA_second[i]]]++;
		for (int i = 1; i < buf_size; i++) buf[i] += buf[i - 1];
		for (int i = n - 1; ~i; i--)
			SA[--buf[rank[SA_second[i]]]] = SA_second[i];

		int* preRank = rank;
		std::swap(rank, SA_second);
		t = 1;
		rank[SA[0]] = 0;
		for (int i = 1; i < n; i++)
			rank[SA[i]] = (preRank[SA[i - 1]] == preRank[SA[i]] &&
				SA[i - 1] + k < n && SA[i] + k < n && // note
				preRank[SA[i - 1] + k] == preRank[SA[i] + k]) ? t - 1 : t++;
		if (t >= n) break;
		buf_size = t;
	}
}
```

如果只看以上代码，你就会发现写的与描述的完全不一样，所以有必要重新解释一番。

首先，我们直接认为每个字符就是每个位置的 rank。这一步明显是对的，只是字符并不离散（如 a 对应的是 97 而不是 1，b 对应的是 98 而不是 2），所以我们首先得想办法把它离散化。

离散化这个操作是在第一次求 SA 时顺便进行的（描述里可没有用到 SA，但是实现时必须要用 SA）。我们对 rank 进行基数排序[^基数排序]，根据基数排序的过程描述，我们知道我们是在利用 rank 的排名对 rank 进行排序。rank 的排名不正是 SA 吗？于是我们就知道了一开始的 SA。但是我们不能写成 `SA[--buf[rank[i]]] = rank[i]`，因为此时 rank 有相同元素存在，直接这么写求出的就是对 rank 排序的结果了。所以我们就在这里离散化一下，于是我们得到了只看单个字符的 SA。

[^基数排序]: 这里只做了一趟，但是仍然叫做基数排序。

然后我们开始倍增。首先我们利用 SA 计算出第二关键字的 SA，然后我们就对 rank 进行排序。这里可以这么理解：如果两个 rank 本身都不一样，说明以它们开头的后缀已经能够比较了，我们直接比较就好了，否则就需要一些办法判断第二关键字。什么办法呢？当然就是基数排序啦！

如果我们按照代码中的方法去实现，我们就可以发现，如果 rank 一样，那么**下标小的** SA_second 将会排在前面。而 SA_second 的下标正好表示的是第二关键字的 rank，所以到此为止我们已经进行完了这一趟的倍增排序了。

我们拿到的实际上是这一趟排序的 SA，为了继续，我们必须还要知道这一趟的 rank。虽然最终结果 SA 和 rank 是一一对应的，**但是过程中我们要认为前缀相同的后缀的 rank 相同**，才能判断是否要继续排序。判断字符串是否一样只需要比较上一次的 rank 就可以了。如果两个字符串两部分的 rank 都一样，我们就认为它们是一样的。如果本质不同的串已经有 $n$ 个了，我们就退出。

其实，后缀数组倍增算法的基数排序与一般的基数排序还是有一点区别的。它要求你对基数排序的最后一部分有深入的理解。

## 后缀数组的应用

虽然求后缀数组很难，但是只掌握倍增算法是毫无用处的。后缀数组真正的精髓在于它的应用之广泛。

### 高度数组（Height）

##### 1. 最长公共前缀（Longest Common Prefix，LCP）

如果两个字符串的 LCP 长度为 $k$，就意味着这两个字符串的前 $k$ 个字符都相同，但是第 $k + 1$ 个字符不同，或者某个字符串一共只有 $k$ 个字符。

##### 2. 高度数组定义

对于一个串，我们可以求出它的后缀数组：

<center>$\mathrm{aabaaaab}$</center>

|  SA  |      |      |      |      |      |      |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  4   |  a   |  a   |  a   |  a   |  b   |      |      |      |
|  5   |  a   |  a   |  a↑  |  b   |      |      |      |      |
|  6   |  a   |  a↑  |  b   |      |      |      |      |      |
|  1   |  a   |  a↑  |  b   |  a   |  a   |  a   |  a   |  b   |
|  7   |  a↑  |  b   |      |      |      |      |      |      |
|  2   |  a   |  b↑  |  a   |  a   |  a   |  a   |  b   |      |
|  8   |  b   |      |      |      |      |      |      |      |
|  3   |  b↑  |  a   |  a   |  a   |  a   |  b   |      |      |

定义 $\mathrm{height}_i$ 表示 $\mathrm{SA}_{i}$ 和 $\mathrm{SA}_{i - 1}$ 的 LCP 长度（$\mathrm{height}_0$ 未定义）。（上面的后缀数组的 $\mathrm{height}$ 使用 ↑ 标志出来）

##### 3. 高度数组的性质

###### 性质 1

对于两个后缀 $j$ 和 $k$（$\mathrm{rank}_j < \mathrm{rank}_k$），则 $j$ 和 $k$ 的 LCP 长度为：
$$
\min_{j < i \le k} \{ \mathrm{height}_i \}
$$
使用 ST 表维护 RMQ 即可快速计算任意两个后缀的 LCP。

###### 性质 2

对于后缀 $i \pod {i > 0}$，有：
$$
\mathrm{height}_{\mathrm{rank_i}} \ge \mathrm{height}_{\mathrm{rank_{i - 1}}} - 1
$$
即后缀 $i$ 的 $\mathrm{height}$ 至少是后缀 $i - 1$ 的 $\mathrm{height}$ 减 1。

只要把数学表达式翻译成上面这句话，这个性质就不难证明了：截去两个字符串的第一个字符后，剩下的字符串的 LCP 的长度会减少 1。由于两个后缀的 LCP 长度等于一系列后缀的 $\mathrm{height}$（包括 $\mathrm{height}_i$）的最小值，所以 $i$ 的 $\mathrm{height}$ 至少是这么多。

##### 4. 求得 height 数组

利用性质 2 即可，时间复杂度为 $O(n)$，具体方法见代码：

```c++
int rank[maxn];
int height[maxn];
void GetHeight()
{
	for (int i = 0; i < n; i++) rank[SA[i]] = i;
	int same = 0;
	for (int i = 0; i < n; i++)
	{
		if (rank[i] == 0)
			same = 0;
		else
		{
			if (same) same--;
			int pre = SA[rank[i] - 1];
			while (i + same < n && pre + n < len && str[i + same] == str[pre + same])
				same++;
		}
		height[rank[i]] = same;
	}
}
```

由于 same 的减少次数为 $n$，不会再减少，而 same 的增加次数最多为序列的长度，所以时间复杂度为 $O(n)$。

## 常见模型[^参考资料]

[^参考资料]: 参考资料：[后缀数组应用小结](http://blog.csdn.net/Akak__ii/article/details/51278533)

##### 1. 可重叠的最长重复子串 

答案为 $\max \{ \mathrm{height} \}$。

##### 2. 不可重叠的最长重复子串问题

二分答案，将极值问题转换为判定性问题。假设二分的长度为 $\mathrm{mid}$，假设答案为 $i$ 和 $j$ $\pod {i < j}$，那么它们之间的 SA 值一定大于等于 $\mathrm{mid}$，即它们的 LCP 长度。

**找到所有 $\mathrm{height}$ 值大于等于 $\mathrm{mid}$ 的段。**如果其中最大的 SA 值减去最小的 SA 值大于等于 $\mathrm{mid}$，那么这两个后缀存在长度为 $\mathrm{mid}$ 的公共前缀（根据 $\mathrm{height}$ 性质）且互不重叠（根据 SA）。

##### 3. 可重叠的出现至少 k 次的最长重复子串

[Luogu 2852 牛奶模式](https://www.luogu.org/problemnew/show/P2852)

二分答案，把 SA 分成 $\mathrm{height}$ 大于等于 $\mathrm{mid}$ 的段，如果存在一段长度大于等于 $k$，那么可行。

##### 4. 重复出现两次的子串个数

[JZOJ 1598 文件修复](https://jzoj.net/senior/#main/show/1598)

答案为：
$$
\sum_{i = 1}^{n - 1} \max (\mathrm{height}_i - \mathrm{height}_{i - 1}, 0)
$$
大概的意思：

![](pic\后缀数组 4.png)

##### 5. 重复出现至少 k 次的子串个数

使用 $\mathrm{height}$ 数组，发现问题其实是一个矩形并集的问题：

![](pic\后缀数组 5.png)

问题其实是要求出竖着的长度大于等于 $k - 1$ 的矩形的个数（矩形不能横向拆开）。使用单调栈即可，用类似于求最大矩形的方法，需要对矩形进行合并。注意，当 $k = 1$ 时，需要特判处理，相当于是在询问**不相同的子串个数**：

```c++
if (k == 1)
{
	LL ans = 0;
	for (int i = 0; i < n; i++)
		ans += n - SA[i] - height[i];
	printOut(ans);
}
```

```c++
height[n] = 0;
for (int i = 0; i <= n; i++)
{
	int w = 0;
	while (!s.empty() && height[i] < s.top().height)
	{
		Rect t = s.top();
		s.pop();
		w += t.width;
		if (w >= k - 1)
		{
			if (!s.empty())
				ans += t.height - std::max(s.top().height, height[i]);
			else
				ans += t.height - height[i];
		}
	}
	if (!s.empty() && s.top().height == height[i])
		s.top().width += w + 1;
	else
		s.push(Rect(height[i], w + 1));
}
printOut(ans);
```

重复出现恰好 $k$ 次的子串个数的计算方法与之类似，只需要统计答案时必须要严格满足 $w = k - 1$ 即可。

##### 6. 字典序第 k 小（本质不同）子串

[JZOJ 2824 [GDOI 2012] 字符串](https://jzoj.net/senior/#main/show/2824)

先求出后缀数组中每个位置对答案的贡献，再在它的前缀和上二分，时间复杂度 $O(n \log n)$。注意分清 SA 和 rank：SA 表示第 $i$ 小是谁（在哪），rank 表示 $i$ 是第几小。

```c++
int contri[maxn];
void run()
{
	scanf("%s", str);
	n = strlen(str);
	GetSA();
	GetHeight();
	for (int i = 0; i < n; i++)
		contri[i] = (n - SA[i]) - height[i];
	for (int i = 1; i < n; i++)
		contri[i] += contri[i - 1];
	int q = readIn();
	while (q--)
	{
		int x = readIn();
		if (x > contri[n - 1])
		{
			printOut(-1);
			putchar('\n');
			continue;
		}
		int pos = std::lower_bound(contri, contri + n, x) - contri;
		int len = pos ? height[pos] + (x - contri[pos - 1]) : x;
		for (int i = SA[pos], j = 0; j < len; i++, j++)
			putchar(str[i]);
		putchar('\n');
	}
}
```

##### 7. 连续重复子串问题

给定一个字符串 $L$，已知这个字符串是由某个字符串 $S$ 重复 $r$ 次得到的，求 $r$ 的最大值。

这个问题显然可以使用 $\mathrm{border}$ 解决，哈希往往也能卡过去。下面让我们来看看后缀数组是怎么解决它的。（不具实用价值）

------

枚举串 $S$ 的长度 $k$，如果 $\mathrm{LCP}(\mathrm{suffix}_0, \mathrm{suffix}_{k}) = |L| - k$，那么当前答案合法。

##### 8. 重复次数最多的连续重复子串

给定一个字符串 $L$，求重复次数最多的连续重复子串。

------

枚举重复子串的长度 $len$，然后求长度为 $len$ 的子串最多能连续出现几次。假设子串 $s$ 在原字符串中出现了 $2$ 次，那么 $s$ 肯定包括了字符 $L_0$，$L_l$，$L_{2l}$，$\cdots$ 中某相邻的两个，所以只需看 $il$ 和 $(i + 1)l$ 往前和往后能匹配多远（即向两个方向扩展），再除以子串长度就是出现次数了（如图）。

![](http://img.blog.csdn.net/20161104093604718)

向后匹配可以直接使用 $\mathrm{RMQ}$ 求 $\mathrm{LCP}$；向前匹配可以将串反过来再做一次预处理，但是这样做效率较低。正确的方法有缘再会。