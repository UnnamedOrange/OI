[TOC]

# 轮廓线动态规划

## 骨牌覆盖问题

&emsp;&emsp;给你一个 $n \times m$ 的棋盘，给你若干个 $1 \times 2$ 的骨牌，问有多少种摆放骨牌的方式使得骨牌恰好覆盖整个棋盘，这被称为*骨牌覆盖问题*。

参考资料：[hihoCoder](http://hihocoder.com/)

##### 1. [$2 × n$ 的骨牌覆盖问题](http://hihocoder.com/problemset/problem/1143)

&emsp;&emsp;毫无疑问，要么横着放两个，要么竖着放一个，没有别的合法方案，于是得到递推方程：
$$
f_n = f_{n - 1} + f_{n - 2}
$$
&emsp;&emsp;时间复杂度 $O(2^3 \log n)$。

##### 2. [$3 × n$ 的骨牌覆盖问题](http://hihocoder.com/problemset/problem/1151) 

&emsp;&emsp;多了一行，复杂度却上升了不止一个档次。我们考虑**增加状态**来简化转移。

&emsp;&emsp;假设我们已经放好了前 $i - 1$ 列骨牌，对于第 $i$ 列骨牌，会有 $2^3 = 8$ 种情况：

![](http://media.hihocoder.com/problem_images/20150418/14293404042701.png)

&emsp;&emsp;我们可以用一个三位的二进制数表示这八种情况：

![](http://media.hihocoder.com/problem_images/20150418/14293404048152.png)

&emsp;&emsp;为了方便，我们将棋盘旋转一下。假设我们正在放置第 $i$ 行的骨牌，那么会有下面三种方式：

![](http://media.hihocoder.com/problem_images/20150418/14293404048833.png)

<center>灰色表示已有骨牌</center>

&emsp;&emsp;根据经验，我们设 $f_{i, S}$ 表示处理到第 $i$ 行，**前 $i - 1$ 行的骨牌已经放满，$i + 1$ 行之后得骨牌都没有放**，第 $i$ 行放骨牌的状态为 $S$ 的方案数。那么最终答案为 $f_{n, (111)_2}$。

###### 构造方法

&emsp;&emsp;对于第 $i$ 行，我们有三种放骨牌的方法：

1. 某个位置不放骨牌，则第 $i - 1$ 行对应位置必须有放置的骨牌，否则前 $i - 1$ 行骨牌没有放满，不满足条件。
2. 某个位置竖放骨牌（注意转回来就是横着放的意思），则第 $i - 1$ 行对应位置必须没有放置骨牌，否则这个骨牌和之前的就重叠了，不是合法方案。
3. 某个位置横放骨牌，则第 $i - 1$ 行对应的两个位置必须有放置的骨牌，否则前 $i - 1$ 行骨牌没有放满。

&emsp;&emsp;例如，对于 $f_{i, (001)_2}$，我们可以转移到 $f_{i + 1, (110)_2}$：

![](http://media.hihocoder.com/problem_images/20150418/14293404046915.png)

&emsp;&emsp;需要注意的是，我们做的是多段图的动态规划，只能从前一段转移到后一段，而不能在同一段中转移。换句话说，只能从 $f_{i, S}$ 转移到 $f_{i + 1, S'}$，而不能从 $f_{i, S}$ 转移到 $f_{i, S'}$。

![](http://media.hihocoder.com/problem_images/20150418/14293404045844.png)

<center>不正确的转移：在同一段中进行转移，转移图中出现了圈</center>

&emsp;&emsp;你可能会说：这可以看作从 $f_{i, 1}$ 转移到 $f_{i + 1, 0}$ 啊。但是这与我们动态规划状态的含义不符。我们设的是正在处理第 $i$ 行，那么我们只能在第 $i$ 行放骨牌，不能在 $i - 1$ 行放骨牌了（竖放骨牌仍然算作放在第 $i$ 行的，因为我们是在第 $i$ 行做的决策）。

------

&emsp;&emsp;对于每个状态 $S$，我们手工计算当上一个状态为 $S'$ 时是否有转移。邀请神仙计算后，我们得到如下转移矩阵：

![](http://media.hihocoder.com/problem_images/20150418/14293404047166.png)

<center>转移矩阵（空白的地方都是 $0$）</center>

&emsp;&emsp;边界条件为 $f_{0, (111)_2} = 1$，其余为 $0$。时间复杂度 $O((2^3)^2 \log n)$。

##### 3. [$k × n$ 的骨牌覆盖问题](http://hihocoder.com/problemset/problem/1162)

&emsp;&emsp;根据 $3 \times n$ 的骨牌覆盖问题给我们的经验，我们知道：$k \times n$ 的转移矩阵将会是 $2^k \times 2^k$ 的。我们只能想办法编程计算出转移矩阵。

###### ①构造转移

&emsp;&emsp;假设我们已经有第 $i - 1$ 行的状态了，根据[前面放骨牌的方法](#构造方法)，我们可以找到唯一的一个第 $i$ 行的状态使其可以转移，或者宣布找不到一个可以转移的状态。

&emsp;&emsp;我们不妨**一列一列**地进行决策，用 DFS 构造两个状态使得它们能够转移，当找到两组能够转移的状态时我们就修改转移矩阵中的值。

###### ②参考代码

```c++
void MakeMatrix(Matrix& r, int colum, int from, int to)
{
	if (colum == m)
	{
		r.c[from][to] = 1;
		return;
	}
	else if (colum > m) return;
	MakeMatrix(r, colum + 1, from << 1 | 1, to << 1); // 不放
	MakeMatrix(r, colum + 1, from << 1, to << 1 | 1); // 竖放
	MakeMatrix(r, colum + 2, from << 2 | 3, to << 2 | 3); // 横放
}
```

###### ③当 $n$ 较小时

&emsp;&emsp;当 $n$ 较小时，我们不必使用矩阵乘法加速，因为这时往往 $k$ 比较大，使用 $O((2^{k})^3)$ 的矩阵乘法反而很慢。我们直接保存最近两次的状态进行转移，这样我们的空间复杂度为 $O(2^{k} n)$，时间复杂度为 $O(2^{2k}n)$。

```c++
std::vector<int> transfer[1 << 11];
void MakeTransfer(int colum, int from, int to)
{
	if (colum == m)
	{
		transfer[from].push_back(to);
		return;
	}
	else if (colum > m) return;
	MakeTransfer(colum + 1, from << 1 | 1, to << 1); // 不放
	MakeTransfer(colum + 1, from << 1, to << 1 | 1); // 竖放
	MakeTransfer(colum + 2, from << 2 | 3, to << 2 | 3); // 横放
}
```

```c++
int U = 1 << m;
f[0][U - 1] = 1;
MakeTransfer(0, 0, 0);
for (int i = 1; i <= n; i++)
{
	int* cnt = f[i & 1];
	int* pre = f[!(i & 1)];
	memset(cnt, 0, sizeof(int) * U);
	int* trans;
	for (int S = 0; S < U; S++) // 上一个状态
	{
		trans = transfer[S].data();
		for (int j = 0, to = transfer[S].size(); j < to; j++)
			(cnt[trans[j]] += pre[S]) %= mod;
	}
}
printOut(f[n & 1][U - 1]);
```

&emsp;&emsp;这种用 `vector` 保存状态的方法很不错，在实际表现下时空都很优秀。如果空间实在开不下，可以考虑直接调用 `MakeTransfer` 函数进行转移，用时间换空间。

## 轮廓线动态规划

##### 1. 从骨牌覆盖问题谈起

&emsp;&emsp;回忆我们是如何解决 $3 \times n$ 乃至 $k \times n$ 的骨牌覆盖问题的。**我们令每一行为一个阶段，一行一行地进行填充。**这种以行为阶段并通过保存其每一行的具体状态（使用状态压缩）进行转移的，我们称之为*轮廓线动态规划*。



……剩下的，有缘再学了。
