#####[JZOJ 5060 公路建设](https://jzoj.net/senior/#main/show/5060)

###### ①60 分做法

​	我们知道暴力算法：直接使用 Kruskal 即可。

​	Kruskal 算法需要先按边权排序，而这三个特殊的测试点并不需要。但是跑 Kruskal 肯定是不可能的，有什么好的方法吗？

​	考虑从大到小添加边，==每次添加后，如果形成了环，就删除环上的最大边。==这是加边的 MST 的套路。==**因为最多只有 n - 1 条边，所以我们用一个数组保存有哪些边即可。这种算法不需要将边保存成邻接矩阵或者邻接表的形式。**==

​	考虑询问 $[l, m]$ 的情况。只需要从 $m$ 到 $l$ 一直维护就可以了。**由于按处理的顺序边权递减，被删去的边永远不可能再被添加。**

​	所以考虑离线询问 $[l, r]$ 。加边时，如果形成了环，就重构；计算时，**只考虑 $[l, r]$ 中的已经选择的边。**可以用反证法证明这是正确的：如果需要考虑 $[l, r]$ 中已经删除了的边，而使它被删除的边是一定存在与 $[l, r]$ 的，因此不需要考虑被删除了的边。**这个做法要求边权是从小到大递增的。**

​	可以用树状数组维护添加了的边的边权和。

​	时间复杂度为 $O(mn \log m + q \log m)$。

###### ②100 分做法

​	考虑使用线段树。==**首先最重要的一点还是最多只会有 $n - 1$ 条边属于最小生成森林。**==所以我们可以对两个区间的最小生成森林的边归并排序后跑 Kruskal，得到大区间的最小生成森林。这个使用线段树来做。

​	查询的操作与初始化的操作类似。可以把结果保存在一个线段树结点中。

​	初始化的时间复杂度为 $O(\alpha(n) \, nm)$，单次查询的时间复杂度为 $O(\alpha(n) \, n \log m)$。

##### [JZOJ 4079 管道连接](https://jzoj.net/senior/#main/show/4079)

###### ①思路

​	先明确一点，如果所有情报站的频道相同，那么这道题就是一个裸的斯坦纳树。

​	可以用斯坦纳树求出所有情报站作为全集的答案，这样就可以得到某个频道的情报站连通的答案了。如何求某个集合的答案呢？$F_{S} = \min \{ f_{i, S} \}$。

​	对于两个频道的情报站，它们首先可以是完全连通的（$F_{S_1 \cup S_2}$），也可以是分成两块的（$F_{S_1} + F_{S_2}$）。同样，如果不存在分成两块的方案，那就一定有重边，$F_{S_1} + F_{S_2}$ 就一定比 $F_{S_1 \cup S_2}$ 大。**这里也用了非法解不会最优的思想。**

###### ②实现

​	首先做斯坦纳树。

​	然后设**频道**集合的全集为 $U$，设使频道集合 $S$ 的各频道建立了通道连接的最小代价为 $g_{S}$。我们实际上求的就是 $g_U$。

​	考虑用动态规划。
$$
g_S = \min(\min \{ 
g_{S_0} + g_{S_1} (S_0 + S_1 = S)
\},
F_{S}
)
$$
​	注意这里是频道集合，但是我们枚举重要情报站集合要方便些，所以可以先预处理某个重要情报站集合是不是能够代表一个完整的频道集合（即不存在某个频道的情报站出现但没有全部出现）。

###### ③最后部分的参考代码

```c++
for (int S = 0; S < U; S++)
for (int i = 1; i <= n; i++)
	g[S] = std::min(g[S], f[i][S]);

init();
for (int S = 0; S < U; S++)
{
	if (!isComplete[S]) continue;
	for (int S0 = (S - 1) & S; S0; S0 = (S0 - 1) & S)
	{
		int S1 = S ^ S0;
		if (!isComplete[S0]) continue;
		g[S] = std::min(g[S], g[S0] + g[S1]);
	}
}
printOut(g[U - 1]);
```

###### ④时间复杂度

​	$O(3^{p}n + 2^{p}k|E| + 2^{p}p + 3^{p})$