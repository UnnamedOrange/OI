[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 吉司机线段树

#### 区间最值操作问题

什么叫做区间最值操作？一般，我们对线段树的操作无非就是单点加，区间加这种简单玩意儿。区间最值操作指：对于一个序列 $A$， 给出三个数 $l$，$r$，$x$，对所有的 $i \in [l, r]$，把 $A_i$ 变成 $\max(A_i, x)$ 或者 $\min(A_i, x)$。这时以前的线段树就挂掉了。

##### 1. e.g. [Gorgeous Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=5306)

###### 题目大意

给出一个长度为 $n$ 的数组 $A$，有 $m$ 次操作，操作分为三种：询问区间最大值，询问区间和，将一个区间内的数全部对参数 $x$ 取 $\min$。$n, m \le 10^6$。

###### Naive

曾经一度，有一个带有区间取模操作的线段树，那时我们只需要保存一下整个序列的最大值，如果需要操作暴力更新就好了，**因为每次被修改的数的大小至少减小一半，所以最多操作 $O(n \log n)$ 次**。这里我们也试着保存一个最大值，当无需操作时直接退出，否则继续递归。

遗憾的是，这么做时间复杂度是得不到保证的，**因为不能保证每次更新所有数至少减少一半，所以操作次数是没有上限的**，时间复杂度将会被卡成 $O(mn \log n)$。

###### 吉司机来了

考虑另外一种解法：对线段树中的每一个结点除了维护 $\mathrm{sum}$ 以外，还要额外维护区间中的最大值 $\mathrm{major}$，**严格次大值 $\mathrm{minor}$**，以及**最大值个数 $t$**。

修改时，我们不像之前那样，分成需要暴力修改，不需要暴力修改两种情况，而是分成三种情况：

1. 当 $\mathrm{major} \le x$ 时，显然直接退出就好了。
2. 当 $\mathrm{minor} < x < \mathrm{major}$ 时，显然这次修改只会影响到所有的最大值，所以我们可以直接把 $\mathrm{sum}$ 加上 $t \cdot (x - \mathrm{major})$，再把 $\mathrm{major}$ 更新为 $x$，打上懒惰标记后退出即可。 
3. 当 $x \le \mathrm{minor}$ 时，我们无法直接更新这个结点的信息，因此我们暴力递归下去。

~~然后你就超时了。~~额，超时其实是输入输出优化的问题，你用 `fread`，然后你就过掉了。

------

为什么这么做就特别快呢？难道不是 $O(mn \log n)$ 的吗？吉司机告诉你，可以证明，这个算法的**均摊时间复杂度为 $O(m \log n)$**。

> 证明
>
> 先直观感受下：如果操作参数 $x$ 相当大，我们将无需做任何操作；如果操作参数 $x$ 相当小，我们暴力修改时将会修改所有的结点，但是以后就不再存在 $\mathrm{minor}$，也就无需暴力修改了。
>
> 给线段树上的每个结点定义一个势能函数 $\Phi$ 表示**该结点对应的序列中**不同的值的个数。当无需暴力修改时，$\Phi$ 显然不会变化；当需要暴力修改时，说明至少 $\mathrm{major}$ 和 $\mathrm{minor}$ 会比修改成一个相同的数，也就是说 $\Phi$ 至少会减少 1。当一个结点的 $\Phi = 0$ 时，我们不需要下去暴力修改；而初始时 $O(\sum \Phi_i) = O(n \log n)$，所以单次操作的均摊时间复杂度为 $O(\log n)$。得证。

笼统地讲，如果暴力修改能够降低势能函数，我们就去暴力修改，否则我们直接使用标记。 

##### 2. e.g. Picks loves segment tree

###### 题目大意

给出一个长度为 $n$ 的数组 $A$，有 $m$ 次操作，操作分为三种：询问区间和，将区间内的数全部加上参数 $ \pod{x \in \Z}$，将一个区间内的数全部对参数 $x$ 取 $\min$。$n, m \le 10^6$。

###### 吉司机告诉你

加上了区间加减后，之前的信息仍可维护，沿用上一题的做法即可。

###### 吉司机带你开车

这下时间复杂度就不是那么好证明了，但是还是能够证明的。吉司机告诉你，这个算法的均摊时间复杂度为 $O(m \log^2 n)$，且这个上界比较松，实际表现却更接近 $O(m \log n)$ 的时间复杂度。

> 证明
>
> （没有看懂）

翻车了……总的来说，吉司机线段树的一个主要方法是记录一个次小值，剩下的有缘再会。