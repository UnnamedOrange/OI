##### 分块算法

​	分块算法是指，把序列上的问题分成一块一块的，然后分别维护其信息。查询时，如果待查询区间是一整块（多个整块），那么对于每一个整块就用维护好的信息 O(1) 得到答案；如果待查询区间不是一个整块（对于一个很大的查询区间，这种情况一定出现在区间两端），**就一个元素一个元素地暴力计算答案**。修改时，如果只存在单点修改，直接修改该点并维护对应块的信息即可；如果存在区间修改，则加上一个修改标记，往往这个标记是怠惰的。修改区间操作时，跟查询区间的操作类似，中间整块改，两边暴力改。

​	不难发现，如果块的大小为 $\sqrt {n}$，那么整个操作的时间复杂度将是 $O(n \sqrt {n})$ 的。**因此，用这种算法在 1 s 内能够解决 n 大约为 50000 的问题。**

#####[JZOJ 4243](https://jzoj.net/senior/#main/show/4243)

- [x] 分块维护桶

######①分块

​	直接每个区间开一个桶，然后每个区间加上一个标记即可。**标记的含义为当前块的数以及桶都加上了 v。**

###### ②标记

​	**注意块标记的含义。**查询时，**暴力查询应当检查 a[i] + flag 是否在 S 中，而区间查询则查询 S[i] - flag 的个数**。修改时，**暴力修改只维护 a[i] 和桶，不管标记的事；而区间修改时只需要修改标记**。

​	**还要注意在加了标记后是否会有数组越界等问题。**

###### ③分块处理

​	一种自认为可以的做法是分两种情况处理分块。首先计算出点在哪个块中，以及 l 所在块的最后一个元素的位置和 r 所在块的第一个元素的位置。

```c++
	INT l = readIn();
	INT r = readIn();
	INT lInBlock = (l - 1) / sqrtN;
	INT lEnd = (lInBlock + 1) * sqrtN;
	INT rInBlock = (r - 1) / sqrtN;
	INT rBegin = rInBlock * sqrtN + 1;
```

​	然后分成两种情况处理。当 lInBlock = rInBlock 时，直接暴力修改 l 和 r。否则，分成三段处理，**而此时的 lEnd 和 rBegin 一定是有效的**。

```c++
	if (lInBlock == rInBlock)
	{
		for (int i = l; i <= r; i++);
	}
	else
	{
		for (int i = l; i <= lEnd; i++);
		for (int i = lInBlock + 1; i <= rInBlock - 1; i++);
		for (int i = rBegin; i <= r; i++);
	}
```

##### [Luogu 3203](https://www.luogu.org/problemnew/show/3203)

###### ①分块

​	分块后，**维护每一个元素跳到下一块的位置以及所需要的步数。**单次跳跃的时间复杂度则为 $O(\sqrt {n})$。修改时，只需要从被修改点修改到块的开头，时间复杂度为 $O(\sqrt {n})$。

###### ②线性递推

​	更新时，不要每个点重新计算，要用递推的方式计算，这样计算的时间复杂度是线性的。

​	类似的思想在预处理时经常会遇到，只不过预处理对时间的要求一般不高，所以尝尝被我们忽视了。

##### [JZOJ 4438](https://jzoj.net/senior/#main/show/4438)

###### ①分块

​	每一块保存一个标记和分块内的排序序列。

###### ②K 小数

​	二分 K 小数，然后通过计算有多少个数来进行二分操作。

​	若**小于等于 x 的数的个数小于 k，则 r = mid；否则 l = mid + 1。**

###### ③时间复杂度分析

​	修改时，区间修改的时间复杂度为 $O(\sqrt {n})$，单点修改的时间复杂度为 $O(\sqrt {n} \; \log \sqrt {n})$。

​	查询时，区间查询的时间复杂度为 $O(\sqrt {n} \; \log \sqrt {n})$，单点查询的时间复杂度为 $O(\sqrt {n})$。

​	总时间复杂度为 $O(n^{\frac {3} {2}} \log \sqrt {n})$。

##### [BZOJ 4241](http://www.lydsy.com/JudgeOnline/problem.php?id=4241) 

###### ①分块

​	预处理 $ans_{i, j}$ 表示第 $i$ 块到 $j$ 块的答案。

​	==预处理 $sum_{i, j}$ 表示**前** $i$ 块中元素 $j$ 的出现次数。==

​	每次计算时，如果在同一块内，就直接暴力计算。

​	如果在不同块内，我们先计算出中间整块的答案。如果只有两边零散的数才有可能使中间整块的答案 $ans_{i, j}$ 不是最终答案，我们就在这么做：拿出两边零散的数（知道了有影响的数有哪些），然后通过预处理的数据重新计算中间的整块，再加上两边的数就行了。

​	怎么快速计算呢？这就要求我们能快速知道两边的数在中间出现了多少次，这就是 $sum_{i, j}$ 的作用。

###### ②技巧

​	可以预处理 $inBlock$，$lBegin$，$rEnd$。

```c++
for (int i = 1; i <= n; i++)
{
	INT t = inBlock[i] = (i - 1) / sqrtN;
	if (!lBegin[t])
		lBegin[t] = i;
	rEnd[t] = i;
}
```

​	可以这样计算**前 $i$ 块各元素的出现次数**：先计算出元素在每一块的出现次数，然后求一个前缀和。

```c++
for (int i = 1; i <= n; i++)
	times[inBlock[i]][a[i]]++;
for (int i = 1; i < N; i++)
	for (int j = 1; j <= bound; j++)
		times[i][j] += times[i - 1][j];
```

######③时间复杂度分析

​	预处理每一块元素出现次数的前缀和：$O(n \sqrt {n})$。

​	预处理每一块的答案：$O(n \sqrt {n})$。

​	每次查询暴力：$O(\sqrt {n})$。

​	每次查询包含整块：$O(\sqrt {n})$。

###### ④总结

​	（1）这种分块与之前的不同的是，因为只拿到一个块的信息是没有用的，所以需要使块的信息有==**区间处理**==的功能。通过这种方式，仍然可以做到根号时间复杂度完成计算。

​	（2）这其中的一个重点便是：求前 $i$ 块的某种信息的前缀和。

​	（3）在预处理答案时，需要注意一点：

```c++
for (int i = 0; i < N; i++)
{
	buf[0] = 0;
	long long t = 0; //要开个临时变量！
	for (int j = lStart[i]; j <= n; j++)
	{
		appear[a[j]]++;
		t = std::max(t, (long long)appear[a[j]] * disc[a[j]]);
		if (j == rEnd[inBlock[j]])
			ans[i][inBlock[j]] = t;
	}
	memset(appear, 0, sizeof(appear));
}
```

#####[BZOJ 3744](http://www.lydsy.com/JudgeOnline/problem.php?id=3744)

###### ①分块

​	预处理 $ans_{i, j}$ 表示第 $i$ 块到 $j$ 块的答案。

​	预处理 $sum_{i, j}$ 表示**前** $i$ 块中元素 $j$ 的出现次数==**的前缀和**==。

​	对于两边的元素，使用 $sum_{i, j}$ 计算中间的对它们的贡献，用归并排序计算两边自己的贡献。

###### ②技巧

​	计算 $sum_{i, j}$ 时，明显要算前缀和。由于之前写了个树状数组，因此就可能会直接去用它。稍加分析便发现，可以直接跑前缀和，因为它不会改变。

```c++
for (int i = 1; i <= n; i++)
	times[inBlock[i]][a[i]]++;
for (int i = 1; i < N; i++)
	for (int j = 1; j <= bound; j++)
		times[i][j] += times[i - 1][j];
for (int i = 0; i < N; i++)
	for (int j = 2; j <= bound; j++)
		times[i][j] += times[i][j - 1];
```

​	计算中间的对两边的贡献，就用 $sum$ 计算，方式有点主席树的味道。

```c++
for (int i = l, to = rEnd[inBlock[l]]; i <= to; i++)
	t += right[a[i] - 1] - left[a[i] - 1];
for (int i = lBegin[inBlock[r]]; i <= r; i++)
	t += right[bound] - right[a[i] + 1 - 1] - (left[bound] - left[a[i] + 1 - 1]);
```

###### ③时间复杂度分析

​	预处理 $O(n \sqrt {n} \log n)$，单次询问 $O(\sqrt {n} \log n)$。

###### ④求逆序对的两种简单方法的总结

​	求逆序对有世人皆知的两种方法：归并排序和树状数组。

​	这两个算法的应用背景应该是本质不同的。树状数组更适合动态的模式，它能求出前 $i$ 个元素的逆序对数，==**但是它不能多次求不同序列的逆序对，因为清空树状数组的时间是无法承受的。**==归并排序适合多次求小块的不同序列的逆序对，==**它不需要额外的时间去清空数组。**==

​	这道题中，这两个方法的区别得到了很好的体现。前面初始化答案时，由于要更新每一块的答案，所以只能使用树状数组；后面要计算两边的数据时，时间复杂度是对的，但是由于每次询问都要求一次，因此不能用树状数组，只能归并排序。

##### 莫队算法

###### ①适用条件

​	在知道了 $ans_{l, r}$ 的情况下，如果我们能够计算出 $ans_{l - 1, r}$，$ans_{l + 1, r}$，$ans_{l, r - 1}$，$ans_{l, r + 1}$，那么就能使用莫队算法。

######②概念

​	莫队算法是一种==**离线算法**==。 其原理是改变询问的操作顺序，在满足适用条件的情况下==直接暴力扩张或收缩区间，就能在一个可行的时间复杂度内解决问题。==

###### ③方法

​	将所有询问==以**左端点所在块**为第一关键字，**右端点**为第二关键字==进行排序。

​	设区间扩张或收缩一个单位的时间复杂度为 $O(1)$，则时间复杂度为 $O(max(n, q) \sqrt {n})$。[^1]

[^1]: 在接下来说明块大小之前，我们先假设块大小为 $\sqrt {n}$。  

######④时间复杂度分析

​	当左端点所在块确定时，右端点单调，所以左端点在同一块内时移动右端点的时间复杂度为 $O(n)$，总共有 $O(\sqrt {n})$ 块，所以==向右移动右端点的总时间复杂度为 $O(n \sqrt {n})$。==

​	当左端点所在块变动时，移动右端点的时间复杂度为 $O(n)$，总共有 $O(\sqrt {n})$ 块，所以==向左移动右端点的总时间复杂度为 $O(n \sqrt {n})$。==

​	当左端点所在块确定时，移动一次左端点的时间复杂度为 $O(\sqrt {n})$ ，总共会有 $q$ 次移动，所以==块内移动左端点的总时间复杂度为 $O(q \sqrt {n})$。==

​	当左端点所在块变动时，相当于从左往右移动左端点，所以==块间移动左端点的总时间复杂度为 $O(n)$。==

​	所以整体的时间复杂度为 $O(max(n, q) \sqrt {n})$。

​	==在一般情况下，莫队算法能过通过数据规模为 $10^5$ 的题。==

###### ⑤块大小

​	很明显，上面的时间复杂度不是很好，因为我们要取一个 $max$，也就是说时间复杂度可能是不正确的。

​	正确的块大小是：$\frac {n} {\sqrt {q}}$，则有 $\sqrt {q}$ 块。

​	在块大小为它的情况下，移动右端点的时间复杂度为 $O(n \sqrt {q})$；块内移动左端点的时间复杂度为 $O(n \sqrt {q})$；块间移动左端点的时间复杂度为 $O(n)$。

​	所以莫队算法的正确时间复杂度为 $O(n \sqrt {q})$。

###### ⑥技巧

​	排序时，若两个询问在相同块，不要直接 $r$ 升序排序，而要这么做：==若 $l$ 为偶数（$l$ 从 $0$ 开始），则 $r$ 为升序；若 $l$ 为奇数，则 $r$ 为降序。==用这种方法能大幅降低程序的运行时间。原理很明显。

​	注意区间扩张和收缩处理时的区别。扩张时，先更改端点位置，再更新答案；收缩时，先更新答案，再更改端点位置。

​	可以将扩张和收缩写成一个函数。

##### [JZOJ 3568 小纪的作业题](https://jzoj.net/senior/#main/show/3568)

​	直接使用莫队算法就可以了。

​	维护每种数的出现次数以及每种数对答案的贡献。提前计算出逆元，便能过掉此题。

##### 树上的莫队算法

###### ①概念

​	树上的莫队算法，即将莫队算法应用到树上，将树上的问题的时间复杂度降低到根号级。

###### ②方法

​	首先需要得到树的括号序（见树上问题求解）。

​	设在括号序中的第一个位置为 $dfn_{i}$，第二个位置为 $end_{i}$。

​	若要求 $j$ 到 $k$ 之间路径的信息，根据它们的相对位置分成两种情况讨论：

​	（1）若 $j$ 是 $k$ 的祖先，则路径对应括号序中的 $[dfn_{j}, dfn_{k}]$。

​	（2）若 $j$ 和 $k$ 互不为祖先，则路径对应括号序中的 $[end_{j}, dfn_{k}]$（需要满足$end_{j} < dfn_{k}$）。这么做的话，就没有算上 $j$ 和 $k$ 的 LCA，要额外算上；在 $j$ 到 $k$ 路径外的，都出现了两次。

​	然后将括号序当作序列，用序列上的莫队来做。

