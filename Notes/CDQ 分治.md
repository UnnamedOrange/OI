[TOC]

# 从归并排序到 CDQ 分治

>   开局一个 Markdown，内容全靠编。——Orange

## Part 1 引入

##### 1. 归并排序

&emsp;&emsp;下面是一段众所周知的归并排序的代码：

```c++
int origin[maxn];
int temp[maxn];
void mergesort(int l, int r)
{
	if(l >= r) return;
	int mid = (l + r) >> 1;
	mergesort(l, mid); mergesort(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && origin[i] <= origin[j])) // <= for stable sort
			temp[k++] = origin[i++];
		else
			temp[k++] = origin[j++];
	}
	for(i = l; i <= r; i++)
		origin[i] = temp[i];
}
```

&emsp;&emsp;不同于快速排序，其最坏时间复杂度为 $O(n \log n)$，但是归并排序需要 $O(n)$ 的额外空间。

###### 归并排序能干什么

&emsp;&emsp;最广为人知的应用便是~~排序以及~~计算序列的逆序数。

&emsp;&emsp;对于序列 $\{ a_i \}$，如果存在两个正整数 $1 \le i < j \le n$ 且 $a_i > a_j$，则称 $a_i$ 与 $a_j$ 为一个逆序对。求逆序对个数最简单的方法莫过于枚举 $i$ 和 $j$ 了，但是这么做的时间复杂度是 $O(n^2)$ 的。归并排序能够在 $O(n \log n)$ 的时间复杂度内“顺便”完成这一操作。

```c++
// ...
		if (!(j <= r) || (i <= mid && origin[i] <= origin[j])) // note 
			temp[k++] = origin[i++];
		else
		{
			nInvPair += mid - i + 1;
			temp[k++] = origin[j++];
		}
```

&emsp;&emsp;注意上面的比较部分。在原始的归并排序中，既可以使用 `<` 也可以使用 `<=`，但是仅当使用 `<=` 时才有稳定排序的效果。而在求逆序数时，实际上我们是要**计算左边的序列对右边的序列的贡献**，对于右边的每个数，这个贡献就是左边**大于**自己的数的个数。上面的实现方式中，只能使用 `<=` 才保证计算的是大于自己的数的个数；**使用 `<` 时得到的是大于等于自己的数的个数，与题意不符。**

##### 2. 逆序数与权值树状数组

&emsp;&emsp;不难发现，**归并排序求逆序数是一种离线算法。**也就是说，我们需要先读入整个序列，才能求出这个序列的逆序数；如果不断地在序列尾部添加整数[^整数]以构成新的序列，那就只能使用权值树状数组求解。

[^整数]: 由于树状数组其实是一个数组，所以最原始的权值树状数组的权值在一定的正整数范围内；稍加修改能够使权值范围扩大到一定的整数范围。可见使用权值树状数组求解逆序数问题还是有相当大的局限性。

&emsp;&emsp;一般来说，这个问题还是不会要求用这种方式在线的（毕竟这个问题还是挺特殊的，不会把数插入到中间！），所以离散化原序列再结合权值树状数组求解是个不错的做法。由于这个算法本身比较经典，也不在我们的讨论范围内，所以就不再详细阐述它了。但是有一个十分有用的小技巧，用于清空权值树状数组：

```c++
struct BIT
{
	int c[maxk];
	inline int lowbit(int x);
	int add(int pos, int val);
	int query(int pos);
	void clear(int pos)
	{
		while(pos <= k)
		{
		    if(c[pos]) c[pos] = 0;
		    else break;
		    pos += lowbit(pos);
		}
	}
};
```

```c++
// ...
	for(int i = l; i <= r; i++) bit.add(a[i], 1);
	// do something
	for(int i = 1; i <= r; i++) bit.clear(a[i]);
```

&emsp;&emsp;当实际权值范围很小，数组却很大时，这种方法避免了直接使用 `memset` 导致的时间复杂度错误。

## Part 2 二维偏序问题

##### 1. 引例

e.g. 给定一个长度为 $n$， 初始为空的序列 $\{ a_i \}$，给定 $m$ 个操作，操作分为两种：将某个位置的值修改为 $x$；查询 $\sum_{i = l}^{r} a_i$。$n \le 10^9$，$m \le 5 \times 10^5$，不要求在线。

###### 在线算法

&emsp;&emsp;尽管不要求在线，但是我们还是老老实实地用在线算法去做它。不难发现，无法使用树状数组去解决这个“树状数组裸题”，因为 $n$ 的范围太大。所以你决定写一个不知道能不能对（因为码力低下，可能超时，可能答案错误）的动态开点线段树。

###### 离线算法

&emsp;&emsp;以上思路明显不明智，既然可以离线，为什么不离线呢？离线并离散化后，这道题就是一道树状数组裸题，可以轻松解决。

&emsp;&emsp;逆序对问题既可以在离散化后使用树状数组求解，又可以采用“特殊”的归并排序求解。既然这个问题也能够使用树状数组加离散化求解，那这个问题为什么不能利用归并排序来求解呢？

&emsp;&emsp;这便是我们要研究的问题：如何使用类似于归并排序求逆序数的方法来解决更多问题。我们将在下面继续讨论。

##### 2. 二维偏序

###### ①偏序[^偏序]

[^偏序]: 这里不对偏序进行学术的研究，所以很多描述并不专业。

&emsp;&emsp;对于两个任意两个整数 $a$，$b$，我们能够知道它们一定满足以下三个关系之一：
$$
a < b
\\
a = b
\\
a > b
$$
&emsp;&emsp;像这样，对于一个可重集，如果其中的任意两个元素都能比较大小，那么我们称集合中的元素有**全序**关系。

&emsp;&emsp;对于两个任意的数对 $a = (x_a, y_a)$ 和 $b = (x_b, y_b)$，可以把它们画在坐标轴上：

![](pic\CDQ 分治 1.png)

&emsp;&emsp;如果有 $x_a < x_b$ 且 $y_a < y_b$，那么可以记作 $a < b$，其几何意义也很明显。但是下面这种情况：

![](pic\CDQ 分治 2.png)

&emsp;&emsp;这两个矩形不能够“互相包含”，因此我们也不能对它们进行比较。一般地，称上面这种关系为偏序关系，也就是说，在可重集中，并不是所有的元素都可以相互比较。

###### ②二维偏序问题

&emsp;&emsp;给定 $n$ 个数对 $(x, y)$（$n \le 5 \times 10^5$），请求出对于每个数对 $(x_a, y_a)$，有多少个其它数对 $(x_b, y_b)$ 满足 $x_b < x_a$ 且 $y_b < y_a$。

------

&emsp;&emsp;毫无疑问暴力是 $O(n^2)$ 的，无法解决这个问题，能不能有更好的方法呢？

&emsp;&emsp;一个很容易想到的思路是：如果我们按照 $x$ 从小到大的顺序处理，那只需要统计有多少个 $y$ 比自己的 $y$ 要小，这不就是个顺序对问题吗？

&emsp;&emsp;接下来，只需要使用树状数组即可。但与逆序对相似的，能否使用归并排序完成这个任务呢？

&emsp;&emsp;答案毫无疑问是肯定的，只需要稍微改变一下**左边区间对右边区间的贡献**即可。

------

&emsp;&emsp;实际上，逆序对问题可以看作一个二维偏序问题：给定数对 $(i, a_i)$，有多少个其它数对 $(j, a_j)$ 满足 $i < j$ 且 $a_i > a_j$。只不过 $i$ 是序列的下标，**是默认有序的**。这也给了我们一个启示：**可以先将第一维有序化，再考虑第二维**。

###### ③使用二维偏序模型解决引例

&emsp;&emsp;树状数组都能用……既然前面几个问题都是树状数组和归并排序均可解，为什么不试试归并排序呢？只不过这次需要排序的内容就很不明显了。

&emsp;&emsp;可以考虑这样去设一个**操作**：设操作 $(x, y)$，表示一个时间在 $x$ 的操作要查询/修改位置 $y$ 的内容。很明显，只有修改这个动作在前，才能影响后面的查询操作；将问题转化为前缀和问题后，只有当修改前部位置的值时，后部位置的前缀和才会发生改变。**这种有单方向且可比较的影响的问题，正是二维偏序模型可以解决的问题。**

&emsp;&emsp;首先对第一关键字排序，由于操作按顺序给出，所以就不用排序了。紧接着对第二维进行归并排序。当处理一个区间时，**我们只考虑左边的区间对右边的区间的影响。一是因为左边的区间的第一关键字一定是小于右边的区间的，**第二是因为左边对左边的贡献以及右边对右边的贡献已经在分治时计算完了。

&emsp;&emsp;怎么计算左边对右边的贡献呢？只需要保存一个变量代表**已经扫描的左边区间的操作影响总和**。另外，查询操作需要将区间拆成一前一后两个点考虑前缀和，这里不再赘述。

------

&emsp;&emsp;以上方法不受空间范围影响，不受偏序的限制。我们可以这样认为：**归并排序利用分治的特性（将问题简单化后再合并）降低了维度。**类似于这样的解决办法，我们称为 CDQ 分治。

## Part 3 利用 CDQ 分治解决三维偏序问题

##### e.g. [BZOJ 3262 陌上花开](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)

题目大意：给定 $n$ 个有序三元组 $(x_i, y_i, z_i)$ ，求出对于每个三元组 $a$，有多少个别的三元组 $b$ 满足 $x_a \ge x_b$，$y_a \ge y_b$ 且 $z_a \ge z_b$。

------

&emsp;&emsp;直接使用数据结构需要使用树套树：**对 $x$ 排序后**，用树状数组维护权值 $y$ 的前缀集合，里层再套一个平衡树查找 $z$。~~反正我不会写。~~

&emsp;&emsp;能否使用 CDQ 分治解决呢？对 $x$ 排序后，我们对 $y$ 进行归并排序，只考虑左边区间对右边区间的影响。怎么计算呢？只需要用一个树状数组维护就好了！

```c++
void cdq(int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1;
	cdq(l, mid); cdq(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && disc[i].y <= disc[j].y)) // note
		{
			bit.add(disc[i].z, disc[i].param); // note
			temp[k++] = disc[i++];
		}
		else
		{
			ans[disc[j].ansIdx] += bit.query(disc[j].z);
			temp[k++] = disc[j++];
		}
	}
	for (i = l; i <= r; i++)
		disc[i] = temp[i];
	for (i = l; i <= r; i++)
		bit.clear(disc[i].z); // note
}
```

&emsp;&emsp;没错，**利用归并排序计算我们想要的，就是所谓的 CDQ 分治**。尽管如此，还是有许多要注意的地方：

Q：树状数组清空不怕超时吗？

A：[前面](#2. 逆序数与权值树状数组)讲过了。

Q：一开始只用按照 $x$ 排序吗？

A：其实不是的。

&emsp;&emsp;CDQ 分治的核心，便是在归并排序中用左边的更新右边的，这有许多要求。首先，你要能够更新（你总得能够写出一个时间复杂度正确的代码吧……），换句话说，类似于线段树，维护的信息必须可合并才能够使用；对 CDQ 分治而言，维护的信息**一般要求可以差分**，如前缀和，可以把所有可能有贡献的数分开考虑贡献。

&emsp;&emsp;第二个要求是：**贡献必选满足单向关系**。什么意思呢？**我们需要保证右边的区间对左边的区间没有贡献**，因为我们从未去计算通过它。如果它存在，我们又没有计算它，那不就是算漏了吗？

&emsp;&emsp;如果我们只对 $x$ 进行排序，那么有可能存在 $x$ 相同 $y$ 大的却在右边区间的情况，这种情况就会导致答案错误。所以**第一步**的排序必须对所有关键字进行排序，**保证右边的元素对左边的元素不可能有贡献**：

```c++
bool operator< (const Flower& b) const
{
    if (x != b.x) return x < b.x;
    else if (y != b.y) return y < b.y;
    return z < b.z;
}
```

Q：代码中的第一个 note 处，为什么必须写小于等于？

A：为了保证左边对右边的贡献计算完整，不会漏掉。

Q：为什么要进行离散化（disc(retize)）？

&emsp;&emsp;正如第二个问题中所说，**右边的元素对左边的元素不能有贡献，否则会算漏**。如果存在相同的元素，那么无论如何右边的元素都会对左边的元素有贡献的，所以必须离散化。

------

&emsp;&emsp;搞懂了上面几个问题后，我相信你已经完全理解 CDQ 分治了（~~只是做不来题~~）。但是 CDQ 分治还有更多应用。

Q：我不喜欢树状数组。

A：~~写线段树，~~写嵌套 CDQ 分治。

##### 嵌套 CDQ 分治

&emsp;&emsp;CDQ 分治的**重要目的是降维**，除此之外，排序和使用数据结构也能够降维。所以三维偏序问题中，我们首先使用排序降低一维，但是数据结构维护二维数据还是很困难，所以我们需要 CDQ 分治。

&emsp;&emsp;CDQ 分治的另外一个好处是：它能够嵌套。如何嵌套呢？

```c++
int ans[maxn];
Flower temp3d[maxn];
Flower temp2d[maxn]; // note
void cdq2d(int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1;
	cdq2d(l, mid); cdq2d(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	int sum = 0;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && temp3d[i].z <= temp3d[j].z))
		{
			if (temp3d[i].flag == LEFT) sum += temp3d[i].param; // note
			temp2d[k++] = temp3d[i++];
		}
		else
		{
			if (temp3d[j].flag == RIGHT) ans[temp3d[j].ansIdx] += sum;
			temp2d[k++] = temp3d[j++];
		}
	}
	for (i = l; i <= r; i++)
		temp3d[i] = temp2d[i];
}
void cdq3d(int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1;
	cdq3d(l, mid); cdq3d(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && disc[i].y <= disc[j].y))
		{
			temp3d[k++] = disc[i++];
			temp3d[k - 1].flag = LEFT; //note
		}
		else
		{
			temp3d[k++] = disc[j++];
			temp3d[k - 1].flag = RIGHT;
		}
	}
	for (i = l; i <= r; i++)
		disc[i] = temp3d[i];
	cdq2d(l, r);
}
```

&emsp;&emsp;相比一层 CDQ 分治，有几个明显的特征：

1.  ~~代码长了一倍。~~
2.  ~~常数翻了一番。~~



1.  需要额外的 temp 数组。
2.  需要打上额外的 LEFT/RIGHT 标记，仅用标记（全）为 LEFT 的区间进行修改，仅用标记（全）为 RIGHT 的区间进行查询。
3.  不同维度比较的东西不同。