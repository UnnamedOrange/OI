[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 整体二分

[参考资料](http://tsinsen.com/resources/Thesis2013_xhr.pdf)

##### 什么是整体二分

说不清楚，不如不说。还是从例题入手吧。

##### e.g. [POJ 2104 K-th Number](http://poj.org/problem?id=2104)

###### 题目大意

给你一个长度为 $n \pod {n \le 10^5}$ 的整数序列 $a$，给你 $m \pod {m \le 5 \times 10^3}$ 个询问 $Q(i, j, k)$，问你 $a_i \sim a_j$ 的第 $k$ 小数是什么？我们假定 $1 \le a_i \le n$，你可以用离散化来满足这个条件。

###### 思路

显然可以用主席树来做，时空复杂度 $O(n \log n)$。（如果你不会，请忽视这句话）

有别的做法吗？`nth_element` 除外。

###### 对于 $m = 1$ 的情况

二分答案，是一个多么套路的做法啊！对于询问 $Q(i, j, k)$，我们二分一个答案 $ans$。如果在区间内**小于等于** $ans$ 的元素个数**小于** $k$ 个，说明我们的答案**肯定**更大，要让 $l = mid + 1$；否则答案**说不定**可以更小，让 $r = mid$。那么现在的问题是，如何快速统计区间内小于等于 $mid$ 的数的个数。（事实上，正是因为主席树能够快速做到这一点，它才能顺利解决这个问题，但我们这里不准用主席树）

由于 $m = 1$，我们自然想到用 $O(n)$ 的时间复杂度暴力扫描整个序列，总时间复杂度为 $O(n \log n)$。

###### 幻想中的二分

我们能不能让统计小于等于 $mid$ 的数的个数这个过程更快些呢？当 check 函数花费的时间太长时，我们常常会幻想：要是能够用上次 check 的某些信息，有些重复的操作是不是就可以不用做了？这不就省下了时间吗？

考虑我们 check $mid$ 时，如果我们发现要让 $l$ 等于 $mid + 1$，这是不是就说明了答案一定大于 $mid$？换句话说，**已经小于等于 $mid$ 的数在接下来二分的过程中也小于等于 $mid$**。现在新的问题是：在剩下的数中找第 $k - check$ 小的数。

如果我们用原力忽视那些小于等于之前的 $mid$ 的数，以上做法肯定是得到了加速的，因为接下来的 check 工作量变少了。我们试着实现一下以上操作。

------

设当前二分的范围为 $[l, r]$，根据上面的叙述，我们的 $k$ 已经减去了询问区间内小于 $l$ 的数的个数。考虑二分的答案 $mid$，我们检查在询问区间内有多少个 $[l, mid]$ 中的数，如果小于当前 $k$，则令 $k$ 减去数的个数，并令 $l = mid + 1$；否则直接令 $r = mid$。

我们用一个数据结构，让所有 $[l, mid]$ 的数的对应位置加一，那么询问区间中满足在 $[l, mid]$ 中的数的个数就是两个端点的前缀和相减。这样我们就能实现以上操作了。我们使用树状数组来实现这个操作，上述操作的时间复杂度为 $O(n \log^2 n)$。

为什么时间复杂度反而变高了？那是因为我们没有原力……

###### 当 $m = 5000$ 时

虽然幻想不能帮我们加速，但是它为我们带来了一个奇特的性质。

显然二分的区间可以看作一棵线段树，二分的过程可以看作询问从根结点掉到叶结点去。我们把所有的询问丢到线段树的根结点中去，然后我们可以惊奇地发现：在同一个结点的一个询问，在初始化该结点的树状数组后，我们能够花费 $O(\log n)$ 的时间来判断它应该走左子树还是右子树。初始化所有结点的时间复杂度为 $O(n \log^2 n)$（初始化一个结点的时间复杂度为 $O(n \log n)$（排序后二分查找），根据主定理得到初始化所有结点的时间复杂度），因此算法的总时间复杂度为 $O(n \log^2 n + m \log n)$。

###### 为什么这么神奇呢

如果我们不用“幻想的方法”，最大的问题是我们不能在理想的时间复杂度内判断在同一个结点的所有询问该走哪边，但我们用上面的方法后，我们就能够在可行的时间复杂度内判断了，那么总结一下，上面的方法到底是什么呢？

我们套用上面的思路，考虑一下如果不用“幻想的方法”将会发生什么。我们就不能只统计区间中有多少个 $[l, mid]$ 内的数，而必须统计有多少个 $[1, mid]$ 内的数，时间复杂度自然就变成了不可承受的 $O(n^2 \log n)$。

所以上面“幻想的方法”的本质是：**保存小于 $l$ 的数[^number]对 check 的影响，在接下来的二分过程中不再统计它们，直接用保存的值，因为它们接下来会始终存在。**这个看似简单的优化能够把 $O(n)$ 变成 $O(\log n)$。

[^number]: 广义的讲，应该叫操作。

------

像上面这样，用类似于“幻想的方法”的本质使得能够在可行的时间复杂度内同时解决多个二分询问的方法，我们称为*整体二分*。

###### 参考代码

```c++
// 见 "Source Code\整体二分"
```

##### e.g. [Luogu 3332 [ZJOI 2013] K 大数查询](https://www.luogu.org/problemnew/show/P3332)

###### 题目大意

有 $n \pod {n \le 5 \times 10^4}$ 个可重集，从 $1$ 标号至 $n$。有 $m \pod {m \le 5 \times 10^4}$ 次操作。操作分两种：

1.  在第 $l$ 个到第 $r$ 个可重集中加入一个数 $x \pod {x \in \text{long long}}$；
2.  询问把第 $l$ 个到第 $r$ 个可重集中所有数拿出来排好后第 $k$ 大的数是多少。

不要求强制在线。

###### 思路

同样使用整体二分。与上一题不同的是，上一题是静态的，只有数；而这一题要动态地进行修改查询，怎么才能做到呢？

考虑把修改和查询一起放进 `solve` 函数里面，把它们统称为*操作*。首先我们确定一下二分的框架。由于是求第 $k$ **大**，因此我们把二分区间设为 $[l, r)$，每次检查**大于等于** $mid$ 的数的个数。如果大于等于 $mid$ 的数的个数不足 $k$ 个，那么这个询问的答案在 $[l, mid)$ 内，我们把 $k$ 减去大于等于 $mid$ 的数的个数；否则它的答案在 $[mid, r)$ 内。

如何把修改操作融入进来呢？注意到，如果 $x \ge mid$，那么它一定会对 $[l, mid)$ 中的询问产生贡献。注意到我们已经在小于 $mid$ 的询问中减去了大于等于 $mid$ 的数对它们的贡献，因此 $x \ge mid$ 修改在之后只会对 $[mid, r)$ 内的询问有贡献，我们把它放入这个区间即可。同理，把 $x < mid$ 的放入 $[l, mid)$ 即可。

注意到，修改和查询是有时间先后的，我们要保证递归时一个区间内的所有操作仍有先后顺序。因此在递归右区间时，如果你是从右向左插入操作，那么必须加上这样一句代码：

```c++
std::reverse(idx + rBegin, idx + 1 + to);
```

如果没有时间先后（比如上一题），就可以不写这句代码。

使用线段树进行区间加和区间查询和，时间复杂度为 $O(n \log^2 n)$。注意线段树的初始化必须是 $O(1)$ 的，否则时间复杂度退化至 $O(n^2 \log n)$。

###### 参考代码

```c++
// 见 "Source Code\整体二分"
```

###### 总结

这道题带我们进入了广义的整体二分，引入了操作的概念。我们规定操作包含修改和查询两类。这对整体二分的过程有了一个新的要求：要保证一个待处理区间内的所有操作按时间有序。除此之外，整体二分还有一些别的注意事项：

1.  整体二分可以看作是把一些操作从根结点上投下，让它们落到叶结点，叶结点代表的值就是答案。线段树的结点数是 $O(n)$ 的，结点总长度是 $O(n \log n)$ 的。如果你的操作的时间复杂度与当前结点长度线性相关，那么总时间复杂度是 $O(n \log n)$ 的；如果你的操作的时间复杂度与结点长度的关系为 $O(n \log n)$（这里的 $n$ 表示结点长度），那么总时间复杂度是 $O(n \log^2 n)$（由主定理推导而来）。如果你的操作的时间复杂度是 $O(n)$（这里的 $n$ 表示序列总长度），那么总时间复杂度为 $O(n^2 \log n)$。所以要注意你的操作的时间复杂度不能与序列总长度线性相关。
2.  整体二分的核心思想是：如果一个修改操作对一个有一定答案范围的询问操作始终有贡献，我们就不再重复统计，而是直接记下这个贡献。这样，对于一个操作区间，我们就保证了：这个区间内的询问已经记录下了区间外所有修改对它们的贡献；这个区间内的修改已经对区间外的所有询问造成了贡献。
3.  整体二分最基本的先决条件：答案可二分，操作可离线。

##### e.g. [HDU 5412 CRB and Queries](http://acm.hdu.edu.cn/showproblem.php?pid=5412)

###### 题目大意

给你 $n \pod {1 \le n \le 10^5}$ 个数，有 $Q \pod {1 \le Q \le 10^5}$ 次操作，操作分成两类：

1. 把第 $l$ 个数变成 $v$。
2. 询问第 $l$ 到第 $r$ 个数中第 $k$ 小的数。

###### 解决方法

这道题就是一道所谓的带修改区间 $k$ 大问题。如何使用整体二分呢？

我们可以用上一题的做法。把一开始的数列看作 $n$ 个插入操作；把之后的修改看作先删除，再插入，这样做法就和上一题完全一样了。

###### 参考代码

```c++
// 见 "Source Code\整体二分"
```
