[TOC]

# Aho-Corasick Automation

（粗体为终点内容，加亮为关键内容）

##### 1. 问题定义

​	给定一个模板串集合，要求在一个字符串中找到所有模板的位置。这个问题又叫做多模式匹配问题。

##### 2. AC 自动机

​	AC 自动机由一个 Trie 和一个失配边集合组成。

​	由于 AC 自动机的底层是一个 Trie，那么它自然有一个 Trie 结点。

```c++
struct Node
{
 	Node* c[alpha_size];
 	Node* fail;
 	Node* suffix;
 	INT count;
};
```

​	可以看出，AC 自动机的结点在 Trie 的基础上多出了个 fail 指针，还多了个 suffix 指针。它们到底怎么用呢？我们一会儿来讲解。

###### ①Trie 的结构

​	我们一般认为，Trie 是一棵结点上没有字符，而在边上有字符的树。AC 自动机也类似，根结点是一个虚拟的结点，但是==可以认为字符存在在其它结点上，==**这样有助于理解“状态”一词。**实际上，==AC 自动机的结点中不保存字符，我们仍然把字符“存”在边上。==

​	回忆 KMP 算法，在某个地方失配后我们要让模板串往前移，通过记录一个失配函数来实现这个功能。事实上 KMP 的失配函数是一个状态机，由于它很简单，所以可以用一个 f 数组来实现。AC 自动机是一棵树，所以必须要用指针，**但是它的功能和 KMP 的失配函数是完全一样的，**==其物理含义也是一样的：指向最长的与后缀相同的前缀的尾部。==

​	与 KMP 算法类似，AC 自动机也是边走边匹配，但是有这么一个区别：若找到了一个串，同时也就说明了找到了这个串的后缀；**如果一个模板是另一个模板的后缀，说不定会出现同时找到两个串或更多串的情况。**一个最简单的想法是沿着失配边走，直到走到根结点，但是**当模板串只由一种字符组成时，时间复杂度就悲剧了：失配边边数与模板串长度同阶。**所以我们需要一个更优秀的东西，它就是 ==suffix 指针==，中文名叫做==后缀链接==。==它的作用就是在**每一个**状态处（并不一定非要是匹配的一个状态）往回走，保证只会走到匹配点或者根结点。==这样时间复杂度就得到了保证。

###### ②构建 AC 自动机

​	工欲善其事，必先利其器。==建立 AC 自动机前，你要先建好 Trie 树。==**这就意味着你不能边插入模板串边维护 AC 自动机，只能把模板串插入完后再一次建成。**

​	步骤（1）：==用 AC 自动机的结点，建立一棵一般的 Trie 树。==

​	受题目影响，**可能会有相同的模板串。**==这时要根据题目要求确定记一次还是记多次，count 就起作用了。==

​	步骤（2）：==构造 fail 指针，同时构造 suffix 指针。==

​	**由于我们肯定是用之前的数据推出之后的目标，所以 ==BFS== 是我们的不二选择。**我们先将根结点放进队列中，==每次通过出队的去更新它的儿子，而不是在出队时更新自己。==这样一不用特判根结点，二我们能**知道子结点对应的字符是什么。**

​	suffix 的计算与 fail 的计算息息相关。==得到 fail 指针后，我们先检查 fail 指向的结点是否代表一个字符串，如果是，就指向 fail，否则指向 fail 的 suffix。== 

​	就这样，AC 自动机就建好了。

###### ③向自动机输入

​	然后就和 KMP 几乎一模一样了，唯一的区别是==**每次**都要跑一次 suffix 到根结点。==

##### 3. 时空复杂度

​	设文本串长度为 n，模板串总长度为 m。

​	**Trie 结点占用的大小不能忽视**，其空间复杂度为 $O(α)$，代表字母表大小。很明显整体空间复杂度为 $O(mα)$。

​	时间复杂度是线性的。