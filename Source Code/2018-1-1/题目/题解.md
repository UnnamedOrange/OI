##### Day1 T1

######Prüfer 序列，动态规划

​	首先要知道 Prüfer 定理。然后考虑使用**计数型动态规划**。

​	设 $f_{i, j, k}$ 表示在前 i 个数中有 j 个作为**候选名单**并且在这个候选名单中选了 $k + 2$ 个点组成了长度为 k 的 Prüfer 序列。

​	初始时 $f_{0, 0, 0} = 1$。**由于边界情况比较复杂，所以考虑“我为人人”的动规方式。**

​	考虑 $f_{i, j, k}$ 对答案的贡献。若不把第 i + 1 个数考虑进候选名单，那么会给 $f_{i + 1, j, k}$ 有 $f_{i, j, k}$ 的贡献。

​	若考虑进候选名单，那么会给 $f_{i + 1, j + 1, k + c}$ 有贡献，这里的 c 由枚举得来，要求满足度数要求（$c < a_{i + 1}$），并且满足 Prüfer 序列的要求（$k + c \le n - 2$）。

​	考虑公式 $\frac {n!} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!}$。我们先让 DP 数组中保存的树除以 $n!$，因此我们实际保存的是 $\frac {1} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!}$ **的和**。这样看上去就没有什么大的实际意义了，但我们知道，**新的和的每一项的形式是 $\frac {1} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!(a_{n + 1} - 1)!}$**，所以我们只需要索性让 $f_{i, j, k}$ 对 $f_{i + 1, j + 1, k + c}$ 有 $\frac {f_{i, j, k}} {c!}$ 的贡献就可以了。

​	最后还要再把 $(n - 2)!$ 乘回来，因此选 i 个作为候选名单的答案为 $f_{n, i, i - 2} * (i - 2)!$。

​	注意：这里不把 $n!$ 保存在 DP 数组中只是为了方便，但同时这样改变了我们所保存的东西的意义。如果要退回原意的话，还得再做一个连续乘法，造成了不必要的麻烦。

##### Day1 T2

######简单博弈，动态规划

​	**树上的博弈可以考虑子树上的情况。**

​	考虑状态的设计。**经验告诉我们，状态可以有四种：红必胜，蓝必胜，先手胜，后手胜。**对于这道题而言，我们需要三种状态：红必胜，蓝必胜和先手胜。

​	**考虑从叶节点开始，推广到子树，再推广到整棵树。**一开始，叶节点的状态时已知的：红色结点为红必胜，蓝色结点为蓝必胜，无色结点为先手胜。**然后考虑将操作限定在子树，**接下来就会很明显的发现，当红色结点个数大于蓝色结点个数时，红必胜；反之蓝必胜；否则先手胜。

​	**基于这么个事实：假设有一个红必胜的不在当前子树，而蓝色想要去挽回，那么蓝色就要去那里选择一个结点。但是红色的可以进行“模仿”，因此一切挽回都是徒劳的。**所以，状态就限定在了子树中。接下来考虑如何通过子树来推断上一级结点。只需要把红必胜的子树看作红色，蓝必胜的子树看成蓝色，先手胜的结点看作无色就是了。**因为最终它们都会变成它们应有的颜色。**

​	最终，问题 1 的答案就是根结点的状态。若根结点的状态为红必胜或先手胜则有解，否则无解。

​	考虑第 2 问，我们不如换一种状态设计。设红必胜子树的权值为 1，蓝必胜子树的权值为 -1，先手胜的权值为 0，则结点的状态为 $\sum 子树权值$。不难发现，$f_i = 0$ 对于上面的先手胜，$f_i > 0$ 对应红必胜，$f_i < 0$ 对应蓝必胜。而且这种描述方式**更精确了**。


​	考虑红方怎么赢。如果是红必胜，随便选一个点就好了。如果是先手胜，现在红方要选一个点，然后就成了后手了。**因此唯一的方式是这一个点使当前根结点的局面由先手胜转变为红必胜。**

​	有两个方法可以使根结点的局面从 0 变为 1。要么把根结点的子树中的一个从 -1 变成 0，要么把根结点的子树中的一个从 0 变成 1。不难发现，这是一个递归的问题，到子树上我们的做法也是一样的。所以我们可以从根结点开始遍历，仅进入 f 为 0 或 -1 的子树，走到叶结点后若该结点没有染色，就说明该结点是答案之一。问题就得到解决了。

​	**以上过程也侧面说明了为什么红必胜的第一步可以随便走：只要根节点的状态为红必胜，红的就赢定了。但可能之后红的就要更谨慎些了，因为随便选了一个位置后，（假设红方继续浪，）有可能局势就从红必胜转为了先手胜，从第 2 问来看，先手胜还得“绝顶聪明”才行。**

##### Day2 T1

###### 分析

​	很明显，当整个串不是回文串时，答案为 1。

​	然后考虑是否对于任意 $i$ 都使 $a_1$ 到 $a_i$ 和 $a_{i + 1}$ 到 $a_i$ 至少有一个是回文子串，如果不是，答案为 2。

​	现在任意前缀和对应的后缀都至少有一个是回文子串了，考虑以下情况：

​	若第一个字符等于第二个字符，有种情况是全部相同，答案为 -1。

​	若第一个字符等于第二个字符，考虑插入一个不同的字符，那么肯定会仍然满足原来的性质。但是如果这个字符不是插在中间的话，整个串就不是回文串了。所以当出现形如（aaaaabaaaaa）的字串时答案为 -1。

​	若第一个字符等于第二个字符，考虑插入多个不同的字符，始终存在一个 i 使得整个串可以分成两个非回文子串。

​	若第一个字符不等于第二个字符，考虑增量构造字符串，只能构造出形如 abababa 的形式的字串，答案为 -1。

​	特判答案为 -1 和 1 的情况，否则输出 2。

​	**要敢想，想细，写对。**

##### Day2 T2

###### 最小割

​	又一个最小割模型：只有两种选择，相同集合对答案没有贡献，不同集合对答案有贡献。

​	先讲限制条件。结合上一道例题，已经可以解决两个点在同一集合（$x = y$），两个点在指定集合（$x < y$）的问题。最后的问题是如何处理 $x \le y$ 的情况（要么 $x$ 和 $y$ 在同一集合，要么 $x$ 在 $S$， $y$ 在 $T$）。

​	解决方法是==**只从 $y$ 向 $x$ 连一条容量为无穷大的边**==，这样，仅当 $x$ 在 $T$ 中，$y$ 在 $S$ 中时，这条边成为割边。



​	然后就是看两个在不同集合的点对答案的贡献了。对于前面有绝对值的部分，翻译过来就是只要两个不一样，就会对答案有 $2aW$（或者 $b$，或者 $c$）的贡献，所以直接连一条无向边即可。

​	剩下的部分好像很难处理，因为==**网络流不能连容量为负的边。**==**像这样很难考虑两个不同集合的点对答案的贡献的情况，干脆==把式子拆开。==**拆开后发现，每个变量将会对答案有 $sum_i w_i$ 的贡献。注意，这个 $sum_i$ 在拆开前就有初值 1，因为题目要求的和的第一部分是 $\sum w_i$。

​	于是现在问题就变成了计算选正选负对答案的贡献（==**实质上是看是否和源点或者汇点在同一集合**==，若在不同集合会造成多少贡献）。但是这样还是会有容量为负的边，所以我们要做这么一个操作：==**先假设选正（负）的，再考虑改成选负（正）的会对答案有多少影响。要求这个影响必须为正。**==这样我们就能保证连一条正容量的边了。

​	注意要提前把那个“假设”给算进答案里。

##### Day2 T3

###### 简单博弈，分类讨论

###### ①初步分析

​	我们先认为 a < b，如果不是可以进行简单交换。然后**假设**所有数对 $(a + b)$ 取模。（为什么？你不取模你能怎么做啊！）

​	可以简单证明一下取模的原因（称双方分别为 a，b）：假设 a 先取，而 b 不去取 a 刚才取的那一堆，那么 b 一定是为了挽回其它堆的劣势才去别的堆取的。所以这时 a 一定会去阻止 b，因为 b 挽回劣势意味着 a 就处于劣势。就这样，这一个堆就少了 a + b。如果 b 一直不去 a 一开始的堆，他们就一定会把别的堆取完，最后不得不回到那一堆，并且还是 b 先手。所以可以认为**先手在某一堆操作后，后手也一定在相同堆进行操作。所以可以对 $(a + b)$ 取模。**

​	取模后，可以发现对于任意一堆石子以下法则：

​	①b 取一次后，谁都不能取。

​	②a 取一次后，b 不能取；若 x > 2a，则 a 可再取。

​	③若 a 不能取，那么 b 也不能取。

###### ②分类讨论

​	**由于石头堆成功地被我们独立了，所以我们可以对一堆石头进行分类讨论。**设一堆**选了的**石头的个数为 x。

​	①若 x < a，那么这些堆肯定没有用，相当于每种方案都乘以 $2^k$，k 为这种石子堆的堆数。

​	②若 $a \le x \lt b$，那么 a 必胜。让 a 优先取不是这种的堆，那么当 a 取完这种堆时，b 一定没有可以取的了，所以 a 必胜。

​	③**现在 $x \ge b$ 了。**

​	**假设** a 先手，如果存在至少一个大于等于 2a 的，那么 a 必胜，因为 a 能把状态转移到 ①。

​	如果 a 后手，如果只存在一个大于等于 2a 的，那么 b 一定会取它以阻止 a，这时就取决于剩余有多少堆。如果剩余有奇数堆，就是后手胜（a 胜）；如果剩余有偶数堆，就是先手胜（b 胜）。但如果存在至少两个，那么 a 还是必胜。

​	如果不存在至少一个大于等于 2a 的，那么剩余有奇数堆时先手胜，否则后手胜。

​	**整理一下，**当至少存在两个大于等于 2a 的时，a 必胜。如果存在一个大于等于 2a 的，如果剩余奇数堆，就是 a 必胜；如果剩余偶数堆，就是先手胜。如果不存在大于等于 2a 的，那么有奇数堆时先手胜，偶数堆时后手胜。

###### ③实现

​	注意到，之前我们提及 2a 时，我们是假设 $x \ge b$ 的，因为如果 x < b 那也直接归类到 a 必胜的范围了。

​	**可以用桶来存每种类型的个数。**

```c++
for (int i = 1; i <= n; i++)
		buf[(x[i] >= a) + (x[i] >= b) + (x[i] >= b && x[i] >= a * 2)]++;
```

​	如何选至少两个？可以先任意选，再排除选一个和不选的情况。

​	如何计算在 n 个里面选奇数/偶数个的方案数？

​	考虑动态规划。设 $f_i$ 为在前 i 个数中选奇数个数的方案，前 $g_i$ 为在前 i 个数中选偶数个数的方案。则 $f_0 = 0$，$g_0 = 1$。考虑方程，不难得到 $f_i = f_{i - 1} + g_{i - 1}$，$g_i = f_{i - 1} + g_{i - 1}$。**通过打表观察发现，当 i > 0 时，$f_i = g_i = 2^{i - 1}$，当 i = 0 时，$f_i = 0$，$g_i = 1$。**

##### Day3 T1

######KMP 算法的深入理解

​	（具体的 KMP 算法，见专题）

​	对于所有 $i \ne a_i$ 的位置，通过求模得到答案。

​	对于所有 $i = a_i$ 的位置，考虑 KMP 算法的性质。**由于失配函数的含义是长度为 i 的前缀的“前缀和后缀相同”的最大长度，因此该位的 f 一定为0，否则 $i \ne a_i$**。由此可以枚举每一位填什么，然后代回去求 $f_i$（注意差一错误），如果求出来不为 0 ，则说明该字符不合法，要找下一个字符验证其是否合法，合法的话就是它了（以保证字典序最小）。由于题目保证有解，因此不用特判。

###### KMP 算法的更深入理解

​	再仔细思考，发现**题目给定的 $pre_i$ 事实上是 $i - f_i$（i 从 1 开始）。**因为 $f_i$ 相当于是新的循环的开始部分的长度，所以一个循环的长度为 $i - f_i$。

​	然后**考虑直接套用 KMP 算法的初始部分。**由于要处理 $f_i = 0$ 的情况，因此失配函数最终是要跳到 0 的。回忆 KMP 初始化代码，我们在跳到上一个匹配点时，**当下一个字符不同时才会继续跳**，直到下一个字符相同或者跳到 0 才不跳了。由于我们的目标是跳到 0，因此这个“下一个字符”一定不能相同。从后往前直接跳，然后每跳到一处就标记它的下一个字符不可选。最后选择最小的可选字符就好了。

​	**深刻理解 $f_i$ 实际代表的是一个长度有效地避免了差一错误。**

##### Day4 T1

###### 迭代加深搜索，剪枝

##### Day4 T2

###### Tarjan（SCC）算法，DAG 上的 DP

##### Day8 T1

###### 带有排序的动态规划

###### ①离散化

​	首先考虑离散化。**不难发现，其实区间本身的位置是没有用的，有用的是区间能够覆盖哪些点。**所以只需要将点离散化即可。

###### ②排序后做 DP

​	考虑动态规划。直接以给定的顺序做 DP 是显然不行的，我们考虑**用排序消除后效性的方法。注意，这里我们要先离散化，再排序。**

​	常用思路：==设 $f_i$ 表示**完全覆盖**前 i 个点的方案数，将区间按第一关键字左端点升序，第二关键字右端点降序排序后 DP。==

​	**考虑原始 DP 状态定义为 $f_{i, j}$ 表示在前 i 个区间中选择一些区间使得前 j 个点完全被覆盖的方案数。**当放第 i 个区间时，考虑到要没有后效性，因此左端点一定要升序。这样，就要要求第 i 个区间把前面的 j 个点都覆盖掉（这里的 j 是个“形参”）。**由于第 i 个区间是确定的，所以一定要覆盖到前 $r_i$ 个点，这样，方案总数将会多出 $\sum _{k = l - 1} ^ {r - 1} f_{i - 1, k}$。**考虑 $f_{i, k} (k \ge r)$，对于区间 i 而言，我们肯定是要从 $f_{i - 1, k} (k \ge r)$ 转移过来的，因为区间 i 覆盖不到。**根据定义，k 之前的都已经被覆盖了，那么 i 可选可不选，因此 $f_{i, k}  += 2 × f_{i - 1, k} (k \ge r)$。**

​	考虑滚动数组，发现其实可以不用滚动，只需要先算乘法（保证 $f_{i, j}$ 不被破坏），再算加法就好了。

​	（其实右端点应该是不必降序的，保险起见，降序吧）	

##### Day8 T2

###### 交互题，编码

###### ①原则

​	不会存在一个算法，能使 12 个数准确映射到 920 个数上，**因此一定要对这两个数进行一些运算才能判断。**

###### ②误区

​	记住一次只需要判断两个数，因此可以紧紧抓住这两个数的特征，而不要试图找通法。**因为通法就意味着你要将 12 个数映射到两个数运算的结果上去，也是不可能的。**

###### ③方法

​	最直接的方法就是考虑第一个不同的位，并记录第一个数在该位上是什么。

​	更好的方法是考虑第一个不同且在第一个数中为 1 的位，这样可以少一个位用来保存。但有可能不存在，**这时它们 1 的个数一定不同，保存它们 1 的个数即可。**

​	正解是**建立映射**，将这 920 个数一一映射到含有 6 个 1 的二进制数当中。由于 $C(12, 6) = 924$，因此够用。这样就一定存在第一个不同且在第一个数中为 1 的位，正好能过掉此题。

##### Day12 T1

###### 贡献，排序与链表，卡精度

###### ①贪心

​	对于一个区间，最终得到的水量为：
$$
\sum _{i = 1} ^ {r - l + 1} \frac {A_i} {2^i}
$$
​	所以我们的操作要从小到大进行。暴力的时间复杂度为 $O(n^3 \log n)$。

###### ②精度

​	题目仅仅要求保留到小数点后两位！==观察上面的式子，发现当 $2^i$ 很大时，就对我们的答案没有影响了。==所以我们可以只算到 $2^{50}$ 左右就完全够了。

###### ③贡献

​	这种区间很难整的，肯定是要考虑单个点对答案的贡献的。发现，一个点在一个区间中对答案的贡献只与它在该区间中的排名有关。于是我们就考虑找到比它大的点，逐个降低它的排名。
$$
contribution_i = w_i × \sum _{u = 1} ^ T \sum _{v = 1} ^ T (l_{u - 1} - l_u) × (r_v - r_{v - 1}) × \frac {1} {2^{u +v - 1}}
$$
​	大概意思就是左边找 T 个比它大的，右边找 T 个比它大的。==分别计算 $T^2$ 个区间的贡献。==
$$
\sum _{u = 1} ^ T \sum _{v = 1} ^ T (l_{u - 1} - l_u) × (r_v - r_{v - 1}) × \frac {1} {2^{u +v - 1}} =
\\
2(\frac {(l_1 - l_2)} {2} \frac {(r_2 - r_1)} {2} + \frac {(l_1 - l_2)} {2} \frac {(r_3 - r_2)} {4} ...)
$$
​	==**展开后**==，发现可以合并，易得：
$$
contribution_i = 2 × w_i × (\sum _{u = 1} ^ {T} \frac {l_{u - 1} - l_u} {2^u})(\sum _{v = 1} ^ {T} \frac {l_v - l_{v - 1}} {2^v})
$$
​	这样，==如果知道了 $l$ 和 $r$，就能在线性时间内处理出答案。==

###### ④排序 + 链表

​	用这个奇技淫巧来维护左边和右边比自己大的数。**这是一个 NOIP 初赛和复赛都有过的技巧，只是不会写。**

​	（1）用链表按==原顺序==链起来。

```c++
for (int i = 1; i < n; i++)
{
	right[i] = i + 1;
	left[i + 1] = i;
}
```

​	（2）==按从小到大的顺序处理。==不难发现，由于第一个处理的时最小的，因此左右两边都是原顺序上第一个比自己大的。==处理完后在链表中删除自己，再继续处理第一个比自己大的。==

```c++
//删除自身
if (INT &t = right[left[idx[i]]])
	t = right[idx[i]];
if (INT &t = left[right[idx[i]]])
	t = left[idx[i]];
```

​	不断重复，这样就能找到左边和右边第一个比自己大的数。如果遍历整个链表，就能得到左边和右边所有比自己大的数，正好满足要求。

##### Day12 T3

###### 分析数据规模，DP

###### ①数据规模

​	不要犹豫，既然题目说了 $nm \le 10^{5}$，就要相信它。观察发现，==当操作次数比区间长度还要多时，不存在合法的操作序列，所以此时答案为 0。==所以操作次数最多只有 $\sqrt {10^{5}} = 320$，**并且这个时候的 $n$ 也是 320。**这给了我们一个 $O(n^3)$ 的机会。

###### ②DP

​	==由于要算 $k$ 次方，如果我们不以当前在第 $i$ 个位置为一个状态的话，我们将难以进行转移。==所以考虑设 $f_i$ 表示当前正在第 $i$ 个位置处理的答案。

​	既然我们要算答案，我们必定要知道当前位置最终是多少。很明显就要设 $f_{i, j, k}$ [^ 1]表示在 $i$ 个位置，放了 $j$ 个左括号，$k$ 个右括号的答案。==我们肯定就处于 $j - k$ 个区间中，最终的数为 $j - k$。==

​	考虑细节。发现，一个位置对答案的贡献，取决于前面有多少种方式。所以我们还要求方案数。设 $w_{i, j, k}$ 表示当前在第 $i$ 个位置，放了 $j$ 个左括号，$k$ 个右括号的方案数。转移时，==有四种方案==：一是什么都不放，二是放一个左括号，三是放一个右括号，四是放一个左括号和一个右括号。特判条件应该很好写。

​	考虑最终答案。发现，如果我们定义 $f_{i, j, k}$ 为第 $i$ 个位置放了 $j$，$k$ 个括号时第 $i$ 个位置对最终答案的贡献，我们就很难统计最终答案。==**因为我们无法知道一个位置放了 $j$，$k$ 个括号时，它能否最终形成合法方案。**所以我们只能定义 $f_{i, j, k}$ 为第 $i$ 个位置放了 $j$，$k$ 个括号时前 $i$ 个位置的答案。这样答案就是 $f_{m, n, n}$ 了。==

​	因此，转移时除了要加上当前位置的贡献，还要加上上一个位置以前的贡献。

​	时间复杂度为 $O(n^2 m)$，由于 $nm \le 10^5$，$n \le \sqrt{10^5}$，所以可行。

[^ 1]: 这里只是粗略地讲，不是最终的定义。只是为了说明要有什么参数。

###### ③memset

​	时隔四月，又见 memset 卡人。首先，我们肯定要用滚动数组，然后我们就要考虑清空数组了。但是这里不能用 memset，否则时间复杂度就变为 $O(10^5 n)$，直接爆掉。

​	可以自己手写清空，就跑得飞快了。