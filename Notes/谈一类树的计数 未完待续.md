[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 谈一类树的计数

从最简单的开始。

#### 有标号无根树

首先你得知道 [Prüfer 序列]() 的相关知识。

##### 1. 没有限制时

直接由 Cayley 定理得无限制的有标号无根树的计数为[^n]：
$$
n^{n - 2}
$$

[^n]: 如果没有特殊说明，默认有 $n$ 个结点。

#####2. 给定度数时

设每个点的度数为 $d_i$，直接由 Prüfer 序列的推论得计数为：
$$
\frac {n!} {\prod_{i = 1}^{n} (d_i - 1)}
$$

##### 3. 有度数限制时

设每个点的度数最多为 $d_i$，好像问题就变得棘手起来了。

考虑继续结合 Prüfer 序列的相关知识使用动态规划。设 $f_{i, j}$ 表示考虑了前 $i$ 个结点，Prüfer 序列长为 $j$ 时的计数。

转移时，枚举当前点的度数，结合组合数转移即可。时间复杂度 $O(n^3)$。

```c++
f[0][0] = 1;
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= n - 2; j++)
        for (int k = 0; k < d[i] && j - k >= 0; k++)
            f[i][j] = (f[i][j] + f[i - 1][j - k] * C(j, k) % mod) % mod;
printOut(f[n][n - 2]);
```

这是一个卷积的形式，可以使用 NTT 优化，时间复杂度为 $O(n^2 \log n)$。

##### 4. e.g. [CODEVS 1850 (BZOJ 1005) 明明的烦恼](http://www.codevs.cn/problem/1850)

这个题也是有标号无根树计数，所以考虑使用 Prüfer 序列，将计数问题转换到序列上。

对于度数确定的点，可以把它们单独放到一个序列中，这时它们的计数相当于有重复元素的排列。
$$
\frac {n!} {a_1! a_2! \cdots a_k!}
$$
对于度数不确定的点，由于 Prüfer 序列中已经放好了度数确定的点了，所以剩下的空位随便放，这时它们的计数相当于不限元素出现次数的排列。
$$
k^n
$$
最后，需要将这两个情况合在一起，相当于是在长度为 $n - 2$ 的序列中选出指定个位置。最后对这三种情况使用乘法原理即可。
$$
\mathrm C_{n - 2}^{k}
$$
注意高精度的实现。组合数虽然一定是整数，但是除法是无法避免的。

#### 有标号有根树

##### 1. 没有限制时

有一个显然的结论：每一种有标号无根树的情况都对应 $n$ 种有标号有根树的情况，因为每一个结点都可以为根。由这个结论，结合 Cayley 定理，可以得到有标号有根树的计数为：
$$
n^{n - 1}
$$

##### 2. 其它情况

结合 1 中提到的显然的结论，所有有标号的树的计数问题都可以转换为有标号无根树的计数问题，这里不再赘述。

#### 无标号有根树

无标号的树的计数问题比有标号的树的计数问题更加困难，因为它没有 Prüfer 序列这样有力的工具。

##### 1. 没有限制时

设 $f_i$ 表示 $i$ 个结点的无标号有根树个数。

一种简单的想法是：枚举根结点的子树大小，然后直接使用加法原理和乘法原理进行计算。

例如，对于前几项：
$$
f_1 = 1
\\
f_2 = f_1 = 1
\\
f_3 = f_1 × f_1 + f_2 = 2
\\
f_4 = f_1 × f_1 × f_1 + f_1 × f_2 + f_3 = 4
\\
f_5 = f_1 × f_1 × f_1 × f_1 + f_1 × f_1 × f_2  + f_1 × f_3 + f_2 × f_2 + f_4 = 9
\\
f_6 = f_1^5 + f_1^3 × f_2 + f_1^2 × f_3 + f_1 × f_2^2 + f_1 × f_4 + f_2 × f_3 + f_5 = 20
\\
\vdots
$$
不难验证其正确性：加法原理的每一部分是互斥的（因为子树大小都不一样），也不存在遗漏的情况（各种子树大小都枚举完了）。

但是，直接计算的时间复杂度为整数的划分数，增长速度较快，且难以实现。有没有更好的方法呢？

------

可以考虑枚举每个大小的子树有多少个：
$$
f_n = \sum_{j_1 + 2 j_2 + 3 j_3 + 4 j_4 + ... + (n - 1)j_{n - 1} = n - 1}
\left(
\prod_{k = 1}^{n - 1}
\mathrm{C}(f_k + j_k - 1, j_k)
\right)
$$
