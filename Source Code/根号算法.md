##### 1. 分块算法

​	分块算法是指，把序列上的问题分成一块一块的，然后分别维护其信息。查询时，如果待查询区间是一整块（多个整块），那么对于每一个整块就用维护好的信息 O(1) 得到答案；如果待查询区间不是一个整块（对于一个很大的查询区间，这种情况一定出现在区间两端），**就一个元素一个元素地暴力计算答案**。修改时，如果只存在单点修改，直接修改该点并维护对应块的信息即可；如果存在区间修改，则加上一个修改标记，往往这个标记是怠惰的。修改区间操作时，跟查询区间的操作类似，中间整块改，两边暴力改。

​	不难发现，如果块的大小为 $\sqrt {n}$，那么整个操作的时间复杂度将是 $O(n \sqrt {n})$ 的。**因此，用这种算法在 1 s 内能够解决 n 大约为 50000 的问题。**

#####2. [JZOJ 4243](https://jzoj.net/senior/#main/show/4243)

- [ ] 分块维护桶

######①分块

​	直接每个区间开一个桶，然后每个区间加上一个标记即可。**标记的含义为当前块的数以及桶都加上了 v。**

###### ②标记

​	**注意块标记的含义。**查询时，**暴力查询应当检查 a[i] + flag 是否在 S 中，而区间查询则查询 S[i] - flag 的个数**。修改时，**暴力修改只维护 a[i] 和桶，不管标记的事；而区间修改时只需要修改标记**。

​	**还要注意在加了标记后是否会有数组越界等问题。**

###### ③分块处理

​	一种自认为可以的做法是分两种情况处理分块。首先计算出点在哪个块中，以及 l 所在块的最后一个元素的位置和 r 所在块的第一个元素的位置。

```c++
	INT l = readIn();
	INT r = readIn();
	INT lInBlock = (l - 1) / sqrtN;
	INT lEnd = (lInBlock + 1) * sqrtN;
	INT rInBlock = (r - 1) / sqrtN;
	INT rBegin = rInBlock * sqrtN + 1;
```

​	然后分成两种情况处理。当 lInBlock = rInBlock 时，直接暴力修改 l 和 r。否则，分成三段处理，**而此时的 lEnd 和 rBegin 一定是有效的**。

```c++
	if (lInBlock == rInBlock)
	{
		for (int i = l; i <= r; i++);
	}
	else
	{
		for (int i = l; i <= lEnd; i++);
		for (int i = lInBlock + 1; i <= rInBlock - 1; i++);
		for (int i = rBegin; i <= r; i++);
	}
```

##### 3. [Luogu 3203](https://www.luogu.org/problemnew/show/3203)

​	