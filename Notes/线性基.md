[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 线性基

全网只服 Sengxian Orz。我只是他的搬运工，所以还是去看原文吧。

[参考资料：线性基学习笔记，Sengxian's Blog](https://blog.sengxian.com/algorithms/linear-basis)

## 线性基能干什么

学了线性基，你可以：

1. 在 $O(64 n)$ 的时间复杂度内求出在 $n$ 个数中任选任意多个数的最大异或和。
2. 在 $O(64 n)$ 的时间复杂度内求出在 $n$ 个数中任选任意多个数的第 $k$ 大异或和，其中重复的算一个。也可以给定异或和求排名。
3. 在 $O(64 n)$ 的时间复杂度内求出一个数与数集中的任意多个数的最大异或和。
4. 在 $O(64 n)$ 的时间复杂度内求出在 $n$ 个数中任选任意多个数的第 $k$ 大异或值，其中重复的算多个。也可以给定异或和求排名。
5. 对于一个没有修改的序列，在 $O(64^2 n \log n)$ 初始化，$O(64^2)$ 查询的时间复杂度内求出一个区间中任选任意多个数的最大异或和。

## 简单线性代数入门（初步）

##### 1. 向量空间

定义 $(F, V, +, \cdot)$ 为*向量空间（vector space）*，其中 $F$ 为域[^domain]，$V$ 为向量集合，$+$ 为向量加法，$\cdot$ 为标量乘法，且运算满足 $8$ 条公理：

[^domain]: 比如整数域，实数域，或者复数域。以整数域为例，在整数域中，所有标量都是整数。

1. 向量加法的结合律。$\vec u + (\vec v + \vec w) = (\vec u + \vec v) + \vec w$。
2. 向量加法的交换律。$\vec u + \vec v = \vec v + \vec u$。
3. 向量加法的单位元。即数学课上的零向量 $\vec 0$，任何 $\vec u \in V$ 都满足 $\vec u + \vec 0 = \vec u$。
4. 向量加法的逆元。即数学课上的相反向量 $- \vec u$，任何 $\vec u \in V$ 都存在其逆元 $- \vec u$ 使得 $\vec u + (- \vec u) = 0$。
5. 标量乘法与标量的域乘法相容。$a(b \vec v) = (ab) \vec v$。
6. 标量乘法的单位元。即 $1 \vec v = \vec v$。
7. 标量乘法对向量加法的分配律。即 $a(\vec u + \vec v) = a \vec u + a \vec v$。
8. 标量乘法对域加法的分配律。即 $(a + b) \vec v = a \vec v + b \vec v$。

##### 2. 线性无关

对于向量空间中 $V$ 上 $n$ 个元素的向量组 $(\vec {v_1}, \cdots, \vec {v_n})$，若存在不全为 $0$ 的数组 $(a_1, \cdots, a_n) \pod {a_i \in F}$ 满足：
$$
a_1 \vec{v_1} + a_2 \vec{v_2} + \cdots + a_n \vec{a_n} = \vec{0}
$$
则称这 $n$ 个向量为*线性相关的（linearly dependent）*，否则称它们为*线性无关的（linearly independent）*。

##### 3. 线性组合 

对于向量空间中 $V$ 上 $n$ 个元素的向量组 $(\vec {v_1}, \cdots, \vec {v_n})$，其*线性组合（linear combination）* 是如下形式的向量：
$$
a_1 \vec{v_1} + a_2 \vec{v_2} + \cdots + a_n \vec{a_n} \pod {a_i \in F}
$$
结论：一组向量线性无关 $\Leftrightarrow$ 没有向量可用有限个其它向量的线性组合表示

对于以上内容，你可以以二维向量为例，结合你在数学课上学的向量进行理解。

##### 4. 张成

对于向量空间中 $V$ 上 $n$ 个元素的向量组 $(\vec {v_1}, \cdots, \vec {v_n})$，其所有线性组合所构成的**集合**称为 $(\vec {v_1}, \cdots, \vec {v_n})$ 的*张成（span）*，记作 $\mathrm{span}(\vec {v_1}, \cdots, \vec {v_n})$。

##### 5. 基

向量空间中 $V$ 的*基（basis）* 是一个向量组 $B$，且满足 $B$ 既是线性无关的又可以张成 $V$。其实就是数学课上学的基底。

需要注意的是，$B$ 是一个向量集合，$V$ 也是一个向量集合。

称 $B$ 中的元素为*基向量*。

###### 性质

需要注意的是，**$B$ 还要满足一些性质才能被称为 $V$ 的基**：

1. $V$ 是 $B$ 的极小生成集。就是说只有 $B$ 能张成 $V$，而它的任何真子集都不张成全部的向量空间。
2. $B$ 是 $V$ 中线性无关向量的极大集合。就是说 $B$ 在 $V$ 中是线性无关集合，而且 $V$ 中没有其它线性无关集合包含它作为真子集。
3. $V$ 中所有的向量都可以按唯一的方式表达为 $B$ 中向量的线性组合。

结合你在数学课上学的基底，你会发现上面这些不都是学过的吗……

##### 6. 线性相关性引理

如果 $(\vec{v_1}, \cdots, \vec{v_n})$ 在 $V$ 中是线性相关的，并且 $\vec{v_1} \ne \vec 0$，则有至少一个 $j \in \{ 2, \cdots, n \}$ 使得以下成立：

1. $\vec{v_j} \in \mathrm{span}(\vec{v_1}, \cdots, \vec{v_{j - 1}})$

感性理解下，可以以二维向量为例进行理解。

2. 如果从 $(\vec{v_1}, \cdots, \vec{v_n})$ 去掉第 $j$ 项，则剩余向量组的张成仍然等于 $\mathrm{span}(\vec{v_1}, \cdots, \vec{v_n})$。

同样可以感性地理解下。

## 线性基入门

##### 1. 异或加法下的向量空间

对于数 $a_1, \cdots, a_n$，将 $a_i$ 的二进制表示 $(b_m \cdots b_0)_2$ 看作向量 $\vec{a_i} = (b_m, \cdots, b_0)$。为了方便，称 $\vec{a_i}$ 的第 $j$ 位为 $b_j$。

向量组 $(\vec{a_1}, \cdots, \vec{a_n})$ 可以张成一个向量集合 $\mathrm{span}(\vec{a_1}, \cdots, \vec{a_n})$，借此我们定义向量空间 $(\{ 0, 1 \}, \mathrm{span}(\vec{a_1}, \cdots, \vec{a_n}), \oplus, \cdot)$，其中 $\oplus$ 表示异或，$\cdot$ 表示数乘。可以验证，这个向量空间是合法的。

我们的任务是：利用向量组 $(\vec{a_1}, \cdots, \vec{a_n})$，即 $n$ 个 $k$ 位二进制数 $a_1, \cdots, a_n$，来求出以 $\mathrm{span}(\vec{a_1}, \cdots, \vec{a_n})$ 为向量集合的向量空间中的一个基 $B$。

##### 2. 用已有向量组求基

假设我们已有 $B = (\vec{a_1}, \cdots, \vec{a_n})$，我们要求是 $\mathrm{span}(\vec{a_1}, \cdots, \vec{a_n})$ 的基。

第 $1$ 步：如果 $\vec {a_1} = \vec 0$，则从 $B$ 中去掉 $\vec {a_1}$，否则保持 $B$ 不变。

第 $j$ 步：若 $\vec {a_j} \in \mathrm{span}(\vec{a_1}, \cdots, \vec{a_{j - 1}})$，则从 $B$ 中去掉 $\vec{a_j}$，否则保持 $B$ 不变。

-----

经过 $n$ 步后终止程序，得到一个向量组 $B$。由于每一次去掉的向量包含于前面所有向量的张成，所以到最后 $B$ 仍然可以张成 $V$。而我们又确保了 $B$ 中的任何向量都不包含于它前面所有向量的张成，根据线性相关性引理可知 $B$ 是线性无关的。于是 $B$ 是 $V$ 的一个基。

于是，我们立马就能得到一个时间复杂度为 $O(64 n)$（$64$ 代表二进制数的位数，为什么时间复杂度是这么多，请往下看）的构造基的算法。我们可以利用高斯消元来判断向量能否被前面的向量张成。

首先注意，我们可以用一个数表示矩阵的一行，因为向量空间的域为 $\{ 0, 1\}$，这和二进制数的一位是相对应的。

我们维护一个**上三角**矩阵，拿来表示线性基。矩阵的每一行都对应了一个向量，并设矩阵的第一行对应二进制的最高位，第二行对应二进制的次高位，以此类推。执行到第 $i$ 步的时候，我们从高到低考虑数 $a_i$ 每一个为 $1$ 的二进制位 $j$。如果第 $j$ 位对应行的主对角线上已经为 $1$ 了，那么我们不能加入 $a_i$ 到 $j$ 的对应行，但是 $a_i$ 还是有希望插入线性基中的。为了让插入 $a_i$ 到矩阵后矩阵仍然满足上三角形性质，需要将第 $j$ 位这一行的向量异或到 $\vec {a_i}$ 中（即令 $a_i = a_i \oplus a_j$），然后继续往更低位进行判断。

如果 $j$ 这一行的主对角线为 $0$，那么我们就可以将 $\vec {a_i}$ 添加到这一行。将 $\vec {a_i}$ 添加到某一行中时，要用这一行去消去其它行。在用 $\vec {a_i}$ 消去前面的行之前，要用下面的行把 $\vec {a_i}$ 的较低位消去。

如果向量 $\vec {a_i}$ 能被 $\vec {a_1}, \cdots, \vec {a_{i - 1}}$ 张成，那么它一定会在高斯消元时被消成 $0$，从而不会被加入到线性基中；反之，它一定能找到某一个行添加进去。

###### 线性基的定义

大家常说的*线性基*一般都指这个方式得到的基，因为这个基具有一个独特的性质。这个基特指**高斯消元解出的对角矩阵的非零行构成的向量组**。

##### 3. 线性基的性质

对于最后得到的矩阵，如果第 $i$ 行的主对角线上为 $1$，此时我们称第 $i$ 位*存在于线性基中*。对于存在于线性基中的二进制位，有一个重要的性质：**对于任意存在于线性基 $B$ 的二进制位 $i$，至多只有一个 $\vec{b_j} \in B$ 满足第 $i$ 位为 $1$**，其余位置我们用高斯消元消去了。

而对于不在线性基中的二进制位 $i$，第 $i$ 行主对角线的下方全为 $0$，而主对角线上方可能有若干个 $1$。

##### 4. 利用性质

###### e.g. [LOJ 113 最大异或和](https://loj.ac/problem/113)

题目大意：给由 $n \pod {n \le 50}$ [^n]个数组成的一个可重集 $S$，求一个集合 $T \subseteq S$，使得 $T_1 \oplus T_2 \oplus \cdots \oplus T_{|T|}$ 最大。你只需要求出这个最大值。

[^n]: $n$ 可以达到 $10^5$ 甚至更大。

------

我们求出向量空间 $V$ 的一组[线性基](#线性基的定义)，则答案就是**将线性基中所有向量异或起来**得到的向量所对应的数。（注意线性基中的所有向量指所有[存在于线性基中](#3.-线性基的性质)的向量）

> 证明
>
> 我们贪心地选择现在可以选的最高位，如果现在最高位不能选，那么答案会更劣。根据基的定义，其异或和一定能由原数集中的数异或得到。

###### 参考代码

```c++
LL linearBasis[bitlen];
void init()
{
	LL bitmov[bitlen];
	bitmov[0] = 1;
	for (int i = 1; i < bitlen; i++)
		bitmov[i] = bitmov[i - 1] << 1; // 防止 1 << i 溢出
	for (int i = 1; i <= n; i++)
	{
		LL t = a[i];
		for (int j = bitlen - 1; ~j; j--)
		{
			if (!(t & bitmov[j])) continue;

			if (linearBasis[j]) t ^= linearBasis[j];
			else
			{
				for (int k = j - 1; ~k; k--)
					if (t & bitmov[k]) 
						t ^= linearBasis[k]; // 用下面消自己低位
				for (int k = j + 1; k < bitlen; k++)
					if (linearBasis[k] & bitmov[j])
						linearBasis[k] ^= t; // 用自己消上面
				linearBasis[j] = t;
				break;
			}
		}
	}
}
LL query()
{
	LL ans = 0;
	for (int i = bitlen - 1; ~i; i--)
		ans = std::max(ans, ans ^ linearBasis[i]); // 从高位向低位贪心
		//if(linearBasis[i])
			//ans ^= linearBasis[i]; // 从高位向低位贪心
	return ans;
}
```

## 高级应用

##### 1. e.g. [HDU 3949 XOR](http://acm.hdu.edu.cn/showproblem.php?pid=3949) 求不重复的第 $k$ 大异或值

题目大意：给定一个 $n$ 个数的可重集 $A$，你可以选择任意多个数字求异或和。求出第 $k$ 大的异或和，重复的仅算一次。

------

我们求出向量空间的一组线性基 $B$。**因为向量空间中的任意向量 $\vec u$ 均可以被表示成 $B$ 中向量的唯一线性组合，所以 $B$ 中的任意非空子集都可以构成一个向量且互不重复。**所以这些数能够组成的异或和的个数为 $2^{|B|} - 1$。特别地，如果 $|B| < n$，则必然存在一个向量组满足线性相关性，这个向量组的线性组合之一就有了 $\vec 0$，则异或和的个数为 $2^{|B|}$。

假设线性基中有 $m$ 个基向量，从小到大依次为 $(\vec {v_0}, \cdots, \vec{v_{m - 1}})$，则第 $k = (b_x \cdots b_0)_2$ 小的数为：
$$
\bigoplus_{0 \le i < m} b_i \cdot v_i
$$
仅当 $|B| < n$ 时，$b$ 才能全为 $0$。

###### 参考代码

```c++
LL query(LL rank)
{
	if (rank > (1ll << size) - 1 + (size != n)) return -1;
	rank--; // 从 0 开始计数
	if (n == size) rank++; // 没有 0 这个答案
	LL ret = 0;
	for (int i = 0; i < bitlen; i++)
	{
		if (lb[i])
		{
			if (rank & 1) ret ^= lb[i];
			rank >>= 1;
		}
	}
	return ret;
}
```

##### 2. e.g. [BZOJ 2115 [WC 2011] Xor](https://www.lydsy.com/JudgeOnline/problem.php?id=2115) 求一个数与数集中任选任意多个数异或的最大值 

题目大意：给定一张 $n \pod {n \le 5 \times 10^4}$ 个点 $m \pod {m \le 10^5}$ 条边的无向图，可能有重边或自环。每个边有求出从 $1$ 到 $n$ 的任意一条路径的边权异或和的最大值。路径可以重复经过某些点或边（包括点 $1$ 和点 $n$），且重复经过的边权算多次。

------

首先需要发现这样一个结论：对于图中的环，我们可以直接算上它的异或和。

> 证明
>
> 我们可以从 $1$ 出发，走到环上，绕环一圈，然后回到 $1$，这样我们就算了这个环，但是我们所在的位置没变，且没有算别的贡献。

然后需要发现这样一个结论：对于 $1$ 到 $n$ 的一条简单路径，如果它不是唯一的，那这条路径和另外任意一条从 $1$ 到 $n$ 的简单路径都形成了一个环。

> 证明
>
> 显然形成了一个从 $1$ 到 $n$ 再到 $1$ 的环。

所以我们的目标是：求出所有环的权值的异或和，设其可重集为 $A$；设任意一条从 $1$ 到 $n$ 的简单路径的异或和为 $d$，则我们需要求的是 $d$ 与 $A$ 中的任选元素进行异或的最大值。

如何求一个元素与集合元素的最大异或和呢？只需要在线性基中从大到小进行异或，每次取 $\max$ 就好了。

> 证明
>
> 从高到低考虑每个二进制位，设当前的答案为 $s$，考虑到第 $k$ 位，线性基向量中代表二进制位 $k$ 的向量为 $\vec v$。那么对于第 $k$ 位，一共有三种情况，我们分别考虑我们的选择原则是不是正确的。
>
> 1. $s$ 中第 $k$ 位是 $1$，$\vec v$ 中第 $k$ 位是 $1$，实际上不能选。根据我们的选择原则，此时异或起来答案一定会变小，不选。正确。
> 2. $s$ 中第 $k$ 位是 $0$，$\vec v$ 中第 $k$ 位是 $1$，实际上要选。根据我们的选择原则，此时异或起来答案一定会变大，选。正确。
> 3. $\vec v$ 中第 $k$ 位是 $0$，那么 $\vec v$ 必定是零向量，选不选无所谓。正确。

所以我们就能在 $O(64 n)$ 的时间复杂度内求出一个数与数集中的任选数异或的最大值。

###### 参考代码

```c++
LL query(LL x)
{
	for (int i = bitlen - 1; ~i; i--)
		x = std::max(x, x ^ lb[i]);
	return x;
}
```

```c++
bool vis[maxn];
LL Xor[maxn];
void DFS(int node, int parent)
{
	vis[node] = true;
	wander(G, node)
	{
		DEF(G);
		if ((idx(G) >> 1) == (parent >> 1)) continue;
		if (vis[to])
		{
			insert(Xor[to] ^ Xor[node] ^ cost);
			continue;
		}
		Xor[to] = Xor[node] ^ cost;
		DFS(to, idx(G));
	}
}
```

```c++
printOut(query(Xor[n]));
```

另外这个题也告诉了我们一些技巧：求异或和可以考虑走两次消除贡献。

##### 3. [e.g. BZOJ 2844 albus 就是要第一个出场](https://www.lydsy.com/JudgeOnline/problem.php?id=2844) 求重复的第 $k$ 大异或值

题目大意：给定 $n \pod {n \le 10^6}$ 个数 $a_1, a_2, \cdots, a_n$，以及一个数 $Q$。将 $a_1, a_2, \cdots, a_n$ 的所有子集（可以为空）的异或值从小到大排序得到序列 $B$，问 $Q$ 在 $B$ 中第一次出现的下标是多少？保证 $Q$ 在 $B$ 中出现过。

------

考虑如果题目要求对 $B$ 进行去重该怎么做。若线性基为 $(\vec {v_0}, \cdots, \vec{v_{m - 1}})$，根据第 $k = (b_x \cdots b_0)_2$ 大的数为 $\bigoplus_{0 \le i < m} b_i \cdot v_i$，我们可以从高位向低位逐位检查 $Q$ 是否被选过，这样就知道了 $k$，也就是 $Q$ 的排名。

那么如果重复的算多次，该怎么做呢？如果我们知道了每个数在题目给的 $B$ 中出现了多少次，那么问题可能会变得可解。

结论：**每个数出现的次数都一样，且这个次数为 $2^{n - |B|}$。**

> 证明
>
> 线性基中有 $|B|$ 个数，线性基外有 $n - |B|$ 个数。对于线性基外的数，我们有 $2^{n - |B|}$ 中选择方案，每种方案的异或和我们都能在线性基中找到一个线性组合使得整体异或和为 $0$（一个数在线性基中被选了多次没有关系，选偶数次相当于不选）。所以对于线性基的一个线性组合，在考虑了线性基外的数后都有 $2^{n - |B|}$ 种不同的方案。

由于集合可以为空，因此异或和始终都可以为 $0$。

###### 参考代码

```c++
int query(int x)
{
	std::vector<int> vec;
	for (int i = 0; i < bitlen; i++)
		if (lb[i])
			vec.push_back(i); // note: 为了正确排名
	int ret = 0;
	for (int i = 0; i < vec.size(); i++)
		if (x & (1 << vec[i]))
			ret |= 1 << i;
	return (ret % mod * power(2, n - size) % mod + 1) % mod; // note: 异或和可以为 0
}
```

##### 4. e.g. [异或问题]() 线性基合并

题目大意：给一个长度为 $n$ 的非负整数序列 $a \pod {n \le 3 \times 10^4}$（下标从 $1$ 开始），给定 $Q \pod {3 \times 10^5}$ 个形如 $(l, r, d)$ 的询问，求出在 $a_l \sim a_r$ 中任选任意个数（可以不选）与 $d$ 的最大异或和。

------

如果我们能求得 $a_l \sim a_r$ 之间的线性基，我们就能在 $O(64)$ 的时间复杂度内求得答案。

事实上，线性基支持合并，只需要把一个线性基中的所有向量插入到另一个线性基中就好了。合并两个线性基的时间复杂度为 $O(64^2)$。（$64$ 代表位长，这道题位长为 $30$）

对于这道题，我们可以用线性基合并，结合 ST 表解决。

###### 参考代码

```c++
static LinearBasis merge(const LinearBasis& a, const LinearBasis& b)
{
	if (a.size == bitlen) return a; // note: 满的线性基合并了还是满的
	if (b.size == bitlen) return b;
	LinearBasis ret = a;
	for (int i = 0; i < bitlen; i++)
		ret.insert(b.lb[i]);
	return ret;
}
int query(int d)
{
	for (int i = bitlen - 1; ~i; i--)
		d = std::max(d, d ^ lb[i]);
	return d;
}
```

需要注意的是，查询时不能分成两次查询，而是要**先合并再做一次查询**。为什么不能分成两次查询呢？可以将其理解成一个错误的贪心，局部最优不一定全局最优。

```c++
void init()
{
	while (1 << (maxk + 1) < n) maxk++;
	for (int i = 1; i <= n; i++)
		lb[0][i].insert(a[i]);
	for (int i = 1; i <= maxk; i++)
		for (int j = 1; j + i - 1 <= n; j++)
			lb[i][j] = LinearBasis::merge(lb[i - 1][j], lb[i - 1][j + (1 << (i - 1))]);

	for (int i = 1; i <= n; i++)
	{
		int& Log = logn[i];
		while (1 << (Log + 1) < i) Log++;
	}
}
int query(int l, int r, int d)
{
	int length = r - l + 1;
	int k = logn[length];
	return LinearBasis::merge(lb[k][r - (1 << k) + 1], lb[k][l]).query(d); // note
}
```