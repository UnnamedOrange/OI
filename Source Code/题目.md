#####1. [JZOJ 4233](https://jzoj.net/senior/#main/show/4233)

- [x] 使用调整法求树的重心

      主要用到了定理：**树的重心每棵子树的大小一定小于等于 n / 2。**因此我们假设一个点为重心，然后判断是否有子树（包括自身这棵子树的其余部分）的大小**大于** n / 2，如果有，我们就假设那个新的点为重心。继续走，直到没有子树大小大于 n / 2，这时当前点就为重心。

      实际实现中，没有必要检查是否需要往上走（即检查自身对应子树的其余部分），因为我们肯定是从上而下走来的，所以肯定不会走回头路。

      ```c++
      INT adjust(INT root)
      {
      	INT maxIdx = 0;
      	for (int i = G.head[root]; i; i = G.edges[i].next)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to == parent[root])
      			continue;
      		if (size[to] > n / 2)
      		{
      			maxIdx = to;
      			break;
      		}
      	}
      	return maxIdx;
      }
      ```

      ```c++
      	INT center = 1;
      	while (INT t = adjust(center))
      		center = t;
      ```

      ​

      另一方面，这个做法对于求子树的重心就很有用（比如在点分治时），它只需要**从上往下走**（**因为起点为子树的根结点，所以不需要回头**）就可以了，而不需要一次额外的 DFS。


#####2. [JZOJ 1301](https://jzoj.net/senior/#main/show/1301)

- [x] 使用调整法求树的重心

      除了树的重心的求法，这道题还涉及两个重心的问题。首先，一棵树有两个重心的必要条件是这棵树的结点数为偶数；其次，它的充分条件是存在一条边，连接两棵大小相同的子树。因此，另一方面，**树的两个重心总是相邻的**。

      ```c++
      	INT center2 = 0;
      	if (!(n & 1))
      	{
      		for (int i = G.head[center]; i; i = G.edges[i].next)
      		{
      			const Edge& e = G.edges[i];
      			INT to = e.to;
      			if (to == parent[center])
      				continue;
      			if (size[to] == n / 2)
      			{
      				center2 = to;
      				break;
      			}
      		}
      		//center 是从上往下找过来的，所以不用找父结点
      		if (center2 && center > center2)
      			std::swap(center, center2);
      	}
      ```

      另外，我们的 center 是从根结点开始，肯定是从上往下调整的，所以 center2 一定不会是 center 的父结点。

##### 3. 树的重心知识点整理

定理 1：树的重心每棵子树的大小一定小于等于 n / 2。作用：判定一个点是否是重心。

定理 2：每棵子树的大小小于等于 n / 2 的结点为重心。作用：求重心。

定理 1 和定理 2 互为逆定理。

定理 3：设 f(x) = 树中所有点到 x 的距离和，则重心的 f 值最小（如果有两个重心，它们 f 值一样）。证明方法：在重心上反证，发现如果移动到相邻点，距离变大了。

定理 4：两棵树通过一条边相连成为一棵新树，新树重心一定在原来两棵树的重心的路径上。

#####4. 树的直径知识点整理

定理 1：以树上任意一个点为起点的最长路径，终点一定是直径的一个端点。

定理 2：对于两条相交的直径，它们不相交部分一定对称。

定理 3：两棵树用一条边合并，新树直径两端一定是原本两棵树直径的四个端点中的两个。

定理 3 的扩展：在树上，对于两个不相交的结点集合，每个集合知道一个最远点对，则两个集合的并的最远点对一定是这两个集合的最远点对的四个端点中的两个。

虚树的定义：在一棵树上，给定一个集合 S，将包含 S 的最小连通块叫做 S 的虚树。定理 3 的扩展中的最远点对可以看作集合对应的虚树的直径。

#####5. [JZOJ 4727](https://jzoj.net/senior/#main/show/4727)

- [x] 使用动态规划求树的直径，使用两次深搜的方法将以 1 为根的答案转移至以 i 为根。

      1.求整棵树的直径

      ​	方法：处理出有根子树的最长链 `length[i][0]` 和次长链 `length[i][1]`，取 `length[i][0] + length[i][1]` 的最大值，设为 `d[i]`。

      ​	**注意：一定是取最大值，而不是根结点的最长链和次长链之和。**

      2.求整棵树排除一棵子树后的直径

      ​	方法：首先想办法**把有根树的 length 转化为 length2。为了防止转移时转移到被排除的子树，还要同时记录子链是从哪里转移来的（who2）。由于我们需要最长和次长，同时有可能（最多）有一个不能进行转移，因此我们保存前三大的 length。**这种通过旋根把有根树的答案转换为无根树的答案往往都需要用这样的方法。

      ​	接下来，考虑如何求直径。我们定义 `d2[i][0 / 1]` 为以 i 为整棵树的根，不经过 i 的直径中最长和次长的长度（因此该直径一定在 i 的一棵子树内）。肯定我们还需要保存 d2 是对应的哪棵子树，用 where 表示。

      ​	现在的问题是，如何求 d2 呢？首先，对于边界情况 i = 1，d2 就是取其子树的 d 的最大值。考虑其它子树，发现只有两种可能，一是取其子树的 d，二是把其父结点看作一棵子树，所以首先用父结点的 d2 更新子树的 d2，然后考虑经过父结点的直径，取不经过当前结点的两条最长链之和更新 d2 即可。由于更新 length2 和 d2 均是从上至下的，因此可以放在一个深搜中。

      ​	需要注意的是，在进行下次 DFS 前，首先得保证当前结点已完全更新，所以得遍历两次边，先更新 d2 后再进行下一次 DFS。

      ```c++
      INT length2[maxn][3];
      INT who2[maxn][3];
      INT d2[maxn][3];
      INT where[maxn][3];
      void DFS2(INT node)
      {
      	if (node != 1)
      	{
      		INT l = length2[parent[node]][0];
      		INT w = who2[parent[node]][0];
      		if (w == node)
      		{
      			l = length2[parent[node]][1];
      			w = who2[parent[node]][1];
      		}
      		l += pCost[node];
      		update3(l, w, node, length2, who2);

      		w = parent[node];
      		//d2 实际上只需要最大和次大，这里只是为了方便，定义成了保存前三大
      		if (where[w][0] != node)
      			update3(d2[w][0], where[w][0], node, d2, where);
      		if (where[w][1] != node)
      			update3(d2[w][1], where[w][1], node, d2, where);

      		if (who2[w][0] == node)
      			l = length2[w][1] + length2[w][2];
      		else if (who2[w][1] == node)
      			l = length2[w][0] + length2[w][2];
      		else
      			l = length2[w][0] + length2[w][1];
      		update3(l, w, node, d2, where);
      	}
      	wander(G, node)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to != parent[node])
      			update3(d[to], to, node, d2, where);
      	}
      	wander(G, node)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to != parent[node]) DFS2(to);
      	}
      }
      ```

      ```c++
          INT ans = 0;
          for (int i = 2; i <= n; i++)
          {
              INT temp = 0;
              INT p = parent[i];
              if (i == who2[p][0])
                  temp = length2[p][1] + length2[p][2];
              else if (i == who2[p][1])
                  temp = length2[p][0] + length2[p][2];
              else
                  temp = length2[p][0] + length2[p][1];

              if (i == where[p][0])
                  temp = std::max(temp, d2[p][1]);
              else if (i == where[p][1])
                  temp = std::max(temp, d2[p][0]);

              temp += d[i];
              ans = std::max(ans, temp);
          }
          printOut(ans);
      ```


#####6. [JZOJ 1016](https://jzoj.net/senior/#main/show/1016)

- [x] 使用 DFS 序维护**子树的和**，进行**单点修改**

      应该是道裸题，不多说了。

##### 7. 欧拉序

######①欧拉序其实有两种

​	第一种欧拉序就是用来把 LCA 转成 RMQ 的欧拉序，序列长度为 2n - 1。有可能一个结点会出现多次，但是叶节点只会出现一次。回忆求 LCA 的过程，我们只取了第一次出现的位置作为区间的起点和终点，这可以作为更深的应用的一个参考。

​	第二种欧拉序是在结点进入时和结点离开时各加入一次序列，也就是说每个结点最多会且只会出现两次，序列长度为 2n。

######②第二种欧拉序的应用

​	考虑这样一个问题：对于一棵结点带权值的有根树，有两种操作，一种操作是给结点加上一个权值，另一种操作是求出两点之间的路径的权值和。

​	用 DFS 可以很方便快捷地解决这个问题。由于权值只有可能对子树造成贡献，因此在给一个结点加上一个权值时，就等同于给整棵子树加上一个权值，然后一个结点被加的权值之和就是该结点到根结点的路径的权值和，接下来怎么做就不需要多说了。具体的操作可以使用树状数组，用差分的思想把单点加，区间查改成区间加，单点查。但是这个方法有个问题，就是这个方法实际上是用到了“贡献”的思想，有时计算贡献会比直接加有大的局限性（见 8.）。

​	而使用第二种欧拉序则可以这么做：**在要被加的结点的起始位置加上权值，在结束位置减去权值**，则从根结点到某个结点的路径的权值之和就是**该点的起始位置的前缀和**。这样，操作就独立在了子树上，跟父结点无关了。

#####8. [JZOJ 4005](https://jzoj.net/senior/#main/show/4005)

- [ ] 维护欧拉序（2）

  （这道题没有数据，只是写了一个常数巨大的程序）

  首先，可以考虑交换操作，我们肯定是要用某种序列来维护这棵树，然后把树放在线段树上。由于颜色只有 10 种，因此可以每种颜色开一棵线段树，交换操作就可以交换线段树的区间。具体的，可以使用指针线段树，则交换的时间复杂度为 O(log n)。

  但是，如果我们使用 DFS 序，则会产生问题：DFS 序考虑的是对答案的贡献，因此移动子树后答案贡献将会变成新的父结点对这棵子树的答案贡献，也就是说，我们要维护的内容将会随着子树的交换而改变，而且很明显这个改变是难以维护的，所以这种方法不可取。

  如果使用欧拉序（2），问题就迎刃而解了。移动子树时就是移动的子树，不受父结点的影响，这就是上文所说的“独立性”和“局限性”。

  本题细节问题还有待研究。


##### 9. 树链剖分

[较具体内容](http://blog.csdn.net/lycheng1215/article/details/78721561)

这里只给出一个众所周知的定理。

定理：如果 v 是 u 的儿子，且 (u, v) 是一条轻边，那么 size(v) < size(u) / 2。

#####10. [JZOJ 2256](https://jzoj.net/senior/#main/show/2256)

- [x] 树链剖分

      这道题直接树链剖分做就可以了，大概写了 30 min。

