# 杜教筛

## 快速复习

&emsp;&emsp;（不再赘述，自行复习）

##### 1. 数论分块

##### 2. 积性函数

## 杜教筛

##### 1. 杜教筛是干什么的

&emsp;&emsp;设积性函数 $f(i)$，我们的问题是求：
$$
\sum_{i = 1}^{n} f(i)
$$
&emsp;&emsp;换句话说，我们的问题是求**积性函数的前缀和**。利用杜教筛可以在优于线性时间的复杂度内解决这个问题。

##### 2. 一般形式

&emsp;&emsp;设数论函数 $f(i)$，定义它的前缀和为：
$$
S(i) = \sum_{i = 1}^{n} f(i)
$$
&emsp;&emsp;如果有下面这个式子：
$$
\sum_{i = 1}^{n} (f * g)(i)
$$
即 $f$ 卷上 $g$ 的前缀和，那么我们有：
$$
\begin{align*}
\sum_{i = 1}^{n} \sum_{d \mid i} f(i) g(\frac {i} {d})
=&
\sum_{i = 1}^{n} g(i) \sum_{j = 1}^{\left\lfloor \frac {n} {i} \right\rfloor} d(j)
\end{align*}
$$
&emsp;&emsp;该等式表示枚举 $g$ 的参数 $i$，再枚举 $i$ 的倍数 $j$，考虑 $(f * g)(ij)$ 对答案的贡献。注意到：
$$
\begin{align*}
\sum_{i = 1}^{n} \sum_{d \mid i} f(i) g(\frac {i} {d})
=&
\sum_{i = 1}^{n} g(i) \sum_{j = 1}^{\left\lfloor \frac {n} {i} \right\rfloor} d(j)
\\=&
\sum_{i = 1}^{n} g(i) S(\left\lfloor \frac {n} {i} \right\rfloor)
\end{align*}
$$
&emsp;&emsp;即我们得到了：
$$
\sum_{i = 1}^{n} g(i) S(\left\lfloor \frac {n} {i} \right\rfloor) = \sum_{i = 1}^{n} (f * g)(i)
$$

&emsp;&emsp;将左式拆开移项到右式，可得：
$$
g(1) S(n) = \sum_{i = 1}^{n} (f * g)(i) - \sum_{i = 2}^{n} g(i) S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
&emsp;&emsp;如果卷积的前缀和以及 $g$ 都易于计算，那么我们能够在更优的时间内解决这个问题。具体的分析我们将在下面以例题的形式呈现。

##### 3. e.g. [51NOD 1244 莫比乌斯函数之和](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1244)

&emsp;&emsp;给定一组询问 $(a, b)$，试求：
$$
\sum_{i = a}^{b} \mu(i)
$$

------

###### ①杜教筛

&emsp;&emsp;首先将问题转化为前缀和相减的形式，然后考虑对原式进行变化。

&emsp;&emsp;根据莫比乌斯等式，我们有：
$$
\sum_{d \mid n} \mu(d) = [n = 1]
$$
&emsp;&emsp;即：
$$
\mu * \mathrm{1} = \epsilon
$$
&emsp;&emsp;我们取 $g = \mathrm{1}$（$\mathrm{1}$ 是常函数），代入一般形式可得：
$$
\begin{align*}
S(n) =& \sum_{i = 1}^{n} \epsilon(i) - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
\\=&
1 - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
\end{align*}
$$
&emsp;&emsp;对右侧进行数论分块，递归进行计算即可。

###### ②时间复杂度

&emsp;&emsp;不考虑具体实现，下面让我们来分析一下时间复杂度。

&emsp;&emsp;设时间复杂度为 $T(n)$，我们需要的时间大致是：
$$
T(n) = O(\sqrt n) + \sum_{i = 1}^{O(\sqrt n)} T(t(i))
$$
 &emsp;&emsp;其中 $t(i)$ 表示不同的 $\left\lfloor \frac {n} {i} \right\rfloor$。

&emsp;&emsp;当 $i$ 很大时，可以把 $T(\left\lfloor \frac {n} {i} \right\rfloor)$ 忽略不计，剩下的就是 $i$ 较小的情况，即 $\left\lfloor \frac {n} {i} \right\rfloor$ 较大的情况。所以可以得到 $T$ 的近似表达式：
$$
T(n) = O(\sqrt n) + \sum_{i = 2}^{\sqrt n} T(\left\lfloor \frac {n} {i} \right\rfloor)
$$
&emsp;&emsp;只将 $T$ 展开一层，剩下的由于展开后会变得很小，忽略不计，得：
$$
\begin{align*}
T(n) &= O(\sqrt n) + \sum_{i = 2}^{\sqrt n} O(\sqrt {\left\lfloor \frac {n} {i} \right\rfloor})
\\&=
O(\sqrt n) + O(\sqrt n) \sum_{i = 2}^{\sqrt n} O(i^{-\frac {1} {2}})
\end{align*}
$$
&emsp;&emsp;将离散的和式视为视为一个积分。因为有：
$$
(i^{\frac {1} {2}})' = \frac {1} {2} i^{-\frac {1} {2}}
$$
&emsp;&emsp;所以上式的结果为：
$$
T(n) = O(n^{\frac {1} {2}} \cdot n^{\frac {1} {2} \cdot \frac {1} {2}}) = O(n^{\frac {3} {4}})
$$
&emsp;&emsp;其中，右边的乘数是上面和式积分后的结果，左边的乘数代表 $\sqrt n$。

------

&emsp;&emsp;$O(n^{\frac {3} {4}})$ 还是太大，怎么办？当 $n$ 较小的时候，我们是可以用线性筛预处理的。所以我们需要预处理到一个合适的值，使得总时间复杂度最小。设预处理到 $k \pod {n^{\frac {1} {2}} \le k \le n}$，则对 $T$ 有：
$$
\begin{align*}
T(n) &= O(\sqrt n) + O(\sqrt n) \sum_{i = 2}^{\frac {n} {k}} O(i^{-\frac {1} {2}})
\\&=
O(\frac {n} {\sqrt k})
\end{align*}
$$
&emsp;&emsp;令 $k = n^{\frac {2} {3}}$，则能得到一个较优的时间复杂度 $O(n^{\frac {2} {3}})$。[^不会]

[^不会]: 这一块我也不会，摘自[某大神的博客](http://blog.csdn.net/skywalkert/article/details/50500009)。

###### ③ 实现

&emsp;&emsp;实现时，**必须使用 Hash 表记忆化**。**注意数论分块的循环变量要开 $\mathrm{long~long}$！**实际操作时，**必须**使用线性筛筛出前面较小的部分，Hash 表也要尽量开大点。

```c++
LL sieve(LL n)
{
	if (n <= threshold) return mu[n];
	LL ans;
	if ((ans = hash.query(n)) != -1) return ans;
	ans = 1;
	for (LL i = 2, t; i <= n; i = t + 1)
	{
		t = n / (n / i);
		ans -= (t - i + 1) * sieve(n / i);
	}
	hash.insert(n, ans);
	return ans;
}
```

##### 4. e.g. [51NOD 1244 欧拉函数之和](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1239)

&emsp;&emsp;给定一组询问 $n$，试求：
$$
\sum_{i = 1}^{n} \varphi(i)
$$

------

&emsp;&emsp;我们知道：
$$
\sum_{d \mid n} \varphi(d) = n
$$
&emsp;&emsp;即：
$$
\varphi * \mathrm{1} =\mathrm{id}
$$
&emsp;&emsp;代入杜教筛：
$$
S(n) = \sum_{i = 1}^{n} i - \sum_{i = 2}^{n} 1 \cdot S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
&emsp;&emsp;即：
$$
S(n) = \frac {n (n + 1)} {2} - \sum_{i = 2}^{n} S(\left\lfloor \frac {n} {i} \right\rfloor)
$$
&emsp;&emsp;用上面的方法即可。

```c++
LL sieve(LL n)
{
	if (n <= threshold) return phi[n];
	if (map.count(n)) return map[n];
	LL ans = (n & 1) ? (n % mod * (((n + 1) >> 1) % mod)) : ((n >> 1) % mod * ((n + 1) % mod));
	for (LL i = 2, t; i <= n; i = t + 1)
	{
		t = n / (n / i);
		ans = (ans - (t - i + 1) % mod * sieve(n / i)) % mod + mod;
	}
	return map[n] = ans % mod;
}
```





