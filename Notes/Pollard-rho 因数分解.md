[TOC]

# Pollard-rho 因数分解

##### 1. 问题引入

给定一个整数 $n (n \in \text{unsigned long long})$，分解它的所有质因数。

##### 2. 暴力方法

试除法，时间复杂度 $O(\sqrt {n})$，不足以解决此问题。

随机法，每次随机一个数，看看它是不是 $n$ 的因子。运气好到爆炸的话，一次解决；然而大部分人都是非洲人，一辈子都算不出来。

##### 3. 生日悖论

###### ①问题

给定 $n$ 个数 $1, 2, 3, 4, \cdots, n$，在里面随机选 $k$ **次**，问选到的数中出现重复的概率？

######②解法

$$
P(A) = 1 - \frac {n} {n} · \frac {n - 1} {n} · \frac {n - 2} {n} · \,... · \frac {n - k + 1} {n}
$$

###### ③扩展

从 [1, 1000] 中，随机取一个数，取到 42 的概率将会是 $\frac {1} {1000}$。

从 [1, 1000] 中，随机取两个数 $i, j$，$|i - j| = 42  \pod {i \ne j}$ 的概率约为 $\frac {1} {500}$。

从 [1, 1000] 中，取 $k$ 个数 $x_1, x_2, x_3, \cdots , x_k$，取得的 $k$ 个数中满足 $|x_i - x_j| = 42$ 的概率随 $k$ 的增大而增大。当 $k$ 为 $100$ 时，概率已经是 0.9999 了。

**如果有 $n$ 个数，那么每 $k = \sqrt {n}$ 个数中有 50% 的可能性产生冲突。**

##### 4. 改进后的随机法

我们先假设 $n$ 可以表示成 $p × q$。

###### ①问题 1

显然，如果我们检测随机出来的数 $r$ 是否为 $n$ 的因子的话，概率太小了：仅当 $r$ 等于 $p$ 或 $q$ 时才能完成我们的任务。一个聪明点的办法是：我们不要求 $r = p$ 或 $r = q$，而是要求 $\gcd(r, p) > 1$ 或 $\gcd(r, q) >1$ 即可，这样我们也找到了一个因子。所以现在我们有 $p + q - 2$ 个数（$p, 2p, 3p, \cdots, (q - 1)p, q, 2q, 3q, \cdots, (p - 1)q$）。

我们现在的任务是：让随机数生成器碰撞到这 $p + q - 2$ 个数。

###### ②问题 2

然而，$\frac {2} {n - 2}$ 即使改进到 $\frac {p + q - 2} {n - 2}$ 也还是太小。我们考虑**用生日悖论来解决这一问题。**

我们考虑在 $k$ 个数中选择 $2$ 个数，看看是否存在两个数 $x_i, x_j$ 使得它们的差与 $n$ 的最大公约数不为 $1$。

我们不一次性生成所有的数，**而是用一个函数不断生成两个数，结合 Floyd 判圈算法产生循环的问题。**

![Pollard-rho 1](pic\Pollard-rho 1.png)

我们让 $a$ 一次走 $1$ 步，$b$ 一次走 $2$ 步。如果有环，那么 $b$ 一定会在某一时刻与 $a$ 走在一起，这时，我们就知道重复了。

**这里用这么一个函数：**
$$
f(x) = (x^2 + a) \bmod n
$$
其中的 $a$ 可以自己指定，也可以随机生成。如果产生了循环，我们换一个 $a$ 就好了。

##### 5. 总结

Pollard-rho 算法实际上是一个结合了生日悖论和 Floyd 判圈算法的随机算法。

##### 6. 时间复杂度

Pollard-rho 算法能在玄学时间复杂度内找到 $n$ 的一个小因子 $p$，但是如果 $n$ 本身是一个质数，Pollard-rho 就不知所措了。**所以要先用 Miller-Rabin 算法检验待分解数是否为素数。**

可以证明分解一次的期望时间复杂度为 $O(n^{\frac {1} {4}})$。

##### 7. 参考代码

```c++
INT seed = 1;
inline ULL f(ULL x, ULL mod)
{
	return (x * x + seed) % mod;
}
ULL gcd(ULL a, ULL b)
{
	if(!b) return a;
	return gcd(b, a % b);
}
INT Pollard_rho(INT n) // 分解得到其中的一个因数
{
	if(Miller_Rabin(n)) return n;
	INT x = f(1, n); // 必须有符号
	INT y = f(x, n);

	INT t;
	while((t = gcd(std::abs(x - y), n)) == 1)
	{
		x = f(x, n);
		y = f(f(y, n), n);
		if(x == y)
		{
			seed = rand() + 1;
			x = f(1, n);
			y = f(x, n);
		}
	}
	return t;
}
```

##### 8. 注意事项

建议特判偶数，写完后检查下是否会进入死循环。在 Linux 下可以用 `factor` 程序检查是否分解正确。