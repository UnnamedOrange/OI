[TOC]

# 莫队算法

#### 一般的莫队算法

##### 1. 适用条件

&emsp;&emsp;在知道了 $\mathrm{ans}_{l, r}$ 的情况下，如果我们能够在 $O(1)$（或更高但可接受的时间复杂度）内计算出 $\mathrm{ans}_{l - 1, r}$，$\mathrm{ans}_{l + 1, r}$，$\mathrm{ans}_{l, r - 1}$，$\mathrm{ans}_{l, r + 1}$，那么就能使用莫队算法。

##### 2. 概念

&emsp;&emsp;莫队算法是一种**离线算法**。其原理是改变询问的操作顺序，在满足适用条件的情况下直接暴力扩张或收缩区间，就能在一个可行的时间复杂度内解决问题。

##### 3. 方法

&emsp;&emsp;将所有询问以**左端点所在块**为第一关键字，**右端点**为第二关键字进行排序。

&emsp;&emsp;设区间扩张或收缩一个单位的时间复杂度为 $O(1)$，则时间复杂度为 $O(\max(n, q) \sqrt {n})$。[^块大小]

[^块大小]: 在接下来说明块大小之前，我们先假设块大小为 $\sqrt {n}$。 

#####  4. 时间复杂度分析

&emsp;&emsp;当左端点所在块确定时，右端点单调，所以左端点在同一块内时移动右端点的时间复杂度为 $O(n)$，总共有 $O(\sqrt {n})$ 块，所以向右移动右端点的总时间复杂度为 $O(n \sqrt {n})$。

&emsp;&emsp;当左端点所在块变动时，移动右端点的时间复杂度为 $O(n)$，总共有 $O(\sqrt {n})$ 块，所以向左移动右端点的总时间复杂度为 $O(n \sqrt {n})$。

&emsp;&emsp;当左端点所在块确定时，移动一次左端点的时间复杂度为 $O(\sqrt {n})$ ，总共会有 $q$ 次移动，所以块内移动左端点的总时间复杂度为 $O(q \sqrt {n})$。

&emsp;&emsp;当左端点所在块变动时，相当于从左往右移动左端点，所以块间移动左端点的总时间复杂度为 $O(n)$。

&emsp;&emsp;所以整体的时间复杂度为 $O(max(n, q) \sqrt {n})$。

##### 5. 块大小

&emsp;&emsp;很明显，上面的时间复杂度不是很好，因为我们要取一个 $max$，也就是说时间复杂度可能是不正确的。

&emsp;&emsp;正确的块大小是：$\frac {n} {\sqrt {q}}$，则有 $\sqrt {q}$ 块。

&emsp;&emsp;在块大小为它的情况下，移动右端点的时间复杂度为 $O(n \sqrt {q})$；块内移动左端点的时间复杂度为 $O(n \sqrt {q})$；块间移动左端点的时间复杂度为 $O(n)$。

&emsp;&emsp;所以莫队算法的正确时间复杂度为 $O(n \sqrt {q})$。

&emsp;&emsp;在一般情况下，莫队算法能过通过数据规模为 $10^5$ 的题。

##### 6. 技巧

&emsp;&emsp;排序时，若两个询问在相同块，不要直接 $r$ 升序排序，而要这么做：若 $l$ 为偶数（$l$ 从 $0$ 开始），则 $r$ 为升序；若 $l$ 为奇数，则 $r$ 为降序。用这种方法被称为**奇偶排序**，能大幅降低程序的运行时间。原理很明显。

&emsp;&emsp;注意区间扩张和收缩处理时的区别。扩张时，先更改端点位置，再更新答案；收缩时，先更新答案，再更改端点位置。

&emsp;&emsp;可以将扩张和收缩写成一个函数。

##### 7. 参考代码

```c++
std::sort(idx + 1, idx + 1 + q,
	[](const INT& a, const INT& b)
{
	const Query& x = querys[a];
	const Query& y = querys[b];
	if (inBlocks[x.l] != inBlocks[y.l])
		return inBlocks[x.l] < inBlocks[y.l];
	else
		return inBlocks[x.l] & 1 ? x.r > y.r : x.r < y.r;
});
```

```c++
INT cntL = 1;
INT cntR = 1;
//手写边界的答案
for (int i = 1; i <= q; i++)
{
	Query& query = querys[idx[i]];
	INT l = query.l;
	INT r = query.r;
	INT& ans = query.ans;

	while (cntL > l)
	{
		cntL--;
		in(cntL);
	}
	while (cntR < r)
	{
		cntR++;
		in(cntR);
	}
	while (cntL < l)
	{
		out(cntL);
		cntL++;
	}
	while (cntR > r)
	{
		out(cntR);
		cntR--;
	}
	ans = sum;
}
```
##### e.g. [JZOJ 3568 小纪的作业题](https://jzoj.net/senior/#main/show/3568)

###### 题目大意

&emsp;&emsp;给定一个正整数序列 $a_{1 \sim n}$。给定 $q$ 个询问，每次询问给定两个正整数 $l$ 和 $r$（$l \le r$）。设里面的数 $x$ 的出现次数为 $f(x)$，求不同的 $x$ 的：
$$
\sum x^{f(x)}
$$
特别地，若一个数没有出现过，则不计入以上和式。答案对一个大质数取模。

###### 思路

&emsp;&emsp;使用莫队算法。我们可以在 $O(\log n)$ 的时间复杂度内更新上式，因此算法的时间复杂度为 $O(n^{\frac {3} {2}} \log n)$。

&emsp;&emsp;我们可以做得更好。预处理逆元后，每次只需要 $O(1)$ 的时间复杂度就能更新上式。因此算法的时间复杂度为 $O(n^{\frac {3} {2}})$。

#### 待修改的莫队算法

&emsp;&emsp;以上为传统的莫队算法，显然只适合处理不带修改操作的问题。如果问题带修改操作了呢？我们直接来看一道例题。

##### e.g. [Luogu 1903 数颜色](https://www.luogu.org/problemnew/show/P1903)

###### 题目大意

&emsp;&emsp;给定一个整数序列 $a_{1 \sim n}$，要求完成两种操作：询问 $a_l \sim a_r$ 中有多少个不同的数；将 $a_p$ 修改成 $v$。不要求在线。

###### 解决方法

&emsp;&emsp;这道题可以使用树套树实现在线操作，但是~~我不会~~不在讨论范围内。我们将介绍如何使用莫队算法解决这个问题。

##### 1. 三个指针 

&emsp;&emsp;对于不带修改的莫队，我们有两个指针：左端点 $l$ 和右端点 $r$。现在加上了修改，我们自然会想到增加第三个指针：时间。时间的含义是**按顺序已经进行了的操作次数**。

&emsp;&emsp;当然，修改操作往往也是能够在 $O(1)$ 内进行的。不过，如果我们仅仅按照左右端点像以前那样排序，时间跨度可能会很大，这导致我们的时间复杂度退化至 $O(n^2)$。有没有什么好办法呢？

&emsp;&emsp;办法当然是让时间也成为一个排序要素，但是排序的方法并不显然，这里直接给出排序方法：**当左端点在不同块时，按左端点排序；否则，若右端点在不同块，按右端点排序；否则按时间排序。**

&emsp;&emsp;前面我们仅仅介绍并验证了一般的莫队算法的时间复杂度，并没有给出如何计算块大小才能让时间复杂度最优，这里我们着重探究下**待修莫队**的最优块大小。

##### 2. 块大小

&emsp;&emsp;设块大小为 $s$，则有 $\frac {n} {s}$ 块。

1.  若下一次询问与当前询问的 $l$ 所在的块不同，那么每次需要移动 $O(s)$ 次左端点。显然移动左端点的时间复杂度为 $O(qs)$。
2.  因左端点所在块改变导致右端点发生变化的时间复杂度显然为 $O(n \frac {n} {s})$。当左端点所在块确定时，右端点每次最多移动 $O(s)$，因此移动右端点的总时间复杂度显然为 $O(n \frac {n} {s} + qs)$。
3.  考虑 $l$ 和 $r$ 处于同一块的情况，设它们所在块为 $b_l$ 和 $b_r$。对于 $b_l$ 和 $b_r$ 分别相同的询问，显然它们的时间是有序的。在这之间改变时间的时间复杂度为 $O(n)$，因此我们考虑有多少个不同的二元组 $(b_l, b_r)$，显然为 $O(\left( \frac {n} {s} \right)^2)$。因此改变 $t$ 的时间复杂度为 $O(\left( \frac {n} {s} \right)^2 n)$。

&emsp;&emsp;因此，算法的整体时间复杂度为 $O(qs + \frac {n^2} {s} +  \frac {n^3} {s^2})$。

&emsp;&emsp;TODO：老祖宗告诉我们，在 $n$ 与 $q$ 同阶的情况下，$s = n^{\frac {2} {3}}$ 时是最优的，此时的时间复杂度为 $O(n^{\frac {5} {3}})$。

&emsp;&emsp;Remark：大神说，先乱搞，然后造数据不断调参。

##### 3. 参考代码

```c++
int sqrtN;
int N;
int inBlock[maxn];
void initBlocks()
{
	sqrtN = std::pow(n, (double)2 / 3);
	N = (n - 1) / sqrtN + 1;
	for (int i = 1; i <= n; i++)
		inBlock[i] = (i - 1) / sqrtN;
}
int idx[maxn];
bool comp(const int& a, const int& b)
{
	const Query& x = querys[a];
	const Query& y = querys[b];
	if (inBlock[x.l] != inBlock[y.l]) return x.l < y.l;
	if (inBlock[x.r] != inBlock[y.r]) return (inBlock[x.l] & 1) ? x.r > y.r : x.r < y.r;
	return x.t < y.t;
}
```

##### 4. 奇偶排序

&emsp;&emsp;由于在 $t$ 前面有两个参数，无法构成全序关系，因此只能对 $r$ 进行奇偶排序，效果还是比较好的。

#### 一些例题

##### e.g. [Luogu 4137 Rmq Problem / mex](https://www.luogu.org/problemnew/show/P4137)

###### 题目大意

&emsp;&emsp;给定一个长度为 $n \pod {n \le 2 \times 10^5}$ 的序列和 $m \pod {m \le 2 \times 10^5}$ 次询问，每个询问给定一个区间，求区间的 $\mathrm{mex}$ 函数。

###### 解决方法

&emsp;&emsp;这道题可以使用可持久化线段树在 $O(n \log n)$ 的时间复杂度内**在线**解决，**只需要记录某个数最后一次出现的位置即可**，离线后还可以使用普通线段树解决。但是这里我们重点讲莫队算法。

&emsp;&emsp;这道题相当于是要维护一个出现次数，显然可以使用莫队算法来做。算一下时间复杂度，发现 $2 \times 10^5$ 应该能卡过，所以我们就尝试一下，在修改出现次数后“暴力”计算 $\mathrm{mex}$。另外，显然的是大于 $n$ 的数在计算 $\mathrm{mex}$ 时没有任何作用，所以我们把它们改成 $n + 1$ 就好了。

###### 参考代码

&emsp;&emsp;我们写个一般的莫队算法，然后水过啦！

```c++
int times[maxn];
int cntL, cntR, ans;
void init()
{
	cntL = cntR = 1;
	times[a[1]]++;
	ans = times[0] ? 1 : 0;
}
void expand(int pos)
{
	times[a[pos]]++;
	register int i = ans;
	while (times[i]) i++;
	ans = i;
}
void shrink(int pos)
{
	if (!(--times[a[pos]]))
		ans = std::min(ans, a[pos]);
}
```

###### 时间复杂度

&emsp;&emsp;虽然修改数的出现次数的时间复杂度是保证在了 $O(n \sqrt q)$ 的（不要忘了莫队算法的正确块大小是 $\frac {n} {\sqrt q}$，虽然没什么用），但是计算 $\mathrm{mex}$ 的时间复杂度如何保证呢？

&emsp;&emsp;很遗憾，没法保证。试想这样一个序列：

|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  2   |  3   |  4   |  5   |  6   | ...  |

&emsp;&emsp;依次递增，令询问的左端点 $1 2$ 交替，右端点依次递增。当左端点收缩到 $2$ 时，$\mathrm{mex}$ 将会变成 $1$；当左端点重新变成 $1$ 后，$\mathrm{mex}$ 需要重新扩张到右端点对应的值。显然这样时间复杂度是没法保证的。

&emsp;&emsp;因此我们有两种解决方法：

###### 代替方法 1

&emsp;&emsp;加一个分块。

&emsp;&emsp;我们能在 $O(1)$ 的时间复杂度维护分块的内容。**然后我们再用 $O(\sqrt n)$ 的时间复杂度来查询。**相信这两句话的描述足以启发你写出这道题 $O(n \sqrt n)$ 的正解。

###### 代替方法 2

&emsp;&emsp;使用我一开始说的（可持久化）线段树，时间复杂度 $O(n \log n)$。这里就不讲怎么做了。

###### 参考代码

```c++
int buf[maxN];
int times[maxn];
int solve()
{
	int ret = 0;
	int b = code(ret);
	while (buf[b] == bsize[b])
	{
		ret += NB;
		b = code(ret);
	}
	while (times[ret]) ret++;
	return ret;
}
int cntL, cntR, ans;
void init()
{
	cntL = cntR = 1;
	++times[a[1]];
	buf[code(a[1])]++;
}
void expand(int pos)
{
	if (!(times[a[pos]]++))
		buf[code(a[pos])]++;
}
void shrink(int pos)
{
	if (!(--times[a[pos]]))
		buf[code(a[pos])]--;
}
```