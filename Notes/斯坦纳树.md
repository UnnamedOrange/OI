[TOC]

# 斯坦纳树

##### 1. 概念

&emsp;&emsp;在图 $G = (V, E)$ 中，边有边权。设点集 $S \subset V$。我们称使 $S$ 中的点连通的树为斯坦纳树（ Steiner Tree）；称**使 $S$ 中的点连通且边权和最小的树为最小斯坦纳树**。

##### 2. 暴力求解

&emsp;&emsp;感性地理解，斯坦纳树中肯定可以包含 $S$ 以外的点。所以我们可以枚举点集 $S_0$ 使得 $S \subseteq S_0 \subset V$，然后取点集的最小生成树的最小值即可。

&emsp;&emsp;时间复杂度 $O(3^n m)$，无法承受。

##### 3. 动态规划求解

&emsp;&emsp;一般来说，最小斯坦纳树问题中的 $|S|$ 是很小的，可以考虑使用状态压缩 DP 来解决。至于为什么要这么做……就当是老祖宗告诉我们的吧。 

&emsp;&emsp;设 $f_{i, S_0}$ 表示以 $i$ 为根，对 $S$ 而言**至少**已经有 $S_0$ 在这棵树中时的最小总权值。

&emsp;&emsp;**为了统一与方便，接下来我们用 $U$ 代替上文中要满足条件的 $S$。**

&emsp;&emsp;不难得到边界条件：
$$
f_{i, \{ i \} } = 0 \pod{i \in U}
$$
&emsp;&emsp;答案也比较明显：
$$
\min \{ f_{i, U} \} \pod{i \in \{ 1, 2, ... , n \}}
$$
&emsp;&emsp;又有两个状态转移方程：
$$
f_{i, S} = \min \{ f_{i, S_0} + f_{i, S_1} \} \pod{S_0 \cup S_1 = S, S_0 \cap S_1 = \emptyset}
\\
f_{i, S} = \min \{ f_{j, S} + e_{i, j} \}
$$

&emsp;&emsp;蒟蒻看到这两个方程，肯定会想：

&emsp;&emsp;（1）为什么是这么两个方程？

&emsp;&emsp;（2）第一个方程很有可能会使某些边算重，为什么是对的？

&emsp;&emsp;（3）怎么进行这两个方程的转移？

&emsp;&emsp;接下来就让我们来解决这些坑爹的问题……

##### 4. 问题解决

###### ①非法解不会最优

&emsp;&emsp;第一个方程最让人疑惑的地方，就是明明会算重，为什么是正确的。其实答案也很简单，就是用那个套路思想：**非法解不会最优。**要是你对这个思想不是很熟悉，可以去试试 NOIP 2017 Day2 T2，它的状态压缩 DP 做法就要用到这个思想。（网上大部分的题解应该都是这个方法）

&emsp;&emsp;以下摘选自 《迭代求解的利器——SPFA 算法的优化与应用 》：

>&emsp;&emsp;注意到（上面的合并）可能会出现两个方格重叠，虽然这不合法，但实际上，由于必然存在另外一组相同的不重叠的解，所以它不可能成为最优解。而算法又保证了每种最优情况都考虑在内，所以不必担心其合法性。 

&emsp;&emsp;这样我们就解决了问题（2）。

###### ②怎么进行转移

&emsp;&emsp;**做动态规划时，想要知道怎么转移，得首先假设我们需要的数据是无后效性的、已经算好了的。**

&emsp;&emsp;在这种假设下，我们来考虑第一个方程。由于已经解决了它的正确性问题，所以单独看第一个方程是不存在任何问题的。因为它只存在一个枚举非空真子集，是没有后效性的。**所以我们第一步直接进行第一个方程的转移。**

&emsp;&emsp;第二个方程就稍微有点棘手了。它的含义大概就是通过一条连接了当前根的边将状态转移到另外一个根上去。这时，我们必须要明确一下我们定义的状态的含义。注意，$f_{i, S}$ 表示以 $i$ 为根，**至少** $S$ 是已经在这棵树中时的最小总权值，所以我们不用担心把根换成了一个 $U$ 中的结点导致 $S$ 发生改变的问题，因为这是符合定义的。

&emsp;&emsp;但是第二个问题的转移顺序就很不明显了：我们该怎么枚举 $i$ 和 $j$ 呢？观察发现，**第二个方程的形式跟最短路是类似的，所以我们使用 SPFA 算法进行转移。**

&emsp;&emsp;那在何时进行 SPFA 的转移呢？在对集合 $S$ 处理完第一个方程后，我们肯定会有一些有效[^有效]的 $f_{i, S}$ 是通过第一个方程转移过来的。**根据假设和前面对第一个方程的总结，由第一个方程推算过来的状态是没有后效性的。**所以我们直接使用这些有效状态作为起点，做一次多个起点的 SPFA 就好了。

[^有效]: 无效状态指 $f_{i, S} = \inf$ 的状态，即还没有从任何地方转移过来且不是边界的状态。有效状态的含义与之相反。

&emsp;&emsp;不难发现，对于相同的 $S$，有些状态 $f_{i, S}$ 应该是有效的，但通过第一个方程却无法让它变成有效的。这时，我们就要用第二个方程来转移了。因此，第二个方程的转移应该在第一个方程处理完一个特定的 $S$ 后进行。

&emsp;&emsp;就这样，问题（3）也解决了。

###### ③总结

&emsp;&emsp;回过头来看问题（1），这时我们就能说出两个方程的作用了：第一个方程使集合从小到大；第二个方程弥补了第一个方程根没有办法转移的问题。在处理完第一个方程后紧接着就处理第二个方程，就能消除第一个方程的后效性，使得我们对动态规划点的假设成立。[^动态规划]

[^动态规划]: 即一开始假设方程没有后效性且已经是正确答案。 

###### ④时间复杂度分析

&emsp;&emsp;第一个方程的时间复杂度为 $O(3^{|S|} n)$，第二个方程的时间复杂度为 $O(k|E|)$，即 SPFA 一般认为的时间复杂度（动态规划题目不会去卡 SPFA 的）。由于第二个方程要做 $2^{|S|}$ 次，因此整个算法的时间复杂度为 $O(3^{|S|} n + 2^{|S|} k|E|)$，注意一下数据范围。

##### 5. e.g. [BZOJ 2595 游览计划](http://www.lydsy.com/JudgeOnline/problem.php?id=2595)

###### ①与单纯的斯坦纳树进行比较

&emsp;&emsp;这个题，可以算作一道斯坦纳树的裸题，但是对于毫无基础的蒟蒻来说，简直是太痛苦了，所以有必要仔细剖析下。

&emsp;&emsp;不难发现一个区别：这是一个网格图，且**权值不在边上，而在点上。**所以我们的方程就有一点区别了：
$$
f_{i, S} = \min \{ f_{i, S_0} + f_{i, S_1} - \mathrm{weight}_{i} \} \pod{S_0 \cup S_1 = S, S_0 \cap S_1 = \emptyset}
\\
f_{i, S} = \min \{ f_{j, S} + \mathrm{weight}_{i} \}
$$
&emsp;&emsp;由于这是一个二维的网格图，所以我们方程中的 $i$ 是个逻辑上的根，真正要表示一个结点需要用一个二维的坐标，这里为了方便就不写成 $f_{i, j, S}$ 了。在这道题中，**即使写成 $f_{i, j, S}$，其本质也是一样的，代表一个根结点编号和一个集合，所以没有必要在简析中写。**

&emsp;&emsp;第二个方程的变形不难理解。第一个为什么要减去一个 $\mathrm{\mathrm{weight}}_i$ 呢？考虑第一个方程时，**需要假设这次转移是由合法状态[^合法状态]转移过来的。**这样就不难理解了：两个状态的值**一定**都包含了 $\mathrm{\mathrm{weight}}_i$，所以必须减去一个，否则就真的算重了。

[^合法状态]: 合法状态与前文的非法解相对。 

&emsp;&emsp;另一个区别是，题目要求输出一种方案。**动态规划输出方案的方法是记录一个状态是从哪个状态转移过来的（设为 $\mathrm{pre}$）。**这个题也是这个套路。作为一道例题，接下来会给出详细的代码。

###### ②斯坦纳树的实现

&emsp;&emsp;这里先给出代码[^代码]，再作出进一步解释。

[^代码]: 代码中最重要的是后面的那个循环，前面的只是初始化。 

```c++
void SteinerTree()
{
	memset(f, 0x3f, sizeof(f));
	memset(&INF, 0x3f, sizeof(INF));
	Point s[maxn];
	k = 0;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			if (!rect[i][j])
			{
				s[k].first = i;
				s[k].second = j;
				k++;
			}

	U = 1 << k;
	for (int i = 0; i < k; i++)
		f[s[i].first][s[i].second][1 << i] = 0;

	for (int S = 0; S < U; S++)
	{
		for (int x = 0; x < n; x++)
		{
			for (int y = 0; y < m; y++)
			{
				for (int S0 = (S - 1) & S; S0; S0 = (S0 - 1) & S) //枚举子集
				{
					int S1 = S ^ S0;
					if (f[x][y][S0] + f[x][y][S1] - rect[x][y] < f[x][y][S])
					{
						f[x][y][S] = f[x][y][S0] + f[x][y][S1] - rect[x][y];
						pre[x][y][S][0] = x;
						pre[x][y][S][1] = y;
						pre[x][y][S][2] = S0;
					}
				}
			}
		}
		SPFA(S);
	}
}
```

&emsp;&emsp;s 代表题目中的景点，rect 为输入的数据，其余变量的含义显然。

&emsp;&emsp;由于我们要求最小值，那么无效状态肯定是要设置为极大值的。由于会有加法，因此要把无效状态设为一个不会溢出的值。

&emsp;&emsp;第二步是求边界状态。

&emsp;&emsp;然后是主要的过程。最外层枚举集合，中间枚举根结点，然后枚举子集（枚举子集的方法见代码，《算法竞赛入门经典》中有讲解）。

&emsp;&emsp;在处理完一个集合后，用 SPFA 更新其它当前集合其它根结点的状态。

------

```c++
void SPFA(INT S)
{
	bool inQ[maxn][maxn] = { false };
	std::queue<Point> q;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (f[i][j][S] < INF) //如果这个状态有效
			{
				q.push(Point(i, j)); //多个起点的最短路
				inQ[i][j] = true;
			}
		}
	}
	while (!q.empty()) //一般的 SPFA
	{
		Point from = q.front();
		q.pop();
		inQ[from.first][from.second] = false;
		for (int i = 0; i < 4; i++)
		{
			INT newx = from.first + vecx[i];
			INT newy = from.second + vecy[i];
			if (!(newx >= 0 && newx < n && newy >= 0 && newy < m))
				continue;
			if (f[newx][newy][S] > f[from.first][from.second][S] + rect[newx][newy])
			{
				f[newx][newy][S] = f[from.first][from.second][S] + rect[newx][newy];
				pre[newx][newy][S][0] = from.first;
				pre[newx][newy][S][1] = from.second;
				pre[newx][newy][S][2] = S;
				if (!inQ[newx][newy])
				{
					q.push(std::make_pair(newx, newy));
					inQ[newx][newy] = true;
				}
			}
		}
	}
}
```

&emsp;&emsp;除了多个起点，跟一般的 SPFA 没有太大差别。**注意，只在当前的 $S$ 更新！**

&emsp;&emsp;另外，**在第一个方程和第二个方程转移时都要保存 $pre$。**

------

```c++
INT vis[maxn][maxn];
void Track(INT x, INT y, INT S) //传入的是使答案最小的 x 和 y
{
	if (!pre[x][y][S][2])
		return;
	vis[x][y] = true; //选了这个的（根据状态的定义）
	Track(pre[x][y][S][0], pre[x][y][S][1], pre[x][y][S][2]);
	if (pre[x][y][S][0] == x && pre[x][y][S][1] == y) //如果是从第一个方程转移而来的
		Track(pre[x][y][S][0], pre[x][y][S][1], S ^ pre[x][y][S][2]);
}
```

&emsp;&emsp;不难发现，**只有第二个方程会让我们选择一个新的点进入集合。**而第一个方程的 $pre$ 是拿来帮助我们转移到第二个方程的 $pre$ 的。

&emsp;&emsp;**当且仅当边界条件不存在上一个状态的集合，**所以当 `!pre[x][y][S][2]`  时，退出就可以了。

&emsp;&emsp;由于题目本身的性质，边界条件的点无所谓选不选，因此不用管。

##### 6. e.g. [HDU 3311 Dig The Wells](http://acm.hdu.edu.cn/showproblem.php?pid=3311)

###### ①题目大意

&emsp;&emsp;有 $n$ 个和尚的寺庙和 $m$ 个其它地方，每个地方都可以花钱挖井；有 $p$ 条需要花钱修的路。用 $1$ 到 $n$ 代表寺庙，$n + 1$ 到 $n + m$ 代表其它地方。求出让所有寺庙所在连通块都有至少一口井的最小花费。

&emsp;&emsp;Tip：这道题的做法很妙，看下面内容前请先思考。

###### ②点权的处理方法

&emsp;&emsp;考虑**超级点**。对这道题而言，超级点简直是法宝！

&emsp;&emsp;加一个超级点 $0$，将 $0$ 与其它所有点连边，边权为在点上建井的花费。然后你就发现，题目变成了一个完全的裸的要求 $0$ 到 $n$ 的点连通的斯坦纳树！

&emsp;&emsp;然后就没有了。

###### ③代码总结

&emsp;&emsp;好久没有写代码了，一点感觉都没有……

&emsp;&emsp;SPFA 的队列需要取模……

&emsp;&emsp;记住总数是 $n + m$ 而不是 $n$。

&emsp;&emsp;记住边要开 $(n + m) × 2 × 2$。 

##### 7. e.g. [JZOJ 4079 管道连接](https://jzoj.net/senior/#main/show/4079)

###### ①思路

&emsp;&emsp;先明确一点，如果所有情报站的频道相同，那么这道题就是一个裸的斯坦纳树。

&emsp;&emsp;可以用斯坦纳树求出所有情报站作为全集的答案，这样就可以得到某个频道的情报站连通的答案了。如何求某个集合的答案呢？$F_{S} = \min \{ f_{i, S} \}$。

&emsp;&emsp;对于两个频道的情报站，它们首先可以是完全连通的（$F_{S_1 \cup S_2}$），也可以是分成两块的（$F_{S_1} + F_{S_2}$）。同样，如果不存在分成两块的方案，那就一定有重边，$F_{S_1} + F_{S_2}$ 就一定比 $F_{S_1 \cup S_2}$ 大。**这里也用了非法解不会最优的思想。**

###### ②实现

&emsp;&emsp;首先做斯坦纳树。

&emsp;&emsp;然后设**频道**集合的全集为 $U​$，设使频道集合 $S​$ 的各频道建立了通道连接的最小代价为 $g_{S}​$。我们实际上求的就是 $g_U​$。

&emsp;&emsp;考虑用动态规划。
$$
g_S = \min(\min \{ 
g_{S_0} + g_{S_1} (S_0 + S_1 = S)
\},
F_{S}
)
$$
&emsp;&emsp;注意这里是频道集合，但是我们枚举重要情报站集合要方便些，所以可以先预处理某个重要情报站集合是不是能够代表一个完整的频道集合（即不存在某个频道的情报站出现但没有全部出现）。

###### ③最后部分的参考代码

```c++
for (int S = 0; S < U; S++)
for (int i = 1; i <= n; i++)
	g[S] = std::min(g[S], f[i][S]);

init();
for (int S = 0; S < U; S++)
{
	if (!isComplete[S]) continue;
	for (int S0 = (S - 1) & S; S0; S0 = (S0 - 1) & S)
	{
		int S1 = S ^ S0;
		if (!isComplete[S0]) continue;
		g[S] = std::min(g[S], g[S0] + g[S1]);
	}
}
printOut(g[U - 1]);
```

###### ④时间复杂度

&emsp;&emsp;$O(3^{p}n + 2^{p}k|E| + 2^{p}p + 3^{p})$