#####1. [JZOJ 4233](https://jzoj.net/senior/#main/show/4233)

- [x] 使用调整法求树的重心

      主要用到了定理：**树的重心每棵子树的大小一定小于等于 n / 2。**因此我们假设一个点为重心，然后判断是否有子树（包括自身这棵子树的其余部分）的大小**大于** n / 2，如果有，我们就假设那个新的点为重心。继续走，直到没有子树大小大于 n / 2，这时当前点就为重心。

      实际实现中，没有必要检查是否需要往上走（即检查自身对应子树的其余部分），因为我们肯定是从上而下走来的，所以肯定不会走回头路。

      ```c++
      INT adjust(INT root)
      {
      	INT maxIdx = 0;
      	for (int i = G.head[root]; i; i = G.edges[i].next)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to == parent[root])
      			continue;
      		if (size[to] > n / 2)
      		{
      			maxIdx = to;
      			break;
      		}
      	}
      	return maxIdx;
      }
      ```

      ```c++
      	INT center = 1;
      	while (INT t = adjust(center))
      		center = t;
      ```

      ​

      另一方面，这个做法对于求子树的重心就很有用（比如在点分治时），它只需要**从上往下走**（**因为起点为子树的根结点，所以不需要回头**）就可以了，而不需要一次额外的 DFS。


#####2. [JZOJ 1301](https://jzoj.net/senior/#main/show/1301)

- [x] 使用调整法求树的重心

      除了树的重心的求法，这道题还涉及两个重心的问题。首先，一棵树有两个重心的必要条件是这棵树的结点数为偶数；其次，它的充分条件是存在一条边，连接两棵大小相同的子树。因此，另一方面，**树的两个重心总是相邻的**。

      ```c++
      	INT center2 = 0;
      	if (!(n & 1))
      	{
      		for (int i = G.head[center]; i; i = G.edges[i].next)
      		{
      			const Edge& e = G.edges[i];
      			INT to = e.to;
      			if (to == parent[center])
      				continue;
      			if (size[to] == n / 2)
      			{
      				center2 = to;
      				break;
      			}
      		}
      		//center 是从上往下找过来的，所以不用找父结点
      		if (center2 && center > center2)
      			std::swap(center, center2);
      	}
      ```

      另外，我们的 center 是从根结点开始，肯定是从上往下调整的，所以 center2 一定不会是 center 的父结点。

##### 3. 树的直径知识点整理

定理 1：树的重心每棵子树的大小一定小于等于 n / 2。作用：判定一个点是否是重心。

定理 2：每棵子树的大小小于等于 n / 2 的结点为重心。作用：求重心。

定理 1 和定理 2 互为逆定理。

定理 3：设 f(x) = 树中所有点到 x 的距离和，则重心的 f 值最小（如果有两个重心，它们 f 值一样）。证明方法：在重心上反证，发现如果移动到相邻点，距离变大了。

定理 4：两棵树通过一条边相连成为一棵新树，新树重心一定在原来两棵树的重心的路径上。

