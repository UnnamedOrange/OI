#####1. [JZOJ 4233](https://jzoj.net/senior/#main/show/4233)

- [x] 使用调整法求树的重心

      主要用到了定理：**树的重心每棵子树的大小一定小于等于 n / 2。**因此我们假设一个点为重心，然后判断是否有子树（包括自身这棵子树的其余部分）的大小**大于** n / 2，如果有，我们就假设那个新的点为重心。继续走，直到没有子树大小大于 n / 2，这时当前点就为重心。

      实际实现中，没有必要检查是否需要往上走（即检查自身对应子树的其余部分），因为我们肯定是从上而下走来的，所以肯定不会走回头路。

      ```c++
      INT adjust(INT root)
      {
      	INT maxIdx = 0;
      	for (int i = G.head[root]; i; i = G.edges[i].next)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to == parent[root])
      			continue;
      		if (size[to] > n / 2)
      		{
      			maxIdx = to;
      			break;
      		}
      	}
      	return maxIdx;
      }
      ```

      ```c++
      	INT center = 1;
      	while (INT t = adjust(center))
      		center = t;
      ```

      ​

      另一方面，这个做法对于求子树的重心就很有用（比如在点分治时），它只需要**从上往下走**（**因为起点为子树的根结点，所以不需要回头**）就可以了，而不需要一次额外的 DFS。


#####2. [JZOJ 1301](https://jzoj.net/senior/#main/show/1301)

- [x] 使用调整法求树的重心

      除了树的重心的求法，这道题还涉及两个重心的问题。首先，一棵树有两个重心的必要条件是这棵树的结点数为偶数；其次，它的充分条件是存在一条边，连接两棵大小相同的子树。因此，另一方面，**树的两个重心总是相邻的**。

      ```c++
      	INT center2 = 0;
      	if (!(n & 1))
      	{
      		for (int i = G.head[center]; i; i = G.edges[i].next)
      		{
      			const Edge& e = G.edges[i];
      			INT to = e.to;
      			if (to == parent[center])
      				continue;
      			if (size[to] == n / 2)
      			{
      				center2 = to;
      				break;
      			}
      		}
      		//center 是从上往下找过来的，所以不用找父结点
      		if (center2 && center > center2)
      			std::swap(center, center2);
      	}
      ```

      另外，我们的 center 是从根结点开始，肯定是从上往下调整的，所以 center2 一定不会是 center 的父结点。

##### 3. 树的重心知识点整理

定理 1：树的重心每棵子树的大小一定小于等于 n / 2。作用：判定一个点是否是重心。

定理 2：每棵子树的大小小于等于 n / 2 的结点为重心。作用：求重心。

定理 1 和定理 2 互为逆定理。

定理 3：设 f(x) = 树中所有点到 x 的距离和，则重心的 f 值最小（如果有两个重心，它们 f 值一样）。证明方法：在重心上反证，发现如果移动到相邻点，距离变大了。

定理 4：两棵树通过一条边相连成为一棵新树，新树重心一定在原来两棵树的重心的路径上。

#####4. 树的直径知识点整理

定理 1：以树上任意一个点为起点的最长路径，终点一定是直径的一个端点。

定理 2：对于两条相交的直径，它们不相交部分一定对称。

定理 3：两棵树用一条边合并，新树直径两端一定是原本两棵树直径的四个端点中的两个。

定理 3 的扩展：在树上，对于两个不相交的结点集合，每个集合知道一个最远点对，则两个集合的并的最远点对一定是这两个集合的最远点对的四个端点中的两个。

虚树的定义：在一棵树上，给定一个集合 S，将包含 S 的最小连通块叫做 S 的虚树。定理 3 的扩展中的最远点对可以看作集合对应的虚树的直径。

#####5. [JZOJ 4727](https://jzoj.net/senior/#main/show/4727)

- [x] 使用动态规划求树的直径，使用两次深搜的方法将以 1 为根的答案转移至以 i 为根。

      1.求整棵树的直径

      ​	方法：处理出有根子树的最长链 `length[i][0]` 和次长链 `length[i][1]`，取 `length[i][0] + length[i][1]` 的最大值，设为 `d[i]`。

      ​	**注意：一定是取最大值，而不是根结点的最长链和次长链之和。**

      2.求整棵树排除一棵子树后的直径

      ​	方法：首先想办法**把有根树的 length 转化为 length2。为了防止转移时转移到被排除的子树，还要同时记录子链是从哪里转移来的（who2）。由于我们需要最长和次长，同时有可能（最多）有一个不能进行转移，因此我们保存前三大的 length。**这种通过旋根把有根树的答案转换为无根树的答案往往都需要用这样的方法。

      ​	接下来，考虑如何求直径。我们定义 `d2[i][0 / 1]` 为以 i 为整棵树的根，不经过 i 的直径中最长和次长的长度（因此该直径一定在 i 的一棵子树内）。肯定我们还需要保存 d2 是对应的哪棵子树，用 where 表示。

      ​	现在的问题是，如何求 d2 呢？首先，对于边界情况 i = 1，d2 就是取其子树的 d 的最大值。考虑其它子树，发现只有两种可能，一是取其子树的 d，二是把其父结点看作一棵子树，所以首先用父结点的 d2 更新子树的 d2，然后考虑经过父结点的直径，取不经过当前结点的两条最长链之和更新 d2 即可。由于更新 length2 和 d2 均是从上至下的，因此可以放在一个深搜中。

      ​	需要注意的是，在进行下次 DFS 前，首先得保证当前结点已完全更新，所以得遍历两次边，先更新 d2 后再进行下一次 DFS。

      ```c++
      INT length2[maxn][3];
      INT who2[maxn][3];
      INT d2[maxn][3];
      INT where[maxn][3];
      void DFS2(INT node)
      {
      	if (node != 1)
      	{
      		INT l = length2[parent[node]][0];
      		INT w = who2[parent[node]][0];
      		if (w == node)
      		{
      			l = length2[parent[node]][1];
      			w = who2[parent[node]][1];
      		}
      		l += pCost[node];
      		update3(l, w, node, length2, who2);

      		w = parent[node];
      		//d2 实际上只需要最大和次大，这里只是为了方便，定义成了保存前三大
      		if (where[w][0] != node)
      			update3(d2[w][0], where[w][0], node, d2, where);
      		if (where[w][1] != node)
      			update3(d2[w][1], where[w][1], node, d2, where);

      		if (who2[w][0] == node)
      			l = length2[w][1] + length2[w][2];
      		else if (who2[w][1] == node)
      			l = length2[w][0] + length2[w][2];
      		else
      			l = length2[w][0] + length2[w][1];
      		update3(l, w, node, d2, where);
      	}
      	wander(G, node)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to != parent[node])
      			update3(d[to], to, node, d2, where);
      	}
      	wander(G, node)
      	{
      		const Edge& e = G.edges[i];
      		INT to = e.to;
      		if (to != parent[node]) DFS2(to);
      	}
      }
      ```

      ```c++
          INT ans = 0;
          for (int i = 2; i <= n; i++)
          {
              INT temp = 0;
              INT p = parent[i];
              if (i == who2[p][0])
                  temp = length2[p][1] + length2[p][2];
              else if (i == who2[p][1])
                  temp = length2[p][0] + length2[p][2];
              else
                  temp = length2[p][0] + length2[p][1];

              if (i == where[p][0])
                  temp = std::max(temp, d2[p][1]);
              else if (i == where[p][1])
                  temp = std::max(temp, d2[p][0]);

              temp += d[i];
              ans = std::max(ans, temp);
          }
          printOut(ans);
      ```


#####6. [JZOJ 1016](https://jzoj.net/senior/#main/show/1016)

- [x] 使用 DFS 序维护**子树的和**，进行**单点修改**

      应该是道裸题，不多说了。

##### 7. JZOJ 4005

- [ ] 维护欧拉序

  ​（这道题没有数据，只是写了一个常数巨大的程序，应该还是错的）

  ​指针线段树 + 交换线段树子树。