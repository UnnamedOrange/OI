[TOC]

# 数论小记

>仅大步小步算法可读性较高，其余部分仅作参考……

#### 欧拉函数与欧拉定理

##### 1. 欧拉函数

​	对于正整数 $n$，定义 $\phi (n)$ 表示比 $n$ 小且与 $n$ 互质的数的个数。

##### 2. 欧拉定理

$$
\forall gcd(a, n) = 1, a^{\phi(n)} \equiv 1 \; (mod \; n)
$$

##### 3. 扩展欧拉定理

$$
a^b \equiv a^{b \; mod \; \phi(p)} \;\;\;\;\;\;\;\; (gcd(a, p) = 1) \; (mod \; p)
\\
a^b \equiv a^b \;\;\;\;\;\;\;\ (gcd(a, p) \ne 1, b < \phi(p)) \; (mod \; p)
\\
a^b \equiv a^{(b \; mod \; \phi(p)) \; + \; \phi(p)} \;\;\;\;\;\;\;\ (gcd(a, p) \ne 1, b \ge \phi(p)) \; (mod \; p)
$$

#### 二次同余式

##### 1. 定义

​	二次同余式是关于未知数的二次多项式的同余方程，形如：
$$
ax^2 + bx + c \equiv 0 \; (mod \; p)
$$
​	形如 $x^2 \equiv a \mod p$ 的二次同余式则称为最简二次同余式。

##### 2. 剩余类

###### ①定义	

​	所有与整数 $a$ 模 $p$ 同余的整数构成的集合叫做模 $p$ 的一个剩余类，记作 $[a]$。

###### ②二次剩余与二次非剩余

​	假设 $p$ 是素数，$a$ 是整数，==如果存在一个整数 $x$ 使得 $x^2 \equiv a \; (mod \; p)$，那么称 $a$ 在 $p$ 的剩余类中是二次剩余的。==

​	假设 $p$ 是素数，$a$ 是整数，==如果**不**存在一个整数 $x$ 使得 $x^2 \equiv a \; (mod \; p)$，那么称 $a$ 在 $p$ 的剩余类中是二次**非**剩余的。==

###### ③条件

​	$a$ 是模 $p$ 的二次剩余的充要条件是 $a^{\frac {p - 1} {2}} \equiv 1 \; (mod \; p)$。

​	$a$ 是模 $p$ 的二次剩余的充要条件是 $a^{\frac {p - 1} {2}} \equiv -1 \; (mod \; p)$。

###### ④二次互反律

​	设 $a$，$p$ 是两个非零整数，我们**定义** $(\dfrac {a} {p})$ 为：若 $a$ 是模 $p$ 的二次剩余，则记 

$(\dfrac {a} {p}) = 1$，否则记 $(\dfrac {a} {p}) = -1$。

​	二次互反律：设 $p$ 和 $q$ 为不同的奇素数，有：
$$
(\dfrac {q} {p})(\dfrac {p} {q}) = (-1) ^ {\frac {p - 1}{2} \frac {q - 1}{2}}
$$

#### 阶

##### 1. 定义

​	对于两个互质的整数 $a$，$p$，定义 ==$a$ 对模 $p$ 的阶==为最小的满足 $a^d \equiv 1 \; (mod \; p)$ 的正整数 $d$，记作 $\delta_p(a)$。

​	显然 $\delta_p(a) | \phi(p)$。

##### 2. 定理和推论

$$
\delta_p(a^k) = \frac {\delta_p(a)} {gcd(\delta_p(a), k)}
$$

##### 3. 求阶

​	暴力枚举 $\phi(p)$ 的约数就可以了。

#### 原根

##### 1. 定义

​	==满足 $\delta_p(a) = \phi(p)$ 的 $a$ 称为 $a$ 称为 $p$ 的原根。==

##### 2. 存在的条件

​	模 m 有原根的充要条件是 m 为 2，4，p，2p，$p^n$，其中 $p$ 是奇素数，$n$ 是任意正整数。

##### 3. 性质

​	（1）如果模 $p$ 有原根，那么它有 $\phi(\phi(p))$ 个原根。

​	（2）设 $p$ 是奇质数，$g$ 是 $p$ 的原根，则 $g$ **或者** $g + p$ 是 $p^2$ 的一个原根。

​	（3）设 $p$ 是奇质数，$k$ 是任意自然数，$g$ 是 $p^k$ 的一个原根，则 $g$ 与 $g + p^k$ 中的奇数是 $2p^k$ 的一个原根。

##### 4. 求原根

​	对 $\phi(n)$ 质因子分解，得 $\phi(n) = p_1^{a_1} p_2^{a_2} ... p_k^{a_k}$。==若恒有  $g^{\frac {\phi(n)} {p_i}} \ne 1 \; (mod \; p)$（要检测 $k$ 个），则 $g$ 就是 $n$ 的原根。$g$ 要从 2 枚举到 $n - 1$。==

​	**这是因为 $\phi(n)$ 的任意一个小于 $\phi(n)$ 的约数都是某一个 $\frac {\phi(n)} {p_i}$ 的约数。**

#### 大步小步算法

##### 1. 问题

​	求解关于 $x$ 的方程 $a^x \equiv b \; (mod \; p)$，其中 $a$ 与 $p$ 互质。可能无解。

##### 2. 暴力方法

​	$O(\phi(n))$ 枚举。

##### 3. 大步小步算法（BSGS）

######①方法

​	我们可以设 $x = A t + B$，$t$ 是我们自己设的一个参数。其中 $0 \le B < t$。这样就变成求 $A$ 和 $B$ 了。
$$
a^{At + B} \equiv b \; (mod \; p)
$$
​	由于 $a$ 与 $p$ 互质，因此可以方便地求逆元，容易得到：
$$
a^{At} \equiv b × a^{-B} \; (mod \; p)
$$
​	因此，对于所有的 $b × a^{-B}$，我们可以存进一个哈希表。然后枚举左边的 $A$，算出 $a_{At}$，看看是否在哈希表中存在。

​	==很明显参数 $t$ 设成 $\left \lceil \sqrt {\phi(c)} \right \rceil$ 是最优的。==

​	这样预处理的时间复杂度为 $O(\sqrt n \log n)$，单次查询的时间复杂度为 $O(\sqrt n \log n)$。

###### ②优化

​	我们可以设 $x = A t - B$。其中 $0 \le B < t$。这样就变成了：
$$
a^{At - B} \equiv b \; (mod \; p)
\\
a^{At} \equiv b × a^{B} \; (mod \; p)
$$
​	==可以避免求逆元。**但是从上式推导到下式是要用到逆元的，因此逆元必须存在。**==

##### 4. 扩展大步小步算法（BSGSEx）

###### ①问题

​	求解关于 $x$ 的方程 $a^x \equiv b \; (mod \; c)$，其中 $a$ **不**与 $c$ 互质。

###### ②方法

​	考虑把方程转换成 $\gcd(a, c) = 1$ 的形式。

​	转换原方程后可以得到这样一个等价的方程（想想扩展欧几里得）：
$$
a^x + yc = b, y \in \mathbb{Z}
$$
​	由裴蜀定理，若 $(g = \gcd(a, m)) \nmid b$，方程一定无解。

​	当 $g \mid b$ 时，在方程左右两边同时除以 $g$，得到：
$$
\frac {a} {g} a^{x - 1} + \frac {c} {g} y = \frac {b} {g}
$$

​	相当于得到了==模方程==：
$$
\frac {a}{g} a^{x - 1} \equiv \frac {b}{g} \; (mod \; \frac {c}{g})
$$
​	令 $c' = \frac {c} {g}$，$b' = \frac {b}{g}(\frac {a}{g})^{-1}$，得新的方程：
$$
a^{x'} \equiv b' \; (mod \; c')
$$
​	可知 $x = x' + 1$。

​	==由于 $a$ 和 $c$ 只有 $c$ 变了，所以**可能会有多次过程，不断递归**，直到可以用大步小步算法即可。==**特别地，当 $b'$ 在某一时刻为 1 时，我们实际上已经得到了唯一解 $x' = 0$。** 