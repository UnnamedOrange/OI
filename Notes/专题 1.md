# 树的度序列和 Prüfer 编码

##树的度序列

##### 1. 来源

​	由于树有 n - 1 条边，因此树的度数和为 $2(n - 1)$。**反过来，**如果我们知道了一个**不上升的**正整数序列 $S$： $d_1, d_2, d_3, ... , d_n$，且它们的和为 $2(n - 1)$，我们就可以构造出以它为度序列的树。

##### 2. 证明

​	用数学归纳法。

​	假设 $n = k$ 时成立，只需证明 $n = k + 1$ 时也成立。首先必然有 $d_{k + 1} = 1$，否则序列和至少为 $2(k + 1) > 2k$（因为递增）。我们从序列中删去 $d_1$ 和 $d_{k +1}$ 并增加 $d' = d_1 - 1$ 到序列中一个保持不上升的位置。那么，现在这个序列的度数和为 $2(n - 1)$，**根据假设，**这可以构造出一棵合法的树。现在增加一个新结点 v，把它和 $d'$ 对应的结点相连，则 $d'$ 的值变为 $d_1$，并且增加了一个度为 1 的结点 v，因此新树的结点序列为 S。得证！

​	然后就可以说明，在 S 乱序时也成立了。

## Prüfer 编码

##### 1. 编码方法

​	设树为 T。

​	① 找到 T 编号最小的叶子结点 $b_1$，设它的相邻接点为 $a_1$。**这里的叶子结点是指度为 1 的结点。**

​	② 从 T 中删除 $b_1$，将 $a_1$ 添加到编码的尾部。

​	③ 重复以上过程，直到只剩下两个结点。

​	我们就得到了一个**长度为 n - 2 **的有序序列 $a$。

##### 2. 解码方法

​	①首先令 $a_{n - 1} = n$，即把编码手动延长至 n - 1 个数。

​	②令 $b_i$ 为不在当前序列的编号最小的点，则当前序列的第一个结点与 $b_i$ 有边。把它们连起来，然后**删去当前序列的第一个结点，并且不再记录 $b_i$。**

​	可以用堆进行这个操作，注意删去序列中的结点后可能会产生新的序列中没有出现过的点，这时要把它加入堆中。时间复杂度为 $O(n \log n)$。

##### 3. Cayley 定理

​	**Prüfer 编码中的每一位可以独立取 1~n 的任意数，即一个 Prüfer 序列对应一棵带标号无根树，因此有得到 Cayley 定理：**

​	不同的 n 结点标号树的数量是 $n^{n - 2}$。

##### 4. 一些推论

​	①若在 Prüfer 序列中一个点出现了 $x$ 次，那么这个点的度数为 $x + 1$。

​	②若一棵树的度数为分别为 $a_1, a_2, a_3, ... , a_n$，那么这棵树的同构数目为 $\frac {n!} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!}$。

#再再再谈 KMP 算法

##### 1. 问题定义

​	给定一个模板串，要求在一个字符串中找到模板串的位置。这又叫作字符串匹配问题。

##### 2. 原理

​	对朴素匹配进行改进。之前我们已经匹配了一些了，设匹配了 p 个。由于我们是知道模板串的，所以我们也就知道匹配串的情况，至少这 p 个我们是一清二楚的，所以有些地方不必一个一个地检查。开始以下一位为起点时，我们是知道已经匹配了多少位的，而不必像朴素算法一样重新开始。通过一些奇技淫巧，我们便能在线性时间复杂度里完成匹配。

##### 3. 失配函数 f

​	f 的物理意义是：==模板串**长度为 i** 的前缀的“相同的前缀和后缀”（不包括本身）的**最大长度**。==这样也就很好理解为什么可以快速匹配了：末尾失配了，开头的那一段好歹是一样的。保留个开头，再拿中间的那块去试试呗。

​	f 的匹配意义是：==若在模板串已匹配的长度为 i 时失配，接下来应假设已匹配的长度为多少。==通过这个定义，就能用 while 写出匹配函数了。

​	我们再来考虑如何求 f。我们假设要求 f[i + 1]，首先我们设 pre = f[i]，表示模板串 t[i]（注意这里 i 是第 i + 1 个，下标从 0 开始），然后看 t[i] 能否让后缀跟前缀一样。如果失败，我们就得尝试减少这个长度（f[i + 1]）。如图，注意图中有哪些部分是一样的。

![KMP 1](KMP 1.png)

​	因此，可以说这个过程用到了动态规划的思维：利用先前求出来的最长长度判断，而不是暴力枚举。其均摊时间复杂度为 $O(n)$。

#####4. 真正的 KMP 算法

​	上述算法其实只是 ==MP== 算法，真正的 KMP 算法还要对失配函数进行优化。

![KMP 2](KMP 2.png)

​	如上图，考虑 i = 14 的情况，此时正在计算 f[**15**]。考虑 f 的物理意义，按照 MP 算法可以得到 f[15] = 4。再考虑 f 的匹配意义，当已经匹配了 15 个字符，即正在考虑 t[**15**] 时失配，下一步应假设已匹配了多少个字符。不难得到答案应该是 4。但是，由于 t[15] = t[4] = a，**因此当 i = 15 时失配意味着在文本串的相同位置 i = 4 时也不会匹配。此时的情况是 t[i + 1] = t[f[i + 1]]。**

​	一个显然的解决办法是，遇到这种情况，就让 f[i + 1] = f[f[i + 1]]。**这样相当于抛弃了 f 的物理意义，我们就不能通过之前的方式用 f 递推 f 了。**考虑这个初始化的过程，这其实是一个==自己匹配自己==的过程，所以维护一个当前已匹配数 pre，就相当于有一个**原意义下的 f[i]。**

​	由于 f 的含义改变了，**因此不能写 f[f[i + 1]] 和 t[f[i + 1]]，而要写 f[pre] 和 t[pre]。**

​	==新的模板==如下：

```c++
INT fMP[maxn];
void initFailureMP()
{
	fMP[0] = -1;
	for (int i = 0; i < m; i++)
	{
		INT pre = fMP[i]; //这个 pre 事实上可以通过维护得到
		while (~pre && t[i] != t[pre]) pre = fMP[pre];
		pre++; //从 -1 开始避免了判断
		fMP[i + 1] = pre;
	}
}
INT fKMP[maxn];
void initFailureKMP()
{
	INT pre = fKMP[0] = -1;
	for (int i = 0; i < m; i++)
	{
		while (~pre && t[i] != t[pre]) pre = fKMP[pre];
		pre++;
		if (t[i + 1] == t[pre]) fKMP[i + 1] = fKMP[pre];
		else fKMP[i + 1] = pre;
	}
}

//...
	while (~cnt && str[i] != t[cnt]) cnt = fKMP[cnt];
	cnt++;
```

​	至于为什么不用 `while(t[i + 1] == t[pre])`，原因是**这其实是一个递推的过程，要用的之前的 f 已经是优化过的了。**

# Manacher

[参考资料](https://segmentfault.com/a/1190000003914228)

##### 1. 问题定义

​	最长回文子串问题：给定一个字符串，求出它的最长回文子串长度。回文串的定义是：如果一个字符串正着读和反着读是一样的，那么它就是回文串。

###### ① 暴力方法

​	找到所有子串，验证它是否为回文子串。时间复杂度 $O(n^3)$。

###### ② 改进的方法

​	枚举中心，向两边扩张，时间复杂度为 $O(n^2)$。

##### 2. Manacher 算法

###### ①问题 1

​	当回文串长度的奇偶性不同时，回文串的形式是不同的。

​	Manacher 首先要做一个预处理，在包括首尾的空隙位置插入一个同样的，但是不会在原串中出现的符号。**这使得所有的回文子串的长度变为了奇数**，但是不影响原串的回文性质：原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。

###### ②问题 2

​	效率问题。如何将时间复杂度将为 $O(n)$？

##### 3. Manacher 算法的定义

###### 回文半径

​	==设一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。==Manacher 定义了一个回文半径数组 RL，==用 $RL_i$ 表示**以第 i 个字符为对称轴的回文串的回文半径。**==由于我们一般对字符串从左往右处理，因此这里定义 $RL_i$ 表示==以第 i 个字符为对称轴的回文串的**最右**一个字符与字符 i 的距离。==

​	距离在这里指**包含开始和结尾的字符个数。**

```
str:	# a # b # a # a #
RL:		1 2 1 4 1 2 3 2 1 
RL - 1:	0 1 0 3 0 1 2 1 0
```

​	观察上例，发现 **$RL_i - 1$ 的值正是原字符串以 i 为对称轴的最长回文子串的长度。** 

​	定义：RL 的物理意义是==以 i 为回文中心的回文串的回文半径。==RL 的匹配意义是==原串中以位置 i 为对称轴的最长回文串的长度 + 1。==

##### 4. Manacher 算法的过程

###### ①基本思路

​	利用回文串的对称性，扩展回文串。

###### ②算法步骤

​	**我们的任务是求 RL 数组。**

​	![Manacher 1](Manacher 1.png)

​	我们需要维护==两个变量：maxRight 和 center。==maxRight 代表从左到右处理时已经到达过的最右位置（它是一个回文子串的端点），center 代表 maxRight 对应的回文子串的回文中心。

​	**注意：上图中从未说到目前正在处理哪里！接下来将对此分情况讨论！**

​	我们设当前正在处理第 i 位，毫无疑问，第 i 位一定在 center 的右边。然后我们分成以下三种情况：

①若 i 在 maxRight 左边

![Manacher 2](Manacher 2.png)

​	上图应该是最简单的情况了。**我们找到 i 关于 center 对称的点 j，发现 j 的回文半径居然还不足以触及到 center！**所以此时 $RL_i = RL_j$。（1）

​	![Manacher 3](Manacher 3.png)

​	当 j 的回文半径更大，超过了 center 时，我们只能知道 **i 到 maxRight 是以 i 为回文中心的最小回文半径（粗虚线）。**能否到细虚线**或是更远**，只能扩张 i 并且**更新 maxRight 和 center** 来检查了。（2）

②当 i 在 maxRight 的右边

![Manacher 4](Manacher 4.png)

​	**只有唯一一种情况：i 与 maxRight 相邻。**这时让回文半径从 1 开始（即从 i 开始）不断扩张，直到**不再回文或到达边界，同时更新 center 和 maxRight 即可。**（3）

​	==总的来说分成三种情况，但其中（1）（2）一并处理，以代码实现为准。==

##### 5.时空复杂度

​	空间复杂度明显是线性的。由于扩张 maxRight 的操作对于每个位置只会进行一次，因此我们得到：Manacher 的时间复杂度是线性的。

# Aho-Corasick Automation

（粗体为终点内容，加亮为关键内容）

##### 1. 问题定义

​	给定一个模板串集合，要求在一个字符串中找到所有模板的位置。这个问题又叫做多模式匹配问题。

##### 2. AC 自动机

​	AC 自动机由一个 Trie 和一个失配边集合组成。

​	由于 AC 自动机的底层是一个 Trie，那么它自然有一个 Trie 结点。

```c++
struct Node
{
 	Node* c[alpha_size];
 	Node* fail;
 	Node* suffix;
 	INT count;
};
```

​	可以看出，AC 自动机的结点在 Trie 的基础上多出了个 fail 指针，还多了个 suffix 指针。它们到底怎么用呢？我们一会儿来讲解。

###### ①Trie 的结构

​	我们一般认为，Trie 是一棵结点上没有字符，而在边上有字符的树。AC 自动机也类似，根结点是一个虚拟的结点，但是==可以认为字符存在在其它结点上，==**这样有助于理解“状态”一词。**实际上，==AC 自动机的结点中不保存字符，我们仍然把字符“存”在边上。==

​	回忆 KMP 算法，在某个地方失配后我们要让模板串往前移，通过记录一个失配函数来实现这个功能。事实上 KMP 的失配函数是一个状态机，由于它很简单，所以可以用一个 f 数组来实现。AC 自动机是一棵树，所以必须要用指针，**但是它的功能和 KMP 的失配函数是完全一样的，**==其物理含义也是一样的：指向最长的与后缀相同的前缀的尾部。==

​	与 KMP 算法类似，AC 自动机也是边走边匹配，但是有这么一个区别：若找到了一个串，同时也就说明了找到了这个串的后缀；**如果一个模板是另一个模板的后缀，说不定会出现同时找到两个串或更多串的情况。**一个最简单的想法是沿着失配边走，直到走到根结点，但是**当模板串只由一种字符组成时，时间复杂度就悲剧了：失配边边数与模板串长度同阶。**所以我们需要一个更优秀的东西，它就是 ==suffix 指针==，中文名叫做==后缀链接==。==它的作用就是在**每一个**状态处（并不一定非要是匹配的一个状态）往回走，保证只会走到匹配点或者根结点。==这样时间复杂度就得到了保证。

###### ②构建 AC 自动机

​	工欲善其事，必先利其器。==建立 AC 自动机前，你要先建好 Trie 树。==**这就意味着你不能边插入模板串边维护 AC 自动机，只能把模板串插入完后再一次建成。**

​	步骤（1）：==用 AC 自动机的结点，建立一棵一般的 Trie 树。==

​	受题目影响，**可能会有相同的模板串。**==这时要根据题目要求确定记一次还是记多次，count 就起作用了。==

​	步骤（2）：==构造 fail 指针，同时构造 suffix 指针。==

​	**由于我们肯定是用之前的数据推出之后的目标，所以 ==BFS== 是我们的不二选择。**我们先将根结点放进队列中，==每次通过出队的去更新它的儿子，而不是在出队时更新自己。==这样一不用特判根结点，二我们能**知道子结点对应的字符是什么。**

​	suffix 的计算与 fail 的计算息息相关。==得到 fail 指针后，我们先检查 fail 指向的结点是否代表一个字符串，如果是，就指向 fail，否则指向 fail 的 suffix。== 

​	就这样，AC 自动机就建好了。

###### ③向自动机输入

​	然后就和 KMP 几乎一模一样了，唯一的区别是==**每次**都要跑一次 suffix 到根结点。==

##### 3. 时空复杂度

​	设文本串长度为 n，模板串总长度为 m。

​	**Trie 结点占用的大小不能忽视**，其空间复杂度为 $O(α)$，代表字母表大小。很明显整体空间复杂度为 $O(mα)$。

​	时间复杂度是线性的。

# 仙人掌（1）（未完待续）

[参考资料](http://blog.csdn.net/zhangche0526/article/details/71879985#bzoj1023cactus仙人掌图shoi2008)

##### 1. 概念

​	![仙人掌 1](仙人掌 1.png)

​	（上图为每逢仙人掌必出的图）

###### ①仙人掌

​	==若有一个**无向连通**图 $G$，$G$ 的**任意边属于至多一个简单环^[1]^**，则称 $G$ 为仙人掌。==

​	虽然仙人掌的一条边最多属于一个环，但是**仙人掌的一个点可能属于多个环。**

​	^[1]^简单环：感性地理解，就是环。

###### ②图论中与仙人掌有关的概念

​	桥边：在无向连通图 $G$ 中，若删去某条边 $e$ 后，图不连通，则称 $e$ 为 $G$ 的桥。==在仙人掌中，就是非环边^[1]^。==

​	^[1]^环边：感性地理解，就是==环上的边。==

##### 2. 圆方树

​	![仙人掌 2](仙人掌 2.png)

​	（上图为一棵圆方树）

​	如果我们能把仙人掌放在树上取搞它那该多好！==事实上，圆方树就是一个解决**静态**仙人掌问题的重要方法。==

###### ①定义

​	仙人掌 $G = (V, E)$ 的圆方树 $T = (V_T, E_T)$ 为满足以下条件的无向图：

​	①$V_T = R_T \cup S_T, R_T = V, R_T \cap S_T = \emptyset$，我们称 $R_T$ 集合为==圆点==，$S_T$ 集合为==方点==。

​	②$\forall e \in E$，若 $e$ 不在任何简单环中，则 $e \in E_T$。

​	说人话：**原仙人掌上所有点都是圆点；**为仙人掌的每一个环新建一个方点，所有在环上的（圆）点都要与方点相连，同时删去所有环边。

###### ②性质

​	（1）圆方树的形态与根的选取无关。换句话说，**没有编号的仙人掌和圆方树是一一对应的。**

​	（2）子圆方树对应子仙人掌^[1]^。

​	（3）==方点和方点不会直接相连。==

​	^[1]^子仙人掌：以 r 为根的仙人掌上的点 p 所在的的子仙人掌是从仙人掌中去掉 p 到 r 的简单路径上的所有边后，p 所在的连通块。

###### ③构建

​	==使用 Tarjan 求点双连通分量的算法。==对于每一个点双连通分量，都建立一个方点，依次向栈中的圆点连边。从栈中取出一个点双连通分量时，栈中的顺序就是环上的顺序。==如果找的边为桥边，我们直接在新图中原样加入它就是了。==

​	所以让我们先复（预）习下点双连通分量。

# 无向图的双连通分量（未完待续）

##### 1.概念

​	==无向图的双连通分量分成两类。==第一类叫做==边双连通分量==，第二类叫做==点双连通分量==。在了解它们之前，得先明白什么是==割顶==和==桥==。

​	割顶：无向连通图中，若删去一个点以及与它相连的边后图不再连通，则称这个点为该图的割点。

​	桥：无向连通图中，若删去一条边后该图不再连通，则称这条边为该图的桥。

​	边双连通分量：无向连通图中，如果**任意**两点至少存在两条“边不重复”的路径，我们称这个图是边双连通的。==即所有边都不是桥。==边双连通的**极大子图**称为点双连通分量。

​	点双连通分量：无向连通图中，如果**任意**两点至少存在两条“点不重复”的路径，则称这个图是点双连通的。==即所有点都不是割顶。==点双连通的**极大子图**

​	点双连通分量等价于要求任意两条边都在同一个简单环中；边双连通分量等价于要求每条边都至少在一个简单环中。明显，边双连通分量的要求比点双连通分量低一点。

​	**边双连通分量没有公共结点，而点双连通分量可能有公共结点。**

##### 2. 寻找割顶和桥

​	考虑 ==DFS 树==。若一个点的子结点最多只能回到自己，那么这个点就是割点；若一个点的子结点连自己都回不到了，就说明这个点到这个子结点的边是桥。

​	具体的可以参考小蓝书。

#####3. 寻找边双连通分量

​	边双连通分量要简单些，而且有两种做法。

###### ①方法 1

​	==可以直接用 Tarjan（SCC）算法来求。==与有向图的唯一区别是“不回头走刚刚走过的边”。这样，求出的每一个“强连通分量”就是一个边双连通分量。

###### ②方法 2

​	==可以先找出所有的桥。==**由于边双连通分量之间是没有公共点的**，所以只要保证不走桥就好了。这样每 DFS 出一个连通块就是一个边双连通分量。

##### 4. 寻找点双连通分量

​	用 ==Tarjan（biconnected）^[1]^算法==。

​	^[1]^：Tarjan 不仅有 SCC 算法，还有 LCA 算法，biconnected 算法等等，所以必须注明，不要弄混了。

​	这个算法类似于 Tarjan（SCC），仍然需要 dfn 和 low。但是它的栈里保存的是==在当前 BCC 的边==。

​	

# 线性代数

​	阅读说明：如果你想以最快的速度了解知识点，请读==加亮部分==。有些地方由于格式限制或为了突出重点，没有加亮，**请顺便读一下上下文。**如果你想了解**关键点**，请读**加粗部分**。**此标记仅代表我的见解，所以最好是阅读全文！**

#### 行列式

[整理自参考资料](https://wenku.baidu.com/view/7d6b77cafd0a79563d1e721f.html)

##### 1. 行列式（1）

######①二阶行列式

​	记：
$$
\begin{vmatrix}
a_{11} & a_{12}\\
a_{21} & a_{22}
\end{vmatrix}
$$
​	称为==二阶行列式==。

​	它表示**数**：$a_{11}a_{22} - a_{12}a_{21}$。

######②概念

​	左上角到右下角表示==主对角线==。

​	右上角到左下角表示==次对角线==。

###### ③三阶行列式

​	记：
$$
\begin{vmatrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & a_{22} & a_{23}\\
a_{31} & a_{32} & a_{33}
\end{vmatrix}
$$
​	称为==三阶行列式==。

###### ④对角线法则

​	三阶行列式也表示一个==数==。
$$
\begin{vmatrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & a_{22} & a_{23}\\
a_{31} & a_{32} & a_{33}
\end{vmatrix}\\
=
a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32}\\
- a_{13}a_{22}a_{31} + a_{12}a_{21}a_{33} + a_{11}a_{23}a_{32}
$$
​	==对角线法则==：行列式表示的数为：**延伸后的主对角线的元素积的和 - 所有延伸后的次对角线的元素的积的和。**这里如果不懂，只好感性地理解下了，图很难画。

​	==行列式的行数等于列数。==

##### 2. 排列及其逆序数

​	称由 1~n 组成的一个有序数组 a[1~n] 为一个 n 级排列。

​	n 级排列的总数为 $n!$ 个。

​	在一个 n 级排列中，若某两个数的前后位置与大小顺序相反，即大的在小的前面，则称这两数构成一个逆序。排列中逆序的总数，称为它的逆序数，==记为 $N(a)$==。

​	若排列 a 的逆序数为奇数，称它为奇排列；若排列 a 的逆序数为偶数，称它为偶排列。

##### 3. 对换

​	在一个排列 a 中，若其中某两个数互换位置，其它各数不变，得到一个新排列 a'。这种变换称为一个对换，记为(a[i], a[j])。

​	定理 1：**任一排列经过一个对换后奇偶性改变。**

​	定理 2：==**n 个数共有 $n!$ 个排列，其中奇偶排列各占一半，各为 $\frac {n!} {2}$。**==

##### 4. 行列式（2）

###### ①n 阶行列式

$$
\begin{vmatrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & a_{22} & a_{23}\\
a_{31} & a_{32} & a_{33}
\end{vmatrix}\\
=
\sum (-1)^{N(j_1 j_2 j_3)} (a_{1j_1} a_{2j_2} a_{3j_3})
$$

​	偶排列加，奇排列减，项数为 $3!$。

​	$j_1, j_2, j_3$ 为所有的三级排列。

​	推广之，得定义：

​	==$n^2$ 个元素 $a_{ij} (i, j = 1, 2, ..., n)$ 排成的 n 阶行列式：==
$$
\begin{vmatrix}
a_{11} & a_{12} & ... & a_{1n}\\
a_{21} & a_{22} & ... & a_{2n}\\
... & ... & ... & ...\\
a_{n1} & a_{n2} & ... & a_{nn}
\end{vmatrix}\\
=
\sum (-1)^{N(j_1 j_2 ... j_n)} (a_{1j_1} a_{2j_2} ... a_{nj_n})
$$
​	==记为 $\det (a_{ij})$ 。==

###### ②三角行列式

​	==下三角行列式的值等于其主对角线各元素的乘积。==
$$
\begin{vmatrix}
a_{11} & 0 & 0 & ... & 0\\
a_{21} & a_{22} & 0 & ... & 0\\
a_{31} & a_{32} & a_{33} & ... & 0\\
... & ... & ... & ... & ...\\
a_{n1} & a_{n2} & a_{n3} & ... & a_{nn}
\end{vmatrix}
=
\prod a_{ii}
$$
​	==上三角行列式的值等于其主对角线各元素的乘积。==
$$
\begin{vmatrix}
a_{11} & a_{12} & a_{13} & ... & a_{1n}\\
0 & a_{22} & a_{23} & ... & a_{2n}\\
0 & 0 & a_{33} & ... & a_{3n}\\
... & ... & ... & ... & ...\\
0 & 0 & 0 & ... & a_{nn}
\end{vmatrix}
=
\prod a_{ii}
$$
​	==对角行列式的值等于其主对角线各元素的乘积。==
$$
\begin{vmatrix}
a_{11} & 0 & 0 & ... & 0\\
0 & a_{22} & 0 & ... & 0\\
0 & 0 & a_{33} & ... & 0\\
... & ... & ... & ... & ...\\
0 & 0 & 0 & ... & a_{nn}
\end{vmatrix}
=
\prod a_{ii}
$$
​	==类似可得次对角线各元素的乘积的情况。**由行列式定义，它的正负取决于 n~1 组成的排列的逆序 $N(a) = \frac {n(n - 1)} {2}。$**==**这里如果不理解就手算一下；如果不明白什么意思就往前看。明白后再继续。**

###### ③转置行列式

​	定义：如果==将行列式 D 的行换为同序数的列，得到的新行列式称为 D 的转置行列式，记为 $D^T$。==这里如果不理解就结合转置矩阵感性地理解下。

###### ④两个练习

​	（1）
$$
\begin{vmatrix}
0 & 1 & 0 & ... & 0\\
0 & 0 & 2 & ... & 0\\
... & ... & ... & ... & ...\\
0 & 0 & 0 & ... & n - 1\\
n & 0 & 0 & ... & 0
\end{vmatrix}\\
= (-1)^{N(2 \, 3 \, ... \, n \, 1)} (1 × 2 × ... × n)
= (-1)^{n - 1} n!
$$
​	==推论：n 阶行列式 $D = \det(a_{ij})$ 的值为==
$$
D = \sum (-1)^{N(i_1 i_2 ... i_n) + N(j_1 j_2 ... j_n)} (a_{i_1 j_1} a_{i_2 j_2} ... a_{i_n j_n})
$$
​	令 $i_1 i_2 ... i_n$ 为 $1 \, 2 \, ... \, n$，得练习 1 的式子。

​	（2）
$$
\begin{vmatrix}
a_1 & b_1 & c_1 & d_1 & e_1\\
a_2 & b_2 & c_2 & d_2 & e_2\\
a_3 & b_3 & 0 & 0 & 0\\
a_4 & b_4 & 0 & 0 & 0\\
a_4 & b_5 & 0 & 0 & 0
\end{vmatrix}
= 0
$$
​	对于行列式的每一项，无法避免至少有一个数为 0，所以行列式为 0。

​	理解后再继续。

##### 5. 行列式（3）

###### 行列式的性质

​	引入：对高阶的行列式而言，直接利用其定义来计算几乎是不可能的，**时间复杂度为指数级别**。

​	性质 1：==行列式与它的转置行列式相等。==即 $D = D_T$。

​	性质 2：==互换行列式的两行或两列，行列式的值变号。==

​		推论：==若行列式 D 的两行或两列完全相同，则 $D = 0$。==

​	性质 3：==用**数** k 乘以行列式的**某一**行或**某一**列，等于 k 乘以行列式。==

​		推论 1：D 中某一行或某一列中所有元素的因子可以提到行列式的符号的外面。

​		推论 2：若 D 的某两行或某两列的对应元素成比例，则 $D = 0$。

​	性质 4：==**行列式 D 的某一行或某一列的所有元素都乘以数 k 加到另一行或另一列（行对行，列对列）的相应元素上，行列式的值不变。**==

​	==**通过性质 4 我们可以将行列式转换为三角行列式，从而在线性时间内计算出行列式。**==

​	==其它性质及练习见参考资料。==

#### 高斯消元

​	假设你已经会了矩阵的最最最基本的概念，矩阵加法，矩阵乘法，矩阵的运算律，方阵，单位矩阵，转置矩阵。

[参考资料](https://www.cnblogs.com/candy99/p/6653743.html)

##### 1. 概念

​	高斯消元（Gaussian elimination）是求解线性方程组的方法。在学习它之前我们先介绍一些概念。

###### ①矩阵

​	（1）可以用一个方阵乘以一个列向量表示一个线性方程组。
$$
\begin{bmatrix}
a_{11} & a_{12} & ... & a_{1k} \\ 
a_{21} & a_{22} & ... & a_{2k} \\
... & ... & ... & ... \\
a_{k1} & a_{k2} & ... & a_{kk}
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2 \\ ... \\ x_k
\end{bmatrix}
=
\begin{bmatrix}
b_1 \\ b_2 \\ ... \\ b_k
\end{bmatrix}
$$
​	（2）逆矩阵

​	**某些** n 阶**方阵** $A$ 中，==存在**唯一**逆元^[1]^ $A^{-1}$ 使得 $A × A^{-1} = A^{-1} × A = I_n$，其中 $I_n$ 是 n 阶单位矩阵（identity matrix）。==

​	矩阵可逆有一个常用的充要条件：==所有行向量都是线性无关的。==线性无关的意思是：==任何一个向量都不能通过其它向量的线性组合得到。==

​	如果我们知道了 $A$ 的逆矩阵 $A^{-1}$，我们就能求解方程组 $Ax = b$。两边同时**左乘**一个 $A^{-1}$ 得到 $x = A^{-1} b$。==所以当 $A^{-1}$ 不存在时，方程组 $Ax = b$ **无解或有无穷多解**。==

###### ②高斯消元中的矩阵

​	（1）增广矩阵
$$
\begin{bmatrix}
a_{11} & a_{12} & ... & a_{1k} & b_1 \\ 
a_{21} & a_{22} & ... & a_{2k} & b_2 \\
... & ... & ... & ... & ...\\
a_{k1} & a{k2} & ... & a_{kk} & b_k
\end{bmatrix}
$$
​	以上矩阵被称为增广矩阵。即==系数矩阵^[1]^加上一列**常数**==。

​	^[1]^系数矩阵：就是上文中用于表示线性方程组的方阵 $A$。

​	（2）矩阵的初等行变换

​	包含以下三个操作：

​		①交换两行。

​		②给一行中的所有数乘上一个非零数。

​		③把一行的倍数加到另一行上。

##### 2. 步骤

​	从上至下依次处理每一行，处理完第 i 行后，让 $A_{ii}$ 非零，而 $A_{ji} (j > i)$ 均为 0。（0 用空白表示）
$$
\begin{bmatrix}
2 & 1 & -1 & 8 \\ 
-3 & -1 & 2 & -11 \\
-2 & 1 & 2 & -3
\end{bmatrix}
\to
\begin{bmatrix}
-3 & -1 & 2 & -11 \\ 
 & \dfrac {1} {3} & \dfrac {1} {3} & \dfrac {2} {3} \\
 & \dfrac {5} {3} & \dfrac {2} {3} & \dfrac {13} {3}
\end{bmatrix}
\to
\begin{bmatrix}
-3 & -1 & 2 & -11 \\ 
 & \dfrac {5} {3} & \dfrac {2} {3} & \dfrac {13} {3} \\
 &  & \dfrac {1} {5} & -\dfrac {1} {5}
\end{bmatrix}
$$
​	注意：虽然这里说是从上至下，但是**这个例子以及实践中**并非如此。

​	==实际过程中， 假设正在处理第 i 行，则首先需要找一个 $r \ge i$ 且绝对值最大的 $a_{ri}$，然后交换第 r 行和第 i 行。==**即在第几行就在第几列找一个未处理的最大的，有助于提高数值稳定性^[1]^。**

​	然后是==加减消元==。一般情况下，如果要==用第 i 个方程来消去第 k 个方程的第 i 列==，那么第 k 行的**所有元素** $A_{kj}$ 都应该减去 $A_{ij}$ 的 $\dfrac {a_{ki}} {a_{ii}}$ 倍。

​	下一步是==回代==。现在 $A$ ==是一个上三角矩阵。==这样，就相当于告诉了我们 $x_n$ 的值，然后一步一步往上代入求解 $x_i$ 即可。

​	^[1]^数值稳定性：可以把它理解成算法的精确性与正确性，具体点就是浮点误差。

​	**以上为最基本的步骤和思路，可以发现==有交换行，加减消元和回代这三个步骤，其中前两个步骤可以归纳为加减消元。==**

##### 3. 问题

​	为了得到第 k 行的消元比例，我们可以令 $f = \dfrac {A_{ki}} {A_{ii}}$，但可能会有精度问题，这个时候==不定义临时变量直接计算会有点效果。==**但是必须保证最后才算 $A_{ki}$，所以要倒着枚举：

```c++
for(int k = i + 1; k < n; k++)
{
	//第 i 行乘以一个系数后再用第 k 行去减去第 i 行，使 a[k][i] 为 0
	for(int j = n; j >= i; j--) //倒着枚举 j
		a[k][j] -= a[k][i] / a[i][i] * a[i][j];
}
```

​	**至此，最最最最基本的高斯消元就讲完了，但是还有很多问题……**

