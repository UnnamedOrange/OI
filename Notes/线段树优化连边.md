[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 线段树优化连边

## 前言

一直听别人说线段树优化连边，所以这到底是个什么东西呢？

蒟蒻的联想：比如要给 $l$ 到 $r$ 连边，是不是维护一个什么东西，然后连边就自然成了？？！

残酷的现实：线段树优化连边跟线段树（这种数据结构）没有关系，跟优化没有什么关系，跟连边~~也没有什么关系~~还是有那么一丁点关系的。

## 可能用到的知识

1. 线段树优化连边的含义：**利用类似线段树的结构重新建图，用一个结点代表一堆结点，如果需要向这一堆结点的所有点连一条边，那么只需要连一条边就可以了。**
2. 对于一棵范围为 $[1, n]$ 的线段树，除开叶结点，**恰好**有 $n - 1$ 个结点。加上叶结点后**恰好有 $2n - 1$ 个结点**。笼统地讲，结点数是线性的。
3. 对于一个长度为 $n$ 的区间，至多需要 $O(\log n)$ 个线段树上的结点就能将它完全覆盖。
4. 对于一个位置，在线段树有 $O(\log n)$ 个结点将它覆盖。
5. 除开叶结点，线段树上每个结点的 `mid` 都是唯一的，且除了 $n$，其它值 `mid` 都出现过 。

## 线段树优化连边

##### e.g. [CF 787D Legacy](http://codeforces.com/problemset/problem/787/D)

###### 题目大意

有一张 $n \pod {n \le 10^5}$ 个结点的图，有 $q \pod {q \le 10^5}$ 次连边操作。连边操作分三种，分别是：

1. 从 $v$ 向 $u$ 连一条边权为 $w$ 的边；
2. 从 $v$ 向 $[l, r]$ 中的所有结点连一条边权为 $w$ 的边；
3. 从 $[l, r]$ 中的所有结点向 $v$ 连一条边权为 $w$ 的边。

给定起点 $s$，求出以 $s$ 为起点的单源最短路（Dijkstra），需要判断无法到达的情况。

###### 暴力方法

按照题目要求暴力连边，边的数量是 $O(n q)$ 的。所以哪怕你有一个数据结构能够让你加快知道边要连到哪里也无济于事，何况这里连边的时间复杂度已经是 $O(1)$ 了。

###### 线段树结构

假设现在只有第 2 种连边方式，该怎么做？我们可以在这 $n$ 个结点的基础上再加 $n - 1$ 个结点，并形成线段树结构，线段树上的边**从上到下**有向，边权为 $0$。连边时，我们直接从起点向能够刚好覆盖完区间的最大结点连一条边权为 $w$ 的边，一次只需要连 $O(\log n)$ 条边。

现在加上第 3 种连边方式。发现之前新建的那 $n - 1$ 个结点无法再次利用（为了体现从某个点出发，必须从下到上连边权为 $0$ 的边，但是之前已经从上到下连过，再连的话两点间距离均为 $0$），怎么办？

那就再新建 $n - 1​$ 个结点形成线段树结构，线段树上的边**从下到上**有向，边权为 $0​$。连边时，我们从能够刚好覆盖完出发区间的最大结点连一条边权为 $w​$ 的边，一次也只需要连 $O(\log n)​$  条边。最后跑单源最短路就完了。

------

如果我们需要对一个区间进行连边，那么我们线段树上的边应该是从上往下的；如果我们需要从一个区间出发到一个点，那么线段树上的边应该是从下往上的。如果同时需要两者，则需要两棵线段树，加上原结点共有 $3n - 2$ 个结点。

###### 总结

这个东西跟线段树这种数据结构没什么关系，跟倍增并查集倒是属于同一类东西。

###### 实现

首先要面对的问题是：如何给线段树上的结点编码。

回忆标号黑科技：

```c++
inline int code(int l, int r)
{
	return (l + r) | (l != r);
}
```

由于不包含叶结点，因此它等效于：

```c++
inline int code(int l, int r)
{
	return (l + r) | 1;
}
```

既然最后一位都是 $1$，那我们索性不要它：

```c++
inline int code(int l, int r)
{
	return (l + r) >> 1;
}
```

发现，这不就是 `mid` 吗？原来线段树标号黑科技的原理是除开叶结点，每个结点的 `mid` 不同，所以这里我们直接把一个结点的 `mid` 作为它的标号就可以了。

##### e.g.  [ARC(AtCoder Regular Contest) 069F Flags](https://arc069.contest.atcoder.jp/tasks/arc069_d)

###### 题目大意

要在一条直线上放 $n \pod {2 \le n \le 10^4}$ 个旗子，第 $i$ 个旗子可以放在 $x_i$ 或者 $y_i$ 处，求旗子间的最大间隔长度。放在同一位置的旗子视作间隔为 $0$。

------

这道题需要用到 2-SAT，有关 2-SAT 的问题见《2-SAT 问题》。

###### 强连通分量

2-SAT 需要求强连通分量，那么线段树优化连边会不会影响结果呢？

很明显不会，**因为线段树优化连边的本质是用一个点代替一堆点，对原图的强连通分量并没有影响**。

###### 叶结点

我们可以让线段树的倒数第二层指向不同的叶结点来达到不同的效果。

```c++
int buildx(int l, int r)
{
	if (l == r)
		return idx[l]; // x 按 y 排序
	int mid = (l + r) >> 1;
	int node = mid + (n << 1);
	G[node].push_back(buildx(l, mid));
	G[node].push_back(buildx(mid + 1, r));
	return node;
}
```

```c++
int buildy(int l, int r)
{
	if (l == r)
		return l + n; // y 按 x 排序
	int mid = (l + r) >> 1;
	int node = mid + n * 3 - 1;
	G[node].push_back(buildy(l, mid));
	G[node].push_back(buildy(mid + 1, r));
	return node;
}
```

上面两段代码中，最大的差别是指向的叶结点不同，第一段的代码中的叶结点甚至不是一个区间。所以线段树优化连边可以做得非常灵活。

##### e.g. 口胡题

###### 题目大意

有一张 $n \pod {n \le 10^5}$ 个结点的图，有 $q \pod {q \le 10^5}$ 次连边操作。连边操作分三种，分别是：

1. 从 $v$ 向 $u$ 连一条边权为 $w$ 的边；
2. 从 $v$ 向 $[l, r]$ 中的所有**奇数**结点连一条边权为 $w$ 的边；
3. 从 $v$ 向 $[l, r]$ 中的所有**偶数**结点连一条边权为 $w$ 的边；
4. 从 $v$ 向 $[l, r]$ 中的所有结点连一条边权为 $w$ 的边；

###### 提示

希望你能感受线段树叶结点的灵活性。

------

用三棵线段树即可。