[TOC]

# 轮廓线动态规划

## 骨牌覆盖问题

给你一个 $n \times m$ 的棋盘，给你若干个 $1 \times 2$ 的骨牌，问有多少种摆放骨牌的方式使得骨牌恰好覆盖整个棋盘，这被称为*骨牌覆盖问题*。

参考资料：[hihoCoder](http://hihocoder.com/)

##### 1. [$2 × n$ 的骨牌覆盖问题](http://hihocoder.com/problemset/problem/1143)

毫无疑问，要么横着放两个，要么竖着放一个，没有别的合法方案，于是得到递推方程：
$$
f_n = f_{n - 1} + f_{n - 2}
$$
时间复杂度 $O(2^3 \log n)$。

##### 2. [$3 × n$ 的骨牌覆盖问题](http://hihocoder.com/problemset/problem/1151) 

多了一行，复杂度却上升了不止一个档次。我们考虑**增加状态**来简化转移。

由于放骨牌的顺序是无关紧要的，所有地方都需要放骨牌，因此我们不妨一列一列地放满。

假设我们已经放好了前 $i - 1$ 列骨牌，对于第 $i$ 列骨牌，会有 $2^3 = 8$ 种情况：

<img src="http://media.hihocoder.com/problem_images/20150418/14293404042701.png" style="zoom:75%">

我们可以用一个三位的二进制数表示这八种情况：

<img src="http://media.hihocoder.com/problem_images/20150418/14293404048152.png" style="zoom:75%">

为了方便，我们将棋盘旋转一下。假设我们正在放置第 $i$ 行的骨牌，那么会有下面三种方式：

<img src="http://media.hihocoder.com/problem_images/20150418/14293404048833.png" style="zoom:75%">

<center>灰色表示已有骨牌</center>

根据经验，我们设 $f_{i, S}$ 表示处理到第 $i$ 行，**前 $i - 1$ 行的骨牌已经放满，$i + 1$ 行之后得骨牌都没有放**，第 $i$ 行放骨牌的状态为 $S$ 的方案数。那么最终答案为 $f_{n, (111)_2}$。

###### 构造方法

对于第 $i$ 行，我们有三种放骨牌的方法：

1. 某个位置不放骨牌，则第 $i - 1$ 行对应位置必须有放置的骨牌，否则前 $i - 1$ 行骨牌没有放满，不满足条件。

2. 某个位置竖放骨牌（注意转回来就是横着放的意思），则第 $i - 1$ 行对应位置必须没有放置骨牌，否则这个骨牌和之前的就重叠了，不是合法方案。

3. 某个位置横放骨牌，则第 $i - 1$ 行对应的两个位置必须有放置的骨牌，否则前 $i - 1$ 行骨牌没有放满。

&emsp;&emsp;例如，对于 $f_{i, (001)_2}$，我们可以转移到 $f_{i + 1, (110)_2}$：

<img src="http://media.hihocoder.com/problem_images/20150418/14293404046915.png" style="zoom:75%">

需要注意的是，我们做的是多段图的动态规划，只能从前一段转移到后一段，而不能在同一段中转移。换句话说，只能从 $f_{i, S}$ 转移到 $f_{i + 1, S'}$，而不能从 $f_{i, S}$ 转移到 $f_{i, S'}$。

<img src="http://media.hihocoder.com/problem_images/20150418/14293404045844.png" style="zoom:75%">

<center>不正确的转移：在同一段中进行转移，转移图中出现了圈</center>

你可能会说：这可以看作从 $f_{i, 1}$ 转移到 $f_{i + 1, 0}$ 啊。但是这与我们动态规划状态的含义不符。我们设的是正在处理第 $i$ 行，那么我们只能在第 $i$ 行放骨牌，不能在 $i - 1$ 行放骨牌了（竖放骨牌仍然算作放在第 $i$ 行的，因为我们是在第 $i$ 行做的决策）。

------

对于每个状态 $S$，我们手工计算当上一个状态为 $S'$ 时是否有转移。邀请神仙计算后，我们得到如下转移矩阵：

<img src="http://media.hihocoder.com/problem_images/20150418/14293404047166.png" style="zoom:75%">

<center>转移矩阵（空白的地方都是 $0$）</center>

边界条件为 $f_{0, (111)_2} = 1$，其余为 $0$。时间复杂度 $O((2^3)^2 \log n)$。

##### 3. [$k × n$ 的骨牌覆盖问题](http://hihocoder.com/problemset/problem/1162)

根据 $3 \times n$ 的骨牌覆盖问题给我们的经验，我们知道：$k \times n$ 的转移矩阵将会是 $2^k \times 2^k$ 的。我们只能想办法编程计算出转移矩阵。

###### ①构造转移

假设我们已经有第 $i - 1$ 行的状态了，根据[前面放骨牌的方法](#构造方法)，我们可以找到唯一的一个第 $i$ 行的状态使其可以转移，或者宣布找不到一个可以转移的状态。

我们不妨**一列一列**地进行决策，用 DFS 构造两个状态使得它们能够转移，当找到两组能够转移的状态时我们就修改转移矩阵中的值。

###### ②参考代码

```c++
void MakeMatrix(Matrix& r, int colum, int from, int to)
{
	if (colum == m)
	{
		r.c[from][to] = 1;
		return;
	}
	else if (colum > m) return;
	MakeMatrix(r, colum + 1, from << 1 | 1, to << 1); // 不放
	MakeMatrix(r, colum + 1, from << 1, to << 1 | 1); // 竖放
	MakeMatrix(r, colum + 2, from << 2 | 3, to << 2 | 3); // 横放
}
```

###### ③当 $n$ 较小时

当 $n$ 较小时，我们不必使用矩阵乘法加速，因为这时往往 $k$ 比较大，使用 $O((2^{k})^3)$ 的矩阵乘法反而很慢。我们直接保存最近两次的状态进行转移，这样我们的空间复杂度为 $O(2^{k} n)$，时间复杂度为 $O(2^{2k}n)$。

```c++
std::vector<int> transfer[1 << 11];
void MakeTransfer(int colum, int from, int to)
{
	if (colum == m)
	{
		transfer[from].push_back(to);
		return;
	}
	else if (colum > m) return;
	MakeTransfer(colum + 1, from << 1 | 1, to << 1); // 不放
	MakeTransfer(colum + 1, from << 1, to << 1 | 1); // 竖放
	MakeTransfer(colum + 2, from << 2 | 3, to << 2 | 3); // 横放
}
```

```c++
int U = 1 << m;
f[0][U - 1] = 1;
MakeTransfer(0, 0, 0);
for (int i = 1; i <= n; i++)
{
	int* cnt = f[i & 1];
	int* pre = f[!(i & 1)];
	memset(cnt, 0, sizeof(int) * U);
	int* trans;
	for (int S = 0; S < U; S++) // 上一个状态
	{
		trans = transfer[S].data();
		for (int j = 0, to = transfer[S].size(); j < to; j++)
			(cnt[trans[j]] += pre[S]) %= mod;
	}
}
printOut(f[n & 1][U - 1]);
```

这种用 `vector` 保存状态的方法很不错，在实际表现下时空都很优秀。如果空间实在开不下，可以考虑直接调用 `MakeTransfer` 函数进行转移，用时间换空间。

------

像这种以行（line）为阶段并通过保存其每一行的具体状态（使用状态压缩）进行转移的，我们称之为*轮廓线动态规划*。

## 插头 DP

[参考资料](http://www.cnblogs.com/LadyLex/p/7326874.html)（入门推荐）

[参考资料](https://www.cnblogs.com/zinthos/p/3897854.html)（最小表示法）

[参考资料](https://blog.csdn.net/litble/article/details/79369147)（括号序列法）

### 插头 DP 能干什么

学了插头 DP，你能在一个 $n \times m$ 很小的棋盘上：

- 求有多少种用一条或多条回路经过所有点的方案数
- 求有多少种用一条回路经过所有点的方案数
- 求一条回路上每个格子的权值和的最大值
- 求一条路径上每个格子的权值和的最大值
- $\cdots \cdots$

插头 DP 通常很明显，但代码量大又容易出错。

### 插头 DP

##### 1. 概念

###### 什么是插头

<img src="https://images0.cnblogs.com/i/660613/201408/071749415846431.png" style="zoom:100%">

<center>上面的箭头就是插头啦</center>

对于一个四连通的问题来说它通常有上下左右四种插头，一个方向的插头存在表示这个格子在这个方向可以与外面相连。

由于我们（就目前为止）考虑都是回路，因此所有格子必然都是从一个方向进，从另一个方向出去。显然格子内路线的形式有如图 $6$ 种。

###### 什么是插头 DP

我们进行轮廓线动态规划，维护**轮廓线上的**插头信息，叫做插头 DP。

<img src="https://images0.cnblogs.com/i/660613/201408/071804008811884.jpg" style="zoom:100%">

<center>图中蓝线为轮廓线</center>

需要注意的是，插头 DP 的插头并不表示将要去某处的虚拟状态，而是表示已经到达某处的现实状态。这也就意味着，轮廓线上方是已决策完的格子，下方是未决策的格子。

##### 2. 实现 

我们把轮廓线作为动态规划的状态进行转移。**逐*格*递推，按照从上到下，从左到右的顺序依次考虑每一格**。递推时，要根据左边上边的插头情况来递推右边下边的插头。

<img src="https://img-blog.csdn.net/20140727145327113" style="zoom:100%">

##### 3. e.g. [HDU 1693 Eat the Trees](https://cn.vjudge.net/problem/HDU-1693)

###### 题目大意

在一个 $n \times m$ 的棋盘上（$n, m \le 11$），有的格子有障碍。现在要构造**一条或多条**哈密顿回路使得回路经过所有没有障碍的格子（不能经过有障碍的格子），求构造的方案数。

###### 解决方法

因为插头 DP 特别恶心，所以我就直接说怎么做了。

由于我们是**逐格递推**，因此我们设 $f_{i, j, S}$ 表示当前正在计算（已经计算）的格子为 $(i, j)$，轮廓线的状态为 $S$ 时的方案总数。（怎么表示轮廓线的状态？我们一会儿再说）

这道题只要求我们走的是回路，没有其它限制，因此我们用一个二进制数来表示轮廓线上的每一段是否有插头。设 $0$ 表示没有插头，$1$ 表示有插头。**这里我们规定：回路至少由四个格子组成**。

###### 边界情况

<img src="pic/轮廓线动态规划 1.png" style="zoom:100%">

<center>粗线表示轮廓线，虚线表示第 $0$ 列，加亮表示正在处理的格子</center>

显然边界情况为 $f_{1, 0, 0} = 1$。

###### 行间转移

当我们从一行的最后一个格子走到下一行的第一个格子时，观察一下轮廓线的变化。

<img src="pic/轮廓线动态规划 2.png" style="zoom:100%">

<center>某一行最后一个格子的轮廓线</center>

<img src="pic/轮廓线动态规划 3.png" style="zoom:100%">

<center>到下一个格子——下一行的第 $0$ 个格子时的轮廓线</center>

现在我们规定：将每段轮廓线从左至右从 $0$ 开始编号，则从左至右它们的编号分别为 $0 \sim m$。观察发现，行间转移实际上是抛弃了标号为 $m$ 的轮廓线，让标号为 $0 \sim m - 1$ 的轮廓线的标号加 $1$，再加上一个标号为 $0$ 的轮廓线。

对**本题**而言，上一行的最后一段轮廓线显然不能有插头；而下一行的第一段轮廓线也不能有插头，所以行间转移为：
$$
f_{i, 0, S << 1} = f_{i - 1, m, S} \pod {0 \le S < 2^m}
$$

###### 行内转移

显然我们对障碍格的处理方法与其它格子不一样，我们先考虑如何处理障碍格。

<img src="pic/轮廓线动态规划 4.png" style="zoom:100%">

<center>当前正在处理蓝色格子（一个障碍格），轮廓线从橙色变到黑色</center>

显然根据状态的定义，蓝色的格子相邻的轮廓线都不能有插头：你既不能走进去，也不能从里面走出来。所以，如果上一个状态的橙色部分有插头，那么当前状态的值就为 $0$；如果没有插头，当前状态的答案就等于上一个状态的答案。

不难发现时间复杂度为 $O(1)$。

------

如果当前格子不是障碍格，情况就要稍微复杂些。

1. 在上一个状态中的轮廓线上，当前格的上面和左面都没有插头。（简称为当前格没有上插头和左插头）

<img src="pic/轮廓线动态规划 5.png" style="zoom:75%">

<center>由于我们要形成回路，因此一个格子必须有两条边有插头，这是唯一的构造方案</center>

实现上，只需要把这两端轮廓线从 $0$ 改成 $1$ 即可。

2. 当前格既有上插头又有左插头。

<img src="pic/轮廓线动态规划 6.png" style="zoom:75%">

<center>同理，我们要让恰好两条边有插头，所以新的状态不能有插头</center>

3. 当前格有一个上插头或一个左插头。

   根据上面两种情况的图，这里就很容易理解了：我们要恰好两个插头，现在有一个插头了，所以枚举是向右走还是向下走进行转移即可。

------

不难发现，所有转移的时间复杂度均为 $O(1)$，所以算法的总时间复杂度为 $O(2^{m}nm)$。

最终答案为 $f_{n, m, 0}$，因为显然最后的轮廓线上不能有插头。

需要注意的是，**每次转移时还要检查新的插头是否合法，即不能插到棋盘外或者插到障碍物里**。这道题由于代码实现的特殊性，不检查也是能够通过的，但实际上必须检查。

###### 参考代码

```c++
// 见 "Source Code\动态规划"
```

注意仔细检查轮廓线的转移是否正确。就这道题而言，代码还是很好写的。在转移部分，虽然有些条件下代码完全一样，但我没有简化代码，而是分成四种情况讨论，目的是使思路更清晰。

##### 4. e.g. [URAL 1519 Formula 1](https://cn.vjudge.net/problem/URAL-1519)

###### 题目大意

在一个 $n \times m$ 的棋盘上（$n, m \le 12$），有的格子有障碍。现在要构造**一条**哈密顿回路使得回路经过所有没有障碍的格子（不能经过有障碍的格子），求构造的方案数。

###### 解决方法

很容易想到套用上一题的思路，但直接复制上一题的代码将会遇到这个问题：

<img src="https://images2017.cnblogs.com/blog/1181169/201708/1181169-20170809200427183-743451724.png" style="zoom:100%">

<center>这种情况不能算进答案</center>

换句话说，我们要让所有的插头都在同一连通块。一个显然的思路是，对所有的连通块标号，用插头所属的连通块标号来表示状态。

------

-   最小表示法

    最小表示法是**一种标号方法**。我们把第一个非障碍格子以及与它连通的所有格子标记为 $1$，然后再找第一个未标记的非障碍格子，将它以及与它连通的格子标号为 $2$……像这样标号，直到所有非障碍格子被标号。这种标号方式被称为*最小表示法*。

&emsp;&emsp;我们这样表示状态：如果一段轮廓线上有下插头，我们就用插头所在的格子的编号作为对应位的状态，否则用 $0$ 表示状态。

注意到，因为 $m \le 12$，所以最多有 $\frac {m} {2} = 6$ 个连通块，我们需要用一个 $12$ 位的 $7$ 进制数表示状态。显然的是，只有极少部分状态是有效的，所以这么做是可行的，只不过需要哈希表。由于~~太难了我不会~~有更好的方法，这里暂时不说怎么做。

------

-   括号序列法

    注意到这么一个事实：由于我们要构造环路，因此**任意时刻每条没有封闭的路径都有两个插头**。对于从左至右的 $4$ 个插头 $a, b, c, d$，如果 $a, c$ 在同一连通块（属于同一路径），那么 $b, d$ 不可能在同一连通块。如果 $b, d$ 在同一连通块，那么 $a, c$ 和 $b, d$ 的路径必然会相交，但路径相交这种事情是不可能发生的~~，这辈子都不可能发生的~~。

    对于一条路径对应的两个插头，我们称左边的那个为左插头，称右边的那个为右插头。则左右插头的排布呈括号序列的形式。

    我们这样表示状态：如果一段轮廓线上有左插头，我们就用 $1$ 表示；如果有右插头，就用 $2$ 表示；否则用 $0$ 表示状态。

&emsp;&emsp;现在我们使用括号序列法表示状态，考虑如何转移。

------

沿用之前的思路，我们使用上一个状态的插头信息来判断可以转移到哪些状态。由于现在每段轮廓线有 $3$ 种状态，所以理论上我们需要考虑 $9$ 种情况。

我们设左插头的状态为 $l$，上插头的状态为 $u$，下插头为 $d$，右插头为 $r$。

0.  行间转移

    因为要求构造的是环路，因此与上一题完全一样。

1.  $l = 0$，$u = 0$

    由于我们要构造环路，且每个方格都要经过，因此每个方格有且仅有两个插头，因此转移到 $d = 1$，$r = 2$（观察路径形状，显然下插头是左括号插头，右插头是右括号插头）。

2.  $l = 0$，$u = 1$

    可以转移到 $d = 1$，$r = 0$ 或 $d = 0$，$r = 1$。

3.  $l = 0$，$u = 2$

    可以转移到 $d = 2$，$r = 0$ 或 $d = 0$，$r = 2$。

4.  $l = 1$，$u = 0$

    可以转移到 $d = 1$，$r = 0$ 或 $d = 0$，$r = 1$。

5.  $l = 1$，$u = 1$

    这种情况需要**把两个左插头相连**，然后把上插头**对应的**右括号插头改成左括号插头。

<img src="pic/轮廓线动态规划 7.png" style="zoom:40%">

转移到 $d = 0$，$r = 0$，并修改那个插头。注意，并不是遇到的第一个右括号插头，而是对应的右括号插头，需要用变量记录当前有多少个左括号，当左括号数量**首次**为 $0$ 时方可进行转移。

6.  $l = 1$，$u = 2$

    现在已经有两个插头了，而我们只能构成一条回路，因此只有在**最后一个非障碍格（并不是右下角，右下角可能有障碍）**时能够转移到 $d = 0$，$r = 0$，其它时候不能转移。

<img src="pic/轮廓线动态规划 8.png" style="zoom:40%">

<center>这种转移只能在**最后一个非障碍格**进行，其它地方进行是会导致答案非法的</center>

7.  $l = 2$，$u = 0$

    转移到 $d = 2$，$r = 0$ 或 $d = 0$，$r = 2$。

8.  $l = 2$，$u = 1$

    直接转移到 $d = 0$，$r = 0$。

<img src="pic/轮廓线动态规划 9.png" style="zoom:40%">

9.  $l = 2$，$u = 2$

    把**两个右插头相连**，然后把左插头**对应**的左括号插头改成右括号插头。

<img src="pic/轮廓线动态规划 10.png" style="zoom:40%">

转移到 $d = 0$，$r = 0$，并修改那个插头。注意，并不是遇到的第一个左括号插头，而是对应的右括号插头，需要用变量记录当前有多少个右括号，当右括号数量**首次**为 $0$ 时方可进行转移。

------

同样设 $f_{i, j, S}$ 即可，其中 $S$ 是一个 $m + 1$ 位的三进制数，时间复杂度 $O(3^{m} nm^2)$（多了个 $m$ 是因为需要找到某个插头）。边界条件同样为 $f_{1, 0, 0} = 1$，最终答案同样为 $f_{n, m, 0}$。

显然直接写会爆炸。显然，有效的状态数是很少的，自然可以使用哈希表保存状态，同时使用滚动数组进行优化。这成功解决了空间问题，但是时间问题似乎并没有解决，我们还是要依次检查每个状态，花去 $O(3^m)$ 的时间。

解决方法是让哈希表支持遍历。只需要在插入元素时额外维护有哪些元素即可。另外，我们不用三进制，而用四进制。这样可以进行位运算，提高效率。另外，**这样做保证了我们是从合法状态转移而来的，但这也同时意味着我们要计算的状态必须合法，所以我们必须检查新的插头是否合法**。

###### 参考代码

```c++
// 见 "Source Code\动态规划"
```

在转移部分，虽然有些条件下代码完全一样，但我没有简化代码，而是分成九种情况讨论，目的是使思路更清晰。

##### 5. e.g. [Luogu 3190 [HNOI 2007] 神奇游乐园](https://www.luogu.org/problemnew/show/P3190)

###### 题目大意

在 $n \times m$ 的棋盘上，每个格子有一个权值（范围为 $[-1000, 1000]$）。现在要构造一条回路使得权值之和最大。求最大权值，保证不会溢出。

满足 $2 \le n \le 100$，$2 \le m \le 6$。

###### 解决方法

这道题在一个窄棋盘上进行操作，并且是对回路进行的操作，显然要用插头 DP。相比前面两道题，这道题有两点不同：

1.  这是道最优化问题。
2.  不一定要经过所有格子。

&emsp;&emsp;那么这道题能够如法炮制吗？我们来试试。

------

设 $f_{i, j, S}$ 表示正在 $(i, j)$，当前的轮廓线状态为 $S$ 时的最大权值之和。由于这道题要求只能有一条回路，因此我们用括号匹配法。

0.  行间转移

    因为要求构造的是环路，因此与上一题完全一样。

1.  $l = 0$，$u = 0$

    可以转移到 $d = 1$，$r = 2$，**也可以转移到 $d = 0$，$r = 0$，表示不经过这个格子**。

2.  $l = 0$，$u = 1$

    与上一题完全一样。

3.  $l = 0$，$u = 2$

    与上一题完全一样。

4.  $l = 1$，$u = 0$

    与上一题完全一样。

5.  $l = 1$，$u = 1$

    与上一题完全一样。

6.  $l = 1$，$u = 2$

    现在已经有两个插头了，而我们只能构成一条回路，因此只有在**没有其它插头时**能够**统计答案**，其它任何时候不能统计答案。并且，由于在这个状态下进行转移就意味着出现了一条新的回路，而我们只能有一条回路，因此**这个状态不能转移到任何其它状态**。

7.  $l = 2$，$u = 0$

    与上一题完全一样。

8.  $l = 2$，$u = 1$

    与上一题完全一样。

9.  $l = 2$，$u = 2$

    与上一题完全一样。

------

&emsp;&emsp;发现，这道题的两点不同已经在转移中体现出来了，所以照做即可。

###### 参考代码

```c++
// 见 "Source Code\动态规划"
```

有几点需要注意的地方：

1.  这道题的答案不能用状态来表示，因为我们的状态指的是**在 $(i, j)$，轮廓线状态为 $S$ 时，*且所有路径都有插头在轮廓线上时*的最大答案**，如果我们在封口那里进行了转移，那就可能有很多回路，不符题意，因此只能通过不转移的方法来保证最终只有一条回路。这也就意味着**没有任何状态表示一条回路**。
2.  不同于计数问题，最优化问题的状态值默认要赋成极小值，不要忘了。
3.  在合并插头时循环不要写错了。

##### 6. e.g. [BZOJ 2310 神奇的游乐园 II](https://www.lydsy.com/JudgeOnline/problem.php?id=2310)（权限题）

###### 题目大意

在 $n \times m$ 的棋盘上，每个格子有一个权值。现在要构造一条**简单路径**使得权值之和最大。求最大权值，保证不会溢出。注意一个点也算一条路径。

满足 $n \le 100$，$m \le 8$。

###### 解决方法

注意我们前面是如何保证回路这一限制条件的。我们实际上是通过规定从哪个状态转移到哪个状态来做到保证最终答案是回路的。

现在我们仍然使用插头 DP。由于要求只能有一条路径，我们自然会想到使用括号表示法——这是我们一开始解决只能有一条回路的办法。但是问题立即就出现了：括号表示法的基础是每条已有的路径在轮廓线上都有两个插头，而这个条件的基础是我们要构造的是回路。现在我们构造的不是回路了，那怎么办呢？

由于一条路径只有两个端点，因此在轮廓线上它要么有一个端点，要么有两个端点（没有端点的在本题中不合法，就不考虑了）。我们可以分两类讨论：**对于有两个端点的，我们仍然用括号序列法来表示；对于只有一个端点的，我们单独用一种新的插头来表示**。

现在我们用一个四进制数表示一段轮廓线上的插头：$0$ 表示没有插头，$1$ 表示左括号插头，$2$ 表示右括号插头，$3$ 表示*独立插头*。理论上，我们要分 $4 \times 4$ 种情况讨论，而且每种情况的转移数比之前更多，实际上的确如此。这就是为什么我[一开始](#解决方法)说插头 DP 特别恶心了。

------

有缘再学了……

# 习题

##### [Tsinsen D491 阵](http://lk.hhwdd.com/new/D491)

###### 题目大意

求 $n \times m$ 的 $0/1$ 网格中 $0$（黑块）没有公共边而所有 $1$（白块）连成一个四连通块的方案数。    

$n \le 11$，$m \le 10^9$。

###### 解决方法

如果你什么都不会，那就考虑一下 Special Instance。当 $n = 2$ 时，每一列要么不放黑块，要么放 $1$ 个黑块，并且上一列不能放黑块。这样我们很容易就得到一个 $O(m)$ 的递推做法（原题当 $n = 2$ 时，$m \le 20000$，暂时不用矩阵快速幂）。

------

与骨牌覆盖问题进行类比，我们很容易想到用一个二进制集合来表示每一位的颜色，作为状态进行转移。然而问题来了：只保存每一位的颜色并不能保证最后白色块是连通的，而且这个信息似乎不好维护（不能像前面插头 DP 那样用*括号序列法*了），怎么办呢？

既然要维护连通信息，那就自然想到前面插头 DP 没有用到的*最小表示法*。

对于一行确定的 $0/1$，我们首先判断它是否满足没有黑块相邻的情况，然后我们枚举每块白块的标号。特别地，若一个白块的左边是一个白块，那么它的标号必须和它左边的白块的标号一样，因为它们肯定是在同一连通块内的。类似于前面的骨牌覆盖，我们就能搜索出所有的状态。

我们还要想办法得到所有的转移。注意到，如果上一列的连通状态已经确定，那么只要知道了下一列每个格子是白块还是黑块就能判断是否合法，并且知道下一列的连通状态。现在的问题是如何计算这个连通状态。我们考虑用并查集，**以标号相同的连通块为单位进行处理（这意味着我们需要先对新的状态临时标一个号）**，然后让新的状态每一个连续的连通块的标号等于它在并查集中的根，最后在用最小表示法重编号即可。注意，得到的状态一定在之前预处理得到的状态中出现过，不然就说明你写错了。
