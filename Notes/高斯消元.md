[TOC]

# 高斯消元

#### 高斯消元（1）

&emsp;&emsp;假设你已经会了矩阵的最最最基本的概念，矩阵加法，矩阵乘法，矩阵的运算律，方阵，单位矩阵，转置矩阵。

[参考资料](https://www.cnblogs.com/candy99/p/6653743.html)

##### 1. 概念

&emsp;&emsp;高斯消元（Gaussian elimination）是求解线性方程组的方法。在学习它之前我们先介绍一些概念。

###### ①矩阵

&emsp;&emsp;（1）可以用一个方阵乘以一个列向量表示一个线性方程组。
$$
\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1k} \\ 
a_{21} & a_{22} & \cdots & a_{2k} \\
\vdots & \vdots & \ddots & \vdots \\
a_{k1} & a_{k2} & \cdots & a_{kk}
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2 \\ \vdots \\ x_k
\end{bmatrix}
=
\begin{bmatrix}
b_1 \\ b_2 \\ \vdots \\ b_k
\end{bmatrix}
$$
&emsp;&emsp;（2）逆矩阵

&emsp;&emsp;**某些** n 阶**方阵** $A$ 中，存在**唯一**逆元 $A^{-1}$ 使得 $A × A^{-1} = A^{-1} × A = I_n$，其中 $I_n$ 是 n 阶单位矩阵（identity matrix）。

&emsp;&emsp;矩阵可逆有一个常用的充要条件：所有行向量都是线性无关的。线性无关的意思是：任何一个向量都不能通过其它向量的线性组合得到。

&emsp;&emsp;如果我们知道了 $A$ 的逆矩阵 $A^{-1}$，我们就能求解方程组 $Ax = b$。两边同时**左乘**一个 $A^{-1}$ 得到 $x = A^{-1} b$。所以当 $A^{-1}$ 不存在时，方程组 $Ax = b$ **无解或有无穷多解**。

###### ②高斯消元中的矩阵

&emsp;&emsp;（1）增广矩阵
$$
\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1k} & b_1 \\ 
a_{21} & a_{22} & \cdots & a_{2k} & b_2 \\
\vdots & \vdots & \ddots & \vdots & \vdots\\
a_{k1} & a{k2} & \cdots & a_{kk} & b_k
\end{bmatrix}
$$
&emsp;&emsp;以上矩阵被称为增广矩阵。即系数矩阵[^系数矩阵]加上一列**常数**。

[^系数矩阵]: 就是上文中用于表示线性方程组的方阵 $A$。

&emsp;&emsp;（2）矩阵的初等行变换

&emsp;&emsp;包含以下三个操作：

&emsp;&emsp;&emsp;&emsp;①交换两行。

&emsp;&emsp;&emsp;&emsp;②给一行中的所有数乘上一个非零数。

&emsp;&emsp;&emsp;&emsp;③把一行的倍数加到另一行上。

##### 2. 步骤

&emsp;&emsp;从上至下依次处理每一行，处理完第 $i$ 行后，让 $A_{ii}$ 非零，而 $A_{ji} \pod {j > i}$ 均为 $0$。（$0$ 用空白表示）
$$
\begin{bmatrix}
2 & 1 & -1 & 8 \\ 
-3 & -1 & 2 & -11 \\
-2 & 1 & 2 & -3
\end{bmatrix}
\to
\begin{bmatrix}
-3 & -1 & 2 & -11 \\ 
 & \dfrac {1} {3} & \dfrac {1} {3} & \dfrac {2} {3} \\
 & \dfrac {5} {3} & \dfrac {2} {3} & \dfrac {13} {3}
\end{bmatrix}
\to
\begin{bmatrix}
-3 & -1 & 2 & -11 \\ 
 & \dfrac {5} {3} & \dfrac {2} {3} & \dfrac {13} {3} \\
 &  & \dfrac {1} {5} & -\dfrac {1} {5}
\end{bmatrix}
$$
&emsp;&emsp;注意：虽然这里说是从上至下，但是**这个例子以及实践中**并非如此。

&emsp;&emsp;实际过程中， 假设正在处理第 $i$ 行，则首先需要找一个 $r \ge i$ 且绝对值最大的 $a_{ri}$，然后交换第 $r$ 行和第 $i$ 行。**即在第几行就在第几列找一个未处理的最大的，有助于提高数值稳定性[^数值稳定性]。**

&emsp;&emsp;然后是加减消元。一般情况下，如果要用第 $i$ 个方程来消去第 $k$ 个方程的第 $i$ 列，那么第 $k$ 行的**所有元素** $A_{kj}$ 都应该减去 $A_{ij}$ 的 $\dfrac {a_{ki}} {a_{ii}}$ 倍。

&emsp;&emsp;下一步是回代。现在 $A$ 是一个上三角矩阵。这样，就相当于告诉了我们 $x_n$ 的值，然后一步一步往上代入求解 $x_i$ 即可。

[^数值稳定性]: 可以把数值稳定性理解成算法的精确性与正确性，具体点就是浮点误差。

&emsp;&emsp;**以上为最基本的步骤和思路，可以发现有交换行，加减消元和回代这三个步骤，其中前两个步骤可以归纳为加减消元。**

&emsp;&emsp;算法的时间复杂度为 $O(n^3)$。

##### 3. 问题

&emsp;&emsp;为了得到第 $k$ 行的消元比例，我们可以令 $f = \dfrac {A_{ki}} {A_{ii}}$，但可能会有精度问题，这个时候不定义临时变量直接计算会有点效果。但是必须保证最后才算 $A_{ki}$，所以要倒着枚举：

```c++
for(int k = i + 1; k < n; k++)
{
	// 第 i 行乘以一个系数后再用第 k 行去减去第 i 行，使 a[k][i] 为 0
	for(int j = n; j >= i; j--) // 倒着枚举 j
		a[k][j] -= a[k][i] / a[i][i] * a[i][j];
}
```

&emsp;&emsp;**至此，最最最最基本的高斯消元就讲完了，但是还有很多问题……**

##### 4. 解的判断

&emsp;&emsp;一般情况下，消元过程的目标是在解不变的情况下把系数矩阵 $A$ 变成一个阶梯矩阵（Row Echelon Form，REF）。也就是说，除第一行外，每一行最左边的非 $0$ 元素在上一行最左边的非 $0$ 元素的右边。

&emsp;&emsp;在回代之前，我们便能判断解的情况。如果方程组无解，我们将得到至少一个系数全为 $0$，常数不为 $0$ 的行[^矛盾方程]；如果方程组无穷多解，我们将得到至少一个系数和常数全为 0 的行。

&emsp;&emsp;如果我们**只用判断没有唯一解**，在实现上我们可以这么做：若在操作第 i 行时发现未处理的行中第 i 列全是 0，那么就说明不存在唯一解。

[^矛盾方程]: 称这一行对应的方程为**矛盾方程**。

##### 5. 自由元

&emsp;&emsp;当线性方程组有无穷多解时，有些变量可以任意取值，我们称这些变量为自由元。**自由元集合的并不是确定的，但是自由元的数量是确定的。**

&emsp;&emsp;结合判断解的方法，我们有如下定义：设消元后矩阵有 $r$ 个非 $0$ 行，且不存在矛盾方程，则一共有 $r$ 个非自由变量，即**有界变量**。这个 $r$ 称为系数矩阵的**秩（rank）**。

##### 6. 参考代码

```c++
bool gauss()
{
    for(int i = 0; i < n; i++)
    {
        // 先交换
        INT r = i;
        for(int j = i + 1; j < n; j++)
        {
            if(std::abs(a[j][i]) > std::abs(a[r][i]))
                r = j;
        }
        if(r != i)
            for(int j = 0; j < n + 1; j++)
                std::swap(a[i][j], a[r][j]);
        if(a[i][i] == 0) return false;

        for(int k = i + 1; k < n; k++)
        {
            // 第 i 行乘以一个系数后再用第 k 行去减去第 i 行，使 a[k][i] 为 0
            for(int j = n; j >= i; j--)
                a[k][j] -= a[k][i] / a[i][i] * a[i][j];
        }
    }
    // 回代，把解保存在 a[i][n] 中
    for(int i = n - 1; i >= 0; i--)
    {
        for(int j = i + 1; j < n; j++)
            a[i][n] -= a[j][n] * a[i][j];
        a[i][n] /= a[i][i];
    }
    return true;
}
```

#### 高斯消元（2）

##### 1. 循环矩阵

&emsp;&emsp;若矩阵的第 $i$ 行（$i > 1$）是由第 $i - 1$ 行循环左移或循环右移得来的，我们称这种矩阵为循环矩阵。

&emsp;&emsp;**两个循环矩阵的乘积仍然是循环矩阵。**因此，可以只对循环矩阵的第一行做乘法操作，从而使时间复杂度减少一个 $n$。

##### 2. 高斯-约当消元

&emsp;&emsp;有时候，我们可能令无解的方程有一个解为 $\inf$。这会使回代过程产生困难。一个方法是高斯-约当消元，它是高斯消元的一种变形，特点是只需要消元，不需要回代。但计算量略大于高斯消元。

###### ①步骤

&emsp;&emsp;还是一行一行地处理，处理第 $i$ 行时在第 $i$ 列中选未处理的行中绝对值最大的为主元。**如果找不到，说明这是一个自由元。**

&emsp;&emsp;确定主元后，通过矩阵初等行变换使主元为 $1$[^主元]，然后用这一行去给其它所有行消元，使主元所在列的除主元外的都为 $0$。

&emsp;&emsp;最后我们得到一个单位矩阵，其解就在常数矩阵中。

[^主元]: 这一步可以不做，等到最后算解时再做。

###### ②用途

&emsp;&emsp;（1）避免回代的求解线性方程组。

&emsp;&emsp;（2）求逆矩阵。只需要一开始在系数矩阵右边放上一个单位矩阵，然后照样操作。当系数矩阵化为单位矩阵时右边的增广部分就是原系数矩阵的逆矩阵了。

##### 3. 参考代码

```c++
bool gauss_jordan()
{
    for(int i = 0; i < n; i++)
    {
        INT r = i;
        for(int j = i + 1; j < n; j++)
            if(std::abs(a[j][i]) > std::abs(a[r][i]))
                r = j;
        if(a[r][i] == double(0)) return false;
        if(r != i)
            for(int j = 0; j <= n; j++)
                std::swap(a[i][j], a[r][j]);
        
        for(int j = 0; j <= n; j++)
            if(j != i)
                a[i][j] /= a[i][i];
        a[i][i] = 1;

        for(int j = 0; j < n; j++)
        {
            if(j == i) continue;
            for(int k = n; k >= i; k--)
                a[j][k] -= a[j][i] * a[i][k];
        }
    }
    return true;
}
```

##### 4. xor 方程组

&emsp;&emsp;xor 方程组的消元方法与高斯消元不同的是，只需要任意找一个为 $1$ 的作主元，而不必绝对值最大的（因为不是 $0$ 就是 $1$）。消元时，只需要做 xor 即可，用主元所在行的每个元素去异或需要消元的剩余行的对应元素。

&emsp;&emsp;可以使用压位优化。