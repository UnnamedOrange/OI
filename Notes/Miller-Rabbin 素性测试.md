[TOC]

# Miller-Rabbin 素性测试

>   ​	很多地方都把这个算法扯个半天也没扯出个什么名堂，今天在这里就让我来终结这些坑爹玩意儿。
>
>   ​	这里假设你知道最基本的费马小定理。
>
>   ​	许多地方的 “$= x$”，“$\ne x$”，“为 $x$” 等，表示的是在模意义下的情况，请仔细思考。



##### 1. 判断素数的暴力方法

​	①定义法：2 ~ n - 1，时间复杂度 $O(n)$。

​	②试除法：2 ~ $\sqrt {n}$，时间复杂度 $O(\sqrt {n})$。

​	以上方法对于 long long 范围的数据无能为力。

##### 2. 费马素性测试

​	对于素数 $p$ 和任意小于 $p$ 的整数 $a$，有 $a^p ≡ a(mod \, p)$。==反过来，当 $a^p ≡ a(mod \, p)$ 时，**$p$ 却有 $\dfrac {1} {4}$ 的几率不是素数。**==

​	当用多个数 $a$ 用这个方法去检验 $p$ 是否为质数时，正确的概率大大增加。理论上，若用 $k$ 个数去检查，错误的概率将为 $(\frac {1} {4}) ^ k$。

​	**不幸的是，仍然有一些数，被称为 ==Carmichael 数==，它们能通过所有的费马小定理的检测。**而且最小的 Carmichael 数仅为 561；小于等于 10 亿（$10^9$）的数中也有 600 个之多。==所以仅使用费马素性测试是**不正确的**。==

##### 3. 二次探测定理

​	这是一个这样的定理：对于素数 $p$ 和**任意小于 $p$ 的整数 $a$**，且 $a^2 ≡ 1(mod \, p)$，那么 $a$ 要么为 1，要么为 -1，且只能为这两个数。

​	简单证明一下。可知 $(a + 1)(a - 1) ≡ 0(mod \, p)$，**即 $(a + 1)(a - 1)$ 整除 $p$。**==由于 $p$ 是素数，所以不存在两个大于 1 小于 $p$ 的数的积满足上式，所以 $a + 1 ≡ 0(mod \, p)$ 或 $a - 1 ≡ 0(mod \, p)$，即 $a ≡ 1(mod \, p)$ 或 $a ≡ p - 1(mod \, p)$。如果我们知道了 $a$ 既不是 1 也不是 $p - 1$，那么我们就可以说，$a$ 一定不是质数。==

​	==注意到，若 $a ≡ 1(mod \, p)$，且假设 $a$ 可以表示成一个完全平方数，那么我们可以继续进行二次探测。==

##### 4. Miller-Rabin 素性测试

​	==把费马素性测试和二次探测定理结合起来，就得到了 Miller-Rabin 素性测试。==设要检查的数为 ==$n$==。

######①基本步骤

​	首先用费马小定理检查 $a^{n - 1} $ 在模 $n$ 意义下是否同余 1。若不，那么 $n$ 一定不是质数。

​	==$n - 1$ 一定为偶数，设 $r = a^{\frac {n - 1}{2}}$ 。==我们可以知道，$r^2 ≡ 1(mod \, p)$。此时可以用二次探测定理，检查 $p$ 是否为素数。

​	如果我们得到 $r = -1$[^ 1 ]，那么我们就没有什么好检测的了，可以得出 $n$ 可能为素数；如果 $r = 1$，且 $\frac {n - 1} {2}$ 仍然为偶数，我们可以令 $r' = a^{\frac {n - 1} {4}}$ 继续进行二次探测；若 $\frac {n - 1} {2}$ 不是偶数，我们就无法继续二次探测，也可以得出 $n$ 可能为素数的结论。如果 $r \ne ±1$，那么 $n$ 一定不是素数。

​	用不同的 $a​$ 检查多次后，我们就能得出 $n​$ 是否为素数。

[^ 1 ]: 为了简便，就不写同余符号了。用等号代替同余符号。

######②a 的选取

​	如果被测数小于 2047，只需要用一个 2 就可以了。像这样不能通过 $a = 2$ 时的 Miller-Rabin 素数测试的数被称为==以 2 为底的强伪素数==。

​	如果被测数小于 1373653（==$10^6$==），只需要用 2 和 3。

​	如果被测数小于 4759123141 （==unsigned int==），只需要用 2， 7 和 61。

​	如果被测数小于 341550071728320 （$10^{14}$），用前 7 个素数 2，3，5，7，11，13，17。

​	==**对于所有的 $a$，我们都要特判一下，判断待测数是否等于 $a$， 是否是 $a$ 的倍数。另外，也要特判偶数和小于 2 的数的情况。**==

######③实际操作

​	实际上，我们在二次探测时不必从大到小迭代，而是可以先将 $n - 1$ 分解成 $2^k × r$ 的形式。[^ 2 ]

​	首先判断 $r$。 可知，只要 $a^r$ 是 1 或者 -1 就说明了 $a$ 可能是素数。**注意，$k$ 肯定是大于等于 1 的，否则 $n$ 就是一个偶数。**由于 1 或者 -1 的平方肯定是 1，最终能够满足费马小定理，也满足了二次探测定理，所以可以得出 $n$ 可能是素数的结论。

​	然后每次计算 $x = (a^{r})^{2}$。==若 $x = -1$ **且指数不等于 $n - 1$**，说明我们正好到了从大到小迭代的出口，最终也能够通过费马素性测试，$n$ 可能是质数。但如果 $x = 1$，**反而说明 $n$ 不是质数**，因为这就说明了 $(a^{r})^{2} ≡ 1(mod \, n)$ 的一个解 $a^r \ne ±1$，哪怕它通过了费马素性测试，也不满足二次探测定理。==

​	==**最后，如果我们还没有退出，那它连费马素性测试也没有通过，所以一定不是质数。**==

[^ 2 ]: 这个地方是实际的更方便快速的做法，真正的原理在上文！

###### ④乘法

​	毫无疑问，对于大数，我们是需要做 long long 之间的乘法的。以下为==快速乘法==，可以防止大数乘法的溢出。取名为快速乘法只是因为它跟快速幂长得像，==它的时间复杂度反而是 $O(\log n)$ 的。==

```c++
ULL mul(ULL x, ULL y, ULL mod)
{
	ULL ret = 0;
	while(y)
    {
		if(y & 1) ret = (ret + x) % mod;
		x = (x + x) % mod;
		y >>= 1;
	}
	return ret;
}
```
##### 5. 时间复杂度分析

​	对于一个数 $n$，我们要做快速幂，因此最基本的时间复杂度为 $O(k \log n)$，$k$ 为测试次数。

​	如果我们必须要使用快速乘法，那么时间复杂度将会是 $O(k \log^2 n)$。

##### 6. 参考代码

```c++
typedef unsigned long long ULL;
bool check(ULL n, ULL a)
{
	ULL r = n - 1;
	ULL c2 = 0;
	while(!(r & 1)
	{
		c2++;
		r >>= 1;
	}

	//ULL power(ULL x, ULL y, ULL mod);
	ULL x = power(a, r, n);
	if(x == 1 || x == n - 1) return true;
	while(c2--)
	{
		//ULL mul(ULL x, ULL y, ULL mod);
		x = mul(x, x, n);
		if(x == n - 1 && c2) return true;
	}
	return false;
}
bool Miller_Rabin(ULL n)
{
	if(n < 2) return false;
	else if(n == 2) return true;

	const ULL a[] = { 2, 7, 61 };
	ULL size = sizeof(a) / sizeof(ULL);
	for(int i = 0; i < size; i++)
	{
		if(n == a[i]) return true;
		else if(n % a[i] == 0) return false;
	}
	for(int i = 0; i < size; i++)
		if(!check(n, a[i])) return false;
	return true;
}
```