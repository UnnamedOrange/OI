[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 再谈 KMP 算法

##### 1. 问题定义

给定一个模板串，要求在一个字符串中找到模板串的位置。这又叫作字符串匹配问题。

##### 2. 原理

对朴素匹配进行改进。之前我们已经匹配了一些了，设匹配了 p 个。由于我们是知道模板串的，所以我们也就知道匹配串的情况，至少这 p 个我们是一清二楚的，所以有些地方不必一个一个地检查。开始以下一位为起点时，我们是知道已经匹配了多少位的，而不必像朴素算法一样重新开始。通过一些奇技淫巧，我们便能在线性时间复杂度里完成匹配。

##### 3. 失配函数 f

f 的物理意义是：模板串**长度为 i** 的前缀的“相同的前缀和后缀”（不包括本身）的**最大长度**。这样也就很好理解为什么可以快速匹配了：末尾失配了，开头的那一段好歹是一样的。保留个开头，再拿中间的那块去试试呗。

f 的匹配意义是：若在模板串已匹配的长度为 i 时失配，接下来应假设已匹配的长度为多少。通过这个定义，就能用 while 写出匹配函数了。

我们再来考虑如何求 f。我们假设要求 f[i + 1]，首先我们设 pre = f[i]，表示模板串 t[i]（注意这里 i 是第 i + 1 个，下标从 0 开始），然后看 t[i] 能否让后缀跟前缀一样。如果失败，我们就得尝试减少这个长度（f[i + 1]）。如图，注意图中有哪些部分是一样的。

![KMP 1](pic\KMP 1.png)

因此，可以说这个过程用到了动态规划的思维：利用先前求出来的最长长度判断，而不是暴力枚举。其均摊时间复杂度为 $O(n)$。

##### 4. 真正的 KMP 算法

上述算法其实只是 MP 算法，真正的 KMP 算法还要对失配函数进行优化。

![KMP 2](pic\KMP 2.png)

如上图，考虑 i = 14 的情况，此时正在计算 f[**15**]。考虑 f 的物理意义，按照 MP 算法可以得到 f[15] = 4。再考虑 f 的匹配意义，当已经匹配了 15 个字符，即正在考虑 t[**15**] 时失配，下一步应假设已匹配了多少个字符。不难得到答案应该是 4。但是，由于 t[15] = t[4] = a，**因此当 i = 15 时失配意味着在文本串的相同位置 i = 4 时也不会匹配。此时的情况是 t[i + 1] = t[f[i + 1]]。**

一个显然的解决办法是，遇到这种情况，就让 f[i + 1] = f[f[i + 1]]。**这样相当于抛弃了 f 的物理意义，我们就不能通过之前的方式用 f 递推 f 了。**考虑这个初始化的过程，这其实是一个自己匹配自己的过程，所以维护一个当前已匹配数 pre，就相当于有一个**原意义下的 f[i]。**

由于 f 的含义改变了，**因此不能写 f[f[i + 1]] 和 t[f[i + 1]]，而要写 f[pre] 和 t[pre]。**

新的模板如下：

```c++
INT fMP[maxn];
void initFailureMP()
{
	fMP[0] = -1;
	for (int i = 0; i < m; i++)
	{
		INT pre = fMP[i]; //这个 pre 事实上可以通过维护得到
		while (~pre && t[i] != t[pre]) pre = fMP[pre];
		pre++; //从 -1 开始避免了判断
		fMP[i + 1] = pre;
	}
}
INT fKMP[maxn];
void initFailureKMP()
{
	INT pre = fKMP[0] = -1;
	for (int i = 0; i < m; i++)
	{
		while (~pre && t[i] != t[pre]) pre = fKMP[pre];
		pre++;
		if (t[i + 1] == t[pre]) fKMP[i + 1] = fKMP[pre];
		else fKMP[i + 1] = pre;
	}
}

//...
	while (~cnt && str[i] != t[cnt]) cnt = fKMP[cnt];
	cnt++;
```

至于为什么不用 `while(t[i + 1] == t[pre])`，原因是**这其实是一个递推的过程，要用的之前的 f 已经是优化过的了。**