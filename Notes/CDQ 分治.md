[TOC]

# 从归并排序到 CDQ 分治

>   开局一个 Markdown，内容全靠编。——Orange

## Part 1 引入

##### 1. 归并排序

下面是一段众所周知的归并排序的代码：

```c++
int origin[maxn];
int temp[maxn];
void mergesort(int l, int r)
{
	if(l >= r) return;
	int mid = (l + r) >> 1;
	mergesort(l, mid); mergesort(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && origin[i] <= origin[j])) // <= for stable sort
			temp[k++] = origin[i++];
		else
			temp[k++] = origin[j++];
	}
	for(i = l; i <= r; i++)
		origin[i] = temp[i];
}
```

不同于快速排序，其最坏时间复杂度为 $O(n \log n)$，但是归并排序需要 $O(n)$ 的额外空间。

###### 归并排序能干什么

最广为人知的应用便是~~排序以及~~计算序列的逆序数。

对于序列 $\{ a_i \}$，如果存在两个正整数 $1 \le i < j \le n$ 且 $a_i > a_j$，则称 $a_i$ 与 $a_j$ 为一个逆序对。求逆序对个数最简单的方法莫过于枚举 $i$ 和 $j$ 了，但是这么做的时间复杂度是 $O(n^2)$ 的。归并排序能够在 $O(n \log n)$ 的时间复杂度内“顺便”完成这一操作。

```c++
// ...
		if (!(j <= r) || (i <= mid && origin[i] <= origin[j])) // note 
			temp[k++] = origin[i++];
		else
		{
			nInvPair += mid - i + 1;
			temp[k++] = origin[j++];
		}
```

注意上面的比较部分。在原始的归并排序中，既可以使用 `<` 也可以使用 `<=`，但是仅当使用 `<=` 时才有稳定排序的效果。而在求逆序数时，实际上我们是要**计算左边的序列对右边的序列的贡献**，对于右边的每个数，这个贡献就是左边**大于**自己的数的个数。上面的实现方式中，只能使用 `<=` 才保证计算的是大于自己的数的个数；**使用 `<` 时得到的是大于等于自己的数的个数，与题意不符。**

##### 2. 逆序数与权值树状数组

不难发现，**归并排序求逆序数是一种离线算法。**也就是说，我们需要先读入整个序列，才能求出这个序列的逆序数；如果不断地在序列尾部添加整数[^整数]以构成新的序列，那就只能使用权值树状数组求解。

[^整数]: 由于树状数组其实是一个数组，所以最原始的权值树状数组的权值在一定的正整数范围内；稍加修改能够使权值范围扩大到一定的整数范围。可见使用权值树状数组求解逆序数问题还是有相当大的局限性。

一般来说，这个问题还是不会要求用这种方式在线的（毕竟这个问题还是挺特殊的，不会把数插入到中间！），所以离散化原序列再结合权值树状数组求解是个不错的做法。由于这个算法本身比较经典，也不在我们的讨论范围内，所以就不再详细阐述它了。但是有一个十分有用的小技巧，用于清空权值树状数组：

```c++
struct BIT
{
	int c[maxk];
	inline int lowbit(int x);
	int add(int pos, int val);
	int query(int pos);
	void clear(int pos)
	{
		while(pos <= k)
		{
		    if(c[pos]) c[pos] = 0;
		    else break;
		    pos += lowbit(pos);
		}
	}
};
```

```c++
// ...
	for(int i = l; i <= r; i++) bit.add(a[i], 1);
	// do something
	for(int i = 1; i <= r; i++) bit.clear(a[i]);
```

当实际权值范围很小，数组却很大时，这种方法避免了直接使用 `memset` 导致的时间复杂度错误。

## Part 2 二维偏序问题

##### 1. 引例

给定一个长度为 $n$， 初始为空的序列 $\{ a_i \}$，给定 $m$ 个操作，操作分为两种：将某个位置的值修改为 $x$；查询 $\sum_{i = l}^{r} a_i$。$n \le 10^9$，$m \le 5 \times 10^5$，不要求在线。

###### 在线算法

尽管不要求在线，但是我们还是老老实实地用在线算法去做它。不难发现，无法使用树状数组去解决这个“树状数组裸题”，因为 $n$ 的范围太大。所以你决定写一个不知道能不能对（因为码力低下，可能超时，可能答案错误）的动态开点线段树。

###### 离线算法

以上思路明显不明智，既然可以离线，为什么不离线呢？离线并离散化后，这道题就是一道树状数组裸题，可以轻松解决。

逆序对问题既可以在离散化后使用树状数组求解，又可以采用“特殊”的归并排序求解。既然这个问题也能够使用树状数组加离散化求解，那这个问题为什么不能利用归并排序来求解呢？

这便是我们要研究的问题：如何使用类似于归并排序求逆序数的方法来解决更多问题。我们将在下面继续讨论。

##### 2. 二维偏序

###### ①偏序[^偏序]

[^偏序]: 这里不对偏序进行学术的研究，所以很多描述并不专业。

对于两个任意两个整数 $a$，$b$，我们能够知道它们一定满足以下三个关系之一：
$$
a < b
\\
a = b
\\
a > b
$$
像这样，对于一个可重集，如果其中的任意两个元素都能比较大小，那么我们称集合中的元素有**全序**关系。

对于两个任意的数对 $a = (x_a, y_a)$ 和 $b = (x_b, y_b)$，可以把它们画在坐标轴上：

<img src="pic\CDQ 分治 1.png" style="zoom:60%">

如果有 $x_a < x_b$ 且 $y_a < y_b$，那么可以记作 $a < b$，其几何意义也很明显。但是下面这种情况：

<img src="pic\CDQ 分治 2.png" style="zoom:60%">

这两个矩形不能够“互相包含”，因此我们也不能对它们进行比较。一般地，称上面这种关系为偏序关系，也就是说，在可重集中，并不是所有的元素都可以相互比较。

###### ②二维偏序问题

给定 $n$ 个数对 $(x, y)$（$n \le 5 \times 10^5$），请求出对于每个数对 $(x_a, y_a)$，有多少个其它数对 $(x_b, y_b)$ 满足 $x_b < x_a$ 且 $y_b < y_a$。

------

毫无疑问暴力是 $O(n^2)$ 的，无法解决这个问题，能不能有更好的方法呢？

一个很容易想到的思路是：如果我们按照 $x$ 从小到大的顺序处理，那只需要统计有多少个 $y$ 比自己的 $y$ 要小，这不就是个顺序对问题吗？

接下来，只需要使用树状数组即可。但与逆序对相似的，能否使用归并排序完成这个任务呢？

答案毫无疑问是肯定的，只需要稍微改变一下**左边区间对右边区间的贡献**即可。

------

实际上，逆序对问题可以看作一个二维偏序问题：给定数对 $(i, a_i)$，有多少个其它数对 $(j, a_j)$ 满足 $i < j$ 且 $a_i > a_j$。只不过 $i$ 是序列的下标，**是默认有序的**。这也给了我们一个启示：**可以先将第一维有序化，再考虑第二维**。

###### ③使用二维偏序模型解决引例

树状数组都能用……既然前面几个问题都是树状数组和归并排序均可解，为什么不试试归并排序呢？只不过这次需要排序的内容就很不明显了。

可以考虑这样去设一个**操作**：设操作 $(x, y)$，表示一个时间在 $x$ 的操作要查询/修改位置 $y$ 的内容。很明显，只有修改这个动作在前，才能影响后面的查询操作；将问题转化为前缀和问题后，只有当修改前部位置的值时，后部位置的前缀和才会发生改变。**这种有单方向且可比较的影响的问题，正是二维偏序模型可以解决的问题。**

首先对第一关键字排序，由于操作按顺序给出，所以就不用排序了。紧接着对第二维进行归并排序。当处理一个区间时，**我们只考虑左边的区间对右边的区间的影响。一是因为左边的区间的第一关键字一定是小于右边的区间的，**第二是因为左边对左边的贡献以及右边对右边的贡献已经在分治时计算完了。

怎么计算左边对右边的贡献呢？只需要保存一个变量代表**已经扫描的左边区间的操作影响总和**。另外，查询操作需要将区间拆成一前一后两个点考虑前缀和，这里不再赘述。

------

以上方法不受空间范围影响，不受偏序的限制。我们可以这样认为：**归并排序利用分治的特性（将问题简单化后再合并）降低了维度。**类似于这样的解决办法，我们称为 *CDQ 分治*，又称*对时间分治*。

## Part 3 利用 CDQ 分治解决三维偏序问题

##### 1. e.g. [BZOJ 3262 陌上花开](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)

###### 题目大意

给定 $n$ 个有序三元组 $(x_i, y_i, z_i)$ ，求出对于每个三元组 $a$，有多少个别的三元组 $b$ 满足 $x_a \ge x_b$，$y_a \ge y_b$ 且 $z_a \ge z_b$。

###### 思路

直接使用数据结构需要使用树套树：**对 $x$ 排序后**，用树状数组维护权值 $y$ 的前缀集合，里层再套一个平衡树查找 $z$。~~反正我不会写。~~

能否使用 CDQ 分治解决呢？对 $x$ 排序后，我们对 $y$ 进行归并排序，只考虑左边区间对右边区间的影响。怎么计算呢？只需要用一个树状数组维护就好了！

```c++
void cdq(int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1;
	cdq(l, mid); cdq(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && disc[i].y <= disc[j].y)) // note
		{
			bit.add(disc[i].z, disc[i].param); // note
			temp[k++] = disc[i++];
		}
		else
		{
			ans[disc[j].ansIdx] += bit.query(disc[j].z);
			temp[k++] = disc[j++];
		}
	}
	for (i = l; i <= r; i++)
		disc[i] = temp[i];
	for (i = l; i <= r; i++)
		bit.clear(disc[i].z); // note
}
```

没错，**利用类似于归并排序的东西计算我们想要的，就是所谓的 CDQ 分治**。尽管如此，还是有许多要注意的地方：

Q：树状数组清空不怕超时吗？

A：[前面](#2. 逆序数与权值树状数组)讲过了。

Q：一开始只用按照 $x$ 排序吗？

A：其实不是的。

CDQ 分治的核心，便是在归并排序中用左边的更新右边的，这有许多要求。首先，你要能够更新（你总得能够写出一个时间复杂度正确的代码吧……），换句话说，类似于线段树，维护的信息必须可合并才能够使用；对 CDQ 分治而言，维护的信息**一般要求可以差分**，如前缀和，可以把所有可能有贡献的数分开考虑贡献。

第二个要求是：**贡献必须满足单向关系**。什么意思呢？**我们需要保证右边的区间对左边的区间没有贡献**，因为我们从未去计算过它。如果它存在，我们又没有计算它，那不就是算漏了吗？

如果我们只对 $x$ 进行排序，那么有可能存在 $x$ 相同 $y$ 大的却在右边区间的情况，这种情况就会导致答案错误。所以**第一步**的排序必须对所有关键字进行排序，**保证右边的元素对左边的元素不可能有贡献**：

```c++
bool operator< (const Flower& b) const
{
    if (x != b.x) return x < b.x;
    else if (y != b.y) return y < b.y;
    return z < b.z;
}
```

Q：代码中的第一个 note 处，为什么必须写小于等于？

A：为了保证左边对右边的贡献计算完整，不会漏掉。

Q：为什么要进行离散化（disc(retize)）？

正如第二个问题中所说，**右边的元素对左边的元素不能有贡献，否则会算漏**。如果存在相同的元素，那么无论如何右边的元素都会对左边的元素有贡献的，所以必须离散化。

------

搞懂了上面几个问题后，我相信你已经完全理解 CDQ 分治了（~~只是做不来题~~）。但是 CDQ 分治还有更多应用。

Q：我不喜欢树状数组。

A：~~写线段树，~~写嵌套 CDQ 分治。

##### 2. 嵌套 CDQ 分治

CDQ 分治的**重要目的是降维**，除此之外，排序和使用数据结构也能够降维。所以三维偏序问题中，我们首先使用排序降低一维，但是数据结构维护二维数据还是很困难，所以我们需要 CDQ 分治。

CDQ 分治的另外一个好处是：它能够嵌套。如何嵌套呢？

```c++
int ans[maxn];
Flower temp3d[maxn];
Flower temp2d[maxn]; // note
void cdq2d(int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1;
	cdq2d(l, mid); cdq2d(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	int sum = 0;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && temp3d[i].z <= temp3d[j].z))
		{
			if (temp3d[i].flag == LEFT) sum += temp3d[i].param; // note
			temp2d[k++] = temp3d[i++];
		}
		else
		{
			if (temp3d[j].flag == RIGHT) ans[temp3d[j].ansIdx] += sum;
			temp2d[k++] = temp3d[j++];
		}
	}
	for (i = l; i <= r; i++)
		temp3d[i] = temp2d[i];
}
void cdq3d(int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) >> 1;
	cdq3d(l, mid); cdq3d(mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (!(j <= r) || (i <= mid && disc[i].y <= disc[j].y))
		{
			temp3d[k++] = disc[i++];
			temp3d[k - 1].flag = LEFT; //note
		}
		else
		{
			temp3d[k++] = disc[j++];
			temp3d[k - 1].flag = RIGHT;
		}
	}
	for (i = l; i <= r; i++)
		disc[i] = temp3d[i];
	cdq2d(l, r);
}
```

相比一层 CDQ 分治，有几个明显的特征：

1.  ~~代码长了一倍。~~
2.  ~~常数翻了一番。~~



1.  需要额外的 temp 数组。
2.  需要打上额外的 LEFT/RIGHT 标记，仅用标记（全）为 LEFT 的区间进行修改，仅用标记（全）为 RIGHT 的区间进行查询。
3.  不同维度比较的东西不同。



什么意思呢？首先，第一层的 CDQ 分治的任务有两个：按 $x$ 的左右区间打上标记；以 $y$ 为关键字进行排序。进行完这个操作后，我们再进行下一层 CDQ 分治，此时保证 $y$ 是递增的，就像第一层中 $x$ 是递增的一样。另外，由于打上了标记，所以我们只会使用 $x$ 符合要求的元素，直观地说，可以画几张图来感受下：

<img src="pic\CDQ 分治 3.png" style="zoom:60%">

<img src="pic\CDQ 分治 4.png" style="zoom:60%">

<img src="pic\CDQ 分治 5.png" style="zoom:60%">



二维的 CDQ 分治，需要考虑所有 Left 对所有 Right 的贡献，如果要处理第三维，需要对第三维进行与的第二维很类似的操作，只不过计算贡献时不止要满足所有贡献都是 Left 对 Right 的，还要满足是 1 ~ 3 对 4 ~ 6 的。如果有第四维，操作也很类似，只不过计算贡献就需要满足三个条件了（排序时会自动满足一个条件，剩下的条件需要用标记来实现）……

一般来说，我们使用排序降低第一维，中间的维度使用 CDQ 分治，最后一层使用数据结构。因为嵌套 CDQ 分治还是挺慢的，既然数据结构能够解决，那就用它吧。

##### 3. 三维偏序模型

类似的，也有三维偏序模型，而且它才是 CDQ 分治的用武之地之一。具体的内容将会在例题中解决。

##### 4. k 维偏序

可以使用嵌套 CDQ 分治解决，时间复杂度为 $O(n \log^{k - 1} n)$。当然，一百维偏序直接 $O(100 n^2)$ 就好了。

## Part 4 利用 CDQ 分治解决斜率优化问题

##### 1. e.g. [51NOD 1376 最长递增子序列的数量](http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1376)

这道题不是斜率优化，但是它的 CDQ 分治解法中用到了一种上面没有提到的方法，会在下面用到。

###### 题目大意

求一个长度为 $n \pod {n \le 5 \times 10^4}$ 的序列的 LIS 的数量。相同的数字在不同的位置，算作不同的子序列，例如 $1~1~2$ 的答案为 $2$。答案对 $10^9 + 7$ 取模。

###### 思路

考虑 $O(n^2)$ 的 DP。设 $f_i$ 表示以 $i$ 结尾的上升子序列的最大长度，$g_i$ 表示以 $i$ 结尾的长度为 $f_i$ 的上升子序列个数，则最终答案为 $f_i$ 等于最长上升子序列长度的 $g_i$ 之和。状态转移方程如下：
$$
f_i =
\begin{cases}
\max_{j < i, a_j < a_i} \{ f_j + 1 \} & \exists j < i, a_j < a_i
\\
1 & \text{otherwise}
\end{cases}
$$

$$
g_i =
\begin{cases}
1 & f_i = 1
\\
\sum_{f_j + 1 = f_i} g_j & \text {otherwise}
\end{cases}
$$

我们可以在 $O(n \log n)$ 的时间复杂度内求出 $f$。考虑求 $g$，它的转移实际上是同时满足三个条件的 $g_j$ 之和：条件一是 $j < i$，条件二是 $a_j < a_i$，条件三是 $f_j + 1 = f_i$。

这里存在一个 $O(n \log n)$ 的做法。方法是根据 $f$ 离线，离散化后用树状数组求 $g$。这个方法不难，但是在你敲代码不专注时很容易把某些关系搞错。这里不对其进行讨论，这里讨论如何使用 CDQ 分治解决这个问题。

很自然想到，这是一个“三维偏序”：一个元素包含位置，值，$f$ 三个参数。现在已经按位置排好序了，下一步我们按值进行归并排序，在里面我们想办法理清 $f$ 的关系，这道题就解决了。

一个很自然的想法是，按值排序后，用一个数组保存左边的 $f$ 为 $i$ 的方案数总和，然后右边的查询直接在数组中进行就可以了。但问题是，如果按照之前的做法，在需要左边的方案数时，左边的方案数可能还没有计算。

解决方法是不要按照归并排序的顺序处理：

```c++
int temp[maxn];
int count_[maxn];
void cdq(int l, int r)
{
	if (l == r)
	{
		if (f[l] == 1)
			g[l] = 1;
		return;
	}
	int mid = (l + r) >> 1;
	cdq(l, mid);

	for (int i = l; i <= r; i++)
		temp[i] = i;
	std::sort(temp + l, temp + mid + 1,
		[](const int& x, const int& y)
	{
		if (a[x] != a[y]) return a[x] < a[y];
		return f[x] < f[y];
	});
	std::sort(temp + mid + 1, temp + r + 1, // note
		[](const int& x, const int& y)
	{
		if (a[x] != a[y]) return a[x] < a[y];
		return f[x] < f[y];
	});
	for (int i = l; i <= mid; i++) // clean the count array
		count_[f[temp[i]]] = 0;
	for (int i = mid + 1; i <= r; i++)
		count_[f[temp[i]] - 1] = 0;
	int i = l, j = mid + 1;
	while (i <= mid || j <= r)
	{
		if (j > r || (i <= mid && a[temp[i]] < a[temp[j]])) // note
		{
			int pos = f[temp[i]];
			count_[pos] = (count_[pos] + g[temp[i]]) % mod;
			i++;
		}
		else
		{
			int pos = f[temp[j]];
			g[temp[j]] = (g[temp[j]] + count_[pos - 1]) % mod;
			j++;
		}
	}

	cdq(mid + 1, r); // note
}
```

上面这份代码跟之前的代码显然不同，而且根本不以归并排序为框架，只是在合并处用了一下归并排序的板子。

事实上，虽然前面说 CDQ 分治基于归并排序，但是它的**核心思想是只考虑左边部分对右边部分的贡献**，因此它的特点是：

1.  左边部分对右边部分的所有贡献都要算上，不能算重算漏。

2.  右边部分的内容不能对左边部分有贡献（也就是不能算漏）。

只要满足了这两个特点，CDQ 分治就是有效的。像上面这个例子，如果我们不提前计算第一个二分之一对第二个二分之一的贡献，我们就不知道第三个四分之一对第四个四分之一的贡献会是多少，因此我们必须改变计算顺序。只需要**左右分别**进行快速排序，就能像归并排序后一样处理贡献了。时间复杂度为 $O(n \log^2 n)$。

```flow
left=>operation: 递归处理左边（目的是算出左边的答案）
sort1=>operation: 在临时数组中对左边排序
sort2=>operation: 在临时数组中对右边排序
merge=>operation: 在临时数组中用类似于归并排序的方法计算左边对右边的贡献
right=>operation: 递归处理右边（右边只剩下内部的贡献未计算）

left->sort1->sort2->merge->right
```

注意代码中的细节，为什么只能用小于号，不能用小于等于号呢？**因为用小于等于号会导致算错：可能有重复的数，所以用小于等于号可能把不下降序列也当作了上升序列。**所以这里必须用小于号。

所以，虽然理论上我们要遵循归并排序的规则，但实际上我们需要遵循的是 CDQ 分治的规则：左边对右边的不要算重算漏。而对这道题来说，受位置的影响，右边部分不可能对左边部分有贡献，所以也就不用管了。

这个题的 CDQ 分治做法很重要，虽然时间复杂度不优，但是是一种重要的题型。最好也做一下这道题的 $O(n \log n)$ 的做法，看看有什么区别。

##### 2. e.g. [Luogu 4027 [NOI 2007] 货币兑换](https://www.luogu.org/problemnew/show/P4027)

###### 题目大意

第 $0$ 天，你有 $S$ 元钱。已知有一家金券交易所，有两种券：A 券和 B 券。你知道了接下来 $n \pod {n \le 10^5}$ 天 A 券和 B 券的单位价值（设为 $A_i$ 和 $B_i$）。这家金券交易所允许你做两种操作：

1. 卖出金券：顾客选择一个百分数 $p$，将持有的 $p\%$ 的 A 券和持有的 $p\%$ 的 B 券以当时的价格兑换成 RMB；
2. 买入金券：在第 $K$ 天，顾客支付 $p$ 元，交易所提供给顾客与支付金额等价值（以第 $K$ 天的价格为标准）的 A 券和 B 券，并且 A 券和 B 券的比例一定为 $Rate_K$。

一天内既可以卖出又可以买入。

求第 $n$ 天后最多能获得多少元钱。有一个显然的性质：一定存在一种最优方案使得每次操作卖出所有的金券或者花去所有钱去买金券。

###### 思路

考虑动态规划。设第 $i$ 天已经卖出了所有金券后（但是还可以在当天再买）拥有的最大财富值为 $f_i$。边界条件为 $f_1 = S$，最终答案为 $f_n$（注意没有要求第 $i$ 天要买），状态转移方程为：
$$
f_i = \max_{j < i} \{ A_i \frac {Rate_j \times f_j} {A_j \times Rate_j + B_j}  + B_i \frac {f_j} {A_j \times Rate_j + B_j} \}
$$
**再对 $f_{i - 1}$ checkmax**。

显然这个可以用 $O(n^2)$ 的 DP 解决。考虑斜率优化。设 $j > k$ 且 $j$ 比 $k$ 更优，则有：
$$
A_i \frac {Rate_j \times f_j} {A_j \times Rate_j + B_j}  + B_i \frac {f_j} {A_j \times Rate_j + B_j} >
A_i \frac {Rate_k \times f_k} {A_k \times Rate_k + B_k}  + B_i \frac {f_k} {A_k \times Rate_k + B_k}
$$

$$
\frac {f_j} {A_j \times Rate_j + B_j} \cdot (A_i \times Rate_j + B_i) >
\frac {f_k} {A_k \times Rate_k + B_k} \cdot (A_i \times Rate_k + B_i)
$$

不妨设 $T_j = \frac {f_j} {A_j \times Rate_j + B_j}$。两式同时除以 $A_i$ 有：
$$
T_j \times (Rate_j + \frac {B_i} {A_i}) > T_k \times (Rate_k + \frac {B_i} {A_i})
$$
整理得：
$$
T_j Rate_j - T_k Rate_k > -(T_j - T_k) \frac {B_i} {A_i}
$$

由于 $T_j - T_k$ 符号不确定，因此我们不能直接除过去，那怎么办呢？

**通解**是，我们不再假设 $j > k$，而是假设 $T_j > T_k$，则上式变成：
$$
\frac {T_j Rate_j - T_k Rate_k} {T_j - T_k} > -\frac {B_i} {A_i}
$$
可以这么做的原因是，过去的斜率优化假设 $j > k$ 的本质就是假设 $X_j > X_k$（或小于）。这道题就是一道所谓横坐标不单调的斜率优化。

显然答案还是凸包切线，但是我们就不能只在尾端用单调栈维护凸包，而是还要考虑在中间插入点时如何维护凸包。这个经典问题可以使用平衡树解决，但还可以用 CDQ 分治解决。

注意到，从 $f_j$ 转移到 $f_i$ 的时候必须满足 $j < i$。如果我们把 $i$ 前面的所有决策点按 $T_j$ 排序，我们就可以只用在尾部插入点维护凸包，问题就变简单了。

考虑套用 CDQ 分治，函数 `cdq(int l, int r)` 表示计算 $f_{l \sim r}$。显然我们首先需要调用 `cdq(l, mid)`，但接下来我们不能直接调用 `cdq(mid + 1, r)`，因为一开始它们的 $f$ 都是 $0$，没法算内部的贡献。正如上一道例题一样，我们需要先计算左边部分对右边部分的贡献。我们将左半部分按横坐标从小到大排序以构建凸包，这一步与一般的斜率优化一致。考虑右半部分，我们将它们按不等式右侧从大到小排序，这样就可以不必在单调栈上倍增，直接使用单调队列即可（如果你不会斜率优化，请先学习基本的斜率优化）。然后我们再递归调用 `cdq(mid + 1, r)`，这时就可以算它们内部的贡献了。

上述过程的时间复杂度显然为 $O(n \log^2 n)$，空间复杂度为 $O(n)$。由于使用平衡树做这道题的时间复杂度为 $O(n \log n)$，因此我们不禁思考存不存在 $O(n \log n)$ 的分治做法。很容易想到把快速排序变成归并排序，毕竟 CDQ 分治就是从归并排序起家的。

发现对于横坐标而言，我们直接在做完 `cdq(mid + 1, r)` 后归并排序即可，因为此时 $[l, r]$ 内的所有 $f$ 都已计算完成，而由于是递归调用，左半部分和右半部分内的横坐标是各自有序的，因此直接归并排序即可。

对不等式右侧，我们似乎不能像横坐标那样直接归并排序，因为我们在递归调用 `cdq(mid + 1, r)` 前就要用到它们。不过注意到，不等式右侧只与 $i$ 有关，并且还是题目给定的，因此我们可以预处理。我们在进行 CDQ 分治前先对不等式右侧做一次归并排序，把每一层的排序结果都保存下来。这样我们的时空复杂度均达到 $O(n \log n)$。

这道题还有两点需要注意：

1. $f_i$ 不仅从状态转移方程转移而来，还要对 $f_{i - 1}$ checkmax。考虑处理 `cdq(pos, pos)` 时的情况，显然此时 `cdq(1, pos - 1)` 是算完了的，因此我们在这里对 `f[pos - 1]` checkmax。这也意味着我们要把 $f_0$ 置为 $0$（否则计算 $f_1$ 处用到了未定义的 $f_0$），或者也可以令 $f_0 = S$。
2. 这道题卡精度，要用题目给定的 $\epsilon = 10^{-7}$。

###### 参考代码

```c++
// 见 "Source Code\CDQ 分治"
// O(n log^2 n) 的做法在类 CDQ 中
// O(n log n) 的做法在类 CDQopt 中 
```

##### 3. 总结使用 CDQ 分治解决斜率优化问题

进行 CDQ 分治时，需要保证左半部分横坐标单调（如果不单调，使用归并排序处理），然后对左侧建立单调队列。为了能够使用单调队列，需要保证右半部分的不等式右侧是单调的（如果不单调，需要 $O(n \log n)$ 的空间和时间预处理），在左右递归调用的中间用单调队列 $O(n)$ 计算左半部分对右半部分的贡献即可。特别地，如果像上一题一样需要对上一个状态 checkmax，那就还需要在边界处理。

大家也应该看出来了，如果题目本身保证横坐标单调，那么就没有必要使用 CDQ 分治。因为 CDQ 分治相比单调栈或者单调队列还是复杂一些。

## Part 5 例题

##### e.g. [BZOJ 1935 [SDOI 2007] 园丁的烦恼](https://www.lydsy.com/JudgeOnline/problem.php?id=1935)

###### 题目大意

在平面直角坐标系中，有 $n \pod {n \le 5 \times 10^5}$ 个点。给定 $m \pod {m \le 5 \times 10^5}$ 个询问，每次询问给定一个矩形（给定左下角坐标和右上角坐标），求矩形中有多少个点。

###### 思路

设矩形的左下角为 $(x_1, y_1)$，右上角为 $(x_2, y_2)$，我们把问题转换成：
$$
ans = f(x_2, y_2) - f(x_1 - 1, y_2) - f(x_2, y_1 - 1) + f(x_1 - 1, y_1 - 1)
$$
其中 $f(x, y)$ 表示求出 $(1, 1) \sim (x, y)$ 中有多少个点，而这个问题显然是一个偏序问题，可以使用 CDQ 来做。

###### 参考代码

```c++
// 见 "Source Code\CDQ 分治"
```

###### 注意事项

1.  记住归并排序中要用小于等于号，使得排序是一个稳定排序。
2.  由于这道题修改（即题目中的点）和询问是分开的，因此不用去重。把这道题再和陌上花开对比一下，深刻理解一下去重的作用。

##### e.g. [JZOJ 5735 身份证](https://jzoj.net/senior/#main/show/5735)

###### 题目大意

有 $n$ 个人，每个人都有三个字符串 $a_i$，$b_i$，$c_i$。现在有 $q$ 次操作，有三个输入框，每次操作可以从某个输入框中输入或者删除一个字符。设输入框中的字符串为 $e_1$，$e_2$，$e_3$，每次操作后，求出满足 $e_{1 / 2 / 3}$ 同时是 $a_i / b_i / c_i$ 的前缀的 $i$ 的个数。

设所有人的三个字符串的总长为 $S$，数据规模为：$1 \le n, q, S \le 5 \times 10^5$。 

###### 思路

见[题解](https://blog.csdn.net/lycheng1215/article/details/80515761)。

###### 参考代码

```c++
// 见 "Source Code\CDQ 分治"
```
