[TOC]

> 开局一个 Markdown，内容全靠编。——Orange

# 2-SAT 问题

## SAT 问题

SAT 问题全称为*适定性问题（Satisfiability Problem，SAT Problem）*，笼统地说，适定性问题的目标就是确定是否可以满足所有的条件。

具体地说，SAT 一般指：有 $n$ 个集合，元素最多的集合中有 $k$ 个元素，现用逻辑运算的形式给出一些取元素的规则，要你判断是否可行，甚至要求给出可行方案。由于每个集合里面最多有 $k$ 个元素，因此我们称其为 $k$-SAT 问题，而 2-SAT 问题指的就是 $k = 2$ 时的 SAT 问题。

已经证明，当 $k \ge 3$ 时，$k$-SAT 问题是 NP 完全问题。而我们将要讨论的 2-SAT 问题中的**每个集合都恰好有 2 个元素，且这两个元素不允许同时取出，也不允许两个元素同时不取**。

------

预警：距不完全统计，90% 的无资源选手（有资源选手请走开）学的 2-SAT 都是假的。本文从一位学了假的 2-SAT 的选手的角度出发进行解读，希望能够解决你对 2-SAT 问题及其算法的所有困惑。

## 2-SAT 问题

### 1. 一般模型

有 $n$ 道题，每道题你可以选择做与不做。现在告诉你：要做第 $2$ 道题就必须做第 $1$ 道题，要做第 $3$ 道题就必须做第 $5$ 道题，要做 $2$ 道题就必须不做第 $4$ 道题……如何给出一个做题方案，使得上面的条件都满足呢？

我们把每道题看成一个集合，集合中有两个元素：选与不选，则原问题转换为 2-SAT 问题。像这样，**给定 $n$ 个物品，有选与不选两种决策，能且只能选其中一种决策，是一种典型的 2-SAT 的模型**。但“选与不选”并不是 2-SAT 问题模型的全部，像“选 $A$ 与选 $B$”这样的二选一，显然也是一种 2-SAT 模型。

### 2. 拆点

我们将[上面的问题](#1.-一般模型)转换为了 2-SAT 问题，那么 2-SAT 问题该如何求解呢？

虽然只有 $n$ 道题，但是我们一共有 $2n$ 个决策（每道题选或不选），我们将每个决策都看作一个点，则共有 $2n$ 个点，我们用 $yes_i$ 和 $no_i$ 表示选或不选第 $i$ 道题对应的结点。

那么我们的问题就变成了选 $n$ 个点，并且不能同时选 $yes_i$ 和 $no_i$，问满足条件的方案。

### 3. 连边

如果我们做了第二题，即选择了 $yes_2$，我们能知道什么（限制条件为[前面举的例子](#1.-一般模型)）？我们可以知道：我们一定选择了 $yes_1$。像这样，如果我们能从选择一个点**推导**出我们**一定**选了另外一个点，我们就从它向另外一个点连一条**有向边**。

#### 原命题和逆否命题

众所周知，原命题等于逆否命题（为什么我不详细解释？因为这个是高中数学必修内容）。对于**像上例中将选与不选的问题转换成 2-SAT 问题的，往往一个限制条件能够产生多个“推导”**：

> 原命题：&emsp;做第二道题 $\to$ 做第一道题。
>
> 逆否命题：不做第一题 $\to$ 不做第二题。

所以我们还需要再连一条边：从 $no_1$ 连向 $no_2$。其它限制条件类似。可以认为，**所有 2-SAT 问题都会因为逆否命题的存在使得一个命题对应两条边**。

需要注意的是，为逆否命题连边只是为了满足逻辑关系，但是它为这张图带来了不可少的性质：对称性。我们将在后文讲述对称性是如何使得问题可解的。

为了方便，在接下来我们用 $yes_i$ 和 $no_i$ 表示 $i$ 的两个**决策**，称它们组成 $i$ 的**决策集合**。**它们并没有本质区别**，如果你觉得 $yes$ 和 $no$ 很别扭，可以把 $yes$ 看作 $s$，把 $no$ 看作 $s'_i$。

#### 强连通分量

连边之后，我们得到了一张有向图，我们求出它的强连通分量。可以发现，对于一个强连通分量，如果我们选择它其中的一个点，那么我们一定选择了这个强连通分量的所有点。为什么呢？如果你选择了 $a$，那么你必须选择从 $a$ 出发能够到达的所有点，而在 $a$ 的强连通分量中从 $a$ 出发肯定能够到达强连通分量的所有点。

当然，反过来，如果我们没有选择强连通分量的一个点，那么整个强连通分量中的点我们都没有选。因此我们得到了在线性时间复杂度内判断 2-SAT 问题[^2-sat]是否有解的方法：**若存在一个集合的两个元素在同一个强连通分量，那么 2-SAT 问题无解，否则一定存在解。**

[^2-sat]: 前面说了，我们讨论的 2-SAT 是指所有集合都恰好有 $2$ 个元素，每个集合能且仅能选择一个元素。

#### e.g. [ARC(AtCoder Regular Contest) 069F Flags](https://arc069.contest.atcoder.jp/tasks/arc069_d)

##### 题目大意

要在一条直线上放 $n \pod {2 \le n \le 10^4}$ 个旗子，第 $i$ 个旗子可以放在 $x_i$ 或者 $y_i$ 处，求旗子间的最大间隔长度。放在同一位置的旗子视作间隔为 $0$。

##### 解决方案

由于每个旗子要么选 $x$，要么选 $y$，因此这是一个 2-SAT 问题，但是限制条件如何呢？

我们可以二分答案。对于两个不同的旗子 $i$，$j$，若 $x_i$ 离 $x_j$ 的距离小于答案，那么选了 $x_i$ 就一定不能选 $x_j$，选了 $x_j$ 就一定不能选 $x_i$，换句适合 2-SAT 的话说，选了 $x_i$ 就一定要选 $y_j$，选了 $y_j$ 就一定要选 $x_i$。其它情况类似。

那么我们考虑这么做：对于一个旗子 $x_i$，若对于一个 $x_j$ 满足 $|x_i - x_j| < ans$，那么我们从 $x_i$ 向 $y_j$ 连一条有向边；若对于一个 $x_j$ 满足 $|x_i - y_j| < ans$，那么我们从 $x_i$ 向 $x_j$ 连一条有向边。对于旗子 $y_i$ 类似。**特别地，$x_i$ 和 $y_i$ 之间不要连边，因为本身就不存在这个推导，再者这会导致它们在一个强连通分量中，造成无解；但由于自环不会影响强连通分量，因此 $x_i$ 和 $x_i$ 之间可以连边，为了方便，无需像 $x_i$ 和 $y_i$ 那样处理。**这样我们可以在 $O(n^2 \log n)$ 的时间复杂度内解决这个问题。

由于 $n$ 很大，因此考虑线段树优化连边。观察发现，如果我们把旗子的 $x$ 和 $y$ 分别从小到大排序，要连边的点将会是一段连续的区间，使用线段树优化连边即可。具体的实现可能有些复杂，需要对线段树优化连边有深刻理解，这里不再赘述，详见线段树优化连边。

```c++
bool check(int s)
{
	G.clear();
	G.resize(n << 2); // 4n - 2 个点
	buildx(1, n);
	buildy(1, n);

	int l = 1, r = 0;
	for (int i = 1; i <= n; i++) // 选了 x 后，某些不能选 x，等价于这些必须选 y
	{
		while (l <= n && points[i].x - points[l].x >= s) l++;
		while (r < n && points[r + 1].x - points[i].x < s) r++;
		linky(i, l, i - 1); // y 按 x 排序的顺序
		linky(i, i + 1, r);
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; i++) // 选了 x 后，某些不能选 y，等价于这些必须选 x
	{
		while (l <= n && points[i].x - points[idx[l]].y >= s) l++;
		while (r < n && points[idx[r + 1]].y - points[i].x < s) r++;
		linkx(i, l, r); // x 按 y 排序的顺序
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; i++) // 选了 y 后，某些不能选 x，等价于这些必须选 y
	{
		while (l <= n && points[idx[i]].y - points[l].x >= s) l++;
		while (r < n && points[r + 1].x - points[idx[i]].y < s) r++;
		linky(idx[i] + n, l, r); // x 按 y 排序的顺序
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; i++) // 选了 y 后，某些不能选 y，等价于这些必须选 x
	{
		while (l <= n && points[idx[i]].y - points[idx[l]].y >= s) l++;
		while (r < n && points[idx[r + 1]].y - points[idx[i]].y < s) r++;
		linkx(idx[i] + n, l, i - 1); // x 按 y 排序的顺序
		linkx(idx[i] + n, i + 1, r);
	}

	stamp = 0;
	stack[0] = 0;
	N = 0;
	memset(dfn, 0, sizeof(dfn));
	memset(low, 0, sizeof(low));
	for (int i = 1, to = 4 * n - 2; i <= to; i++)
		if (!dfn[i])
			Tarjan(i);

	for (int i = 1; i <= n; i++)
		if (belong[i] == belong[i + n])
			return false;
	return true;
}
```

### 4. 构造方案

我们对当前的图缩点，得到一个 DAG，若有解，那么每一个点对应的强连通分量一定不会同时存在 $yes_i$ 和 $no_i$。现在我们考虑如何得到一个具体的方案。

#### 字典序最小的解

利用强连通分量的方法其实不适用于构造字典序最小的解，我们只能贪心地去尝试让字典序最小。我们依次检查每一个还没有确定选谁的集合，并贪心地选择字典序小的元素，然后递归去选中能被推导出的元素。如果选择失败，我们撤销刚才的操作，尝试去选择字典序大的元素，如果还是失败，说明 2-SAT 问题无解。（训练指南上的方法，这里不再赘述~~，因为我不会~~）

需要注意的是这个方法的时间复杂度是 $O(nm)$ 而不是 $O(n + m)$，因此需要注意数据规模。

#### 任意解

为了方便，下面的讨论我们都在 2-SAT 问题存在解的前提下进行，即不存在任何一个决策集合使得它的两个决策属于同一个强连通分量。

##### 构造方法

回忆我们判断无解的方法，我们判断无解的方法是检查是否存在一个 $i$ 使得它的两个决策对应的点在同一个强连通分量中。为什么这样就无解了呢？这是因为我们最终的解是在这 $2n$ 个点中选 $n$ 个代表答案，并且满足：

1. 对于所有的决策集合，需要在其中选且仅选一个决策；
2. 对于被选择的点，能够被它推导出的点一定被选。

------

由于在一个强连通分量中的点要么全部都被选，要么全部都没有选，因此我们构造解的方法可以提炼为：选若干个强连通分量，使得每个 $i$ 有且仅有一个决策被选中，**且选中的强连通分量必须构成闭合子图**[^closing subgraph]。

[^closing subgraph]: 对于图 $G$ 的点集的一个子集 $V'$，如果从 $V'$ 中的任何一个点出发都不能到达 $V'$ 之外的点，则称 $V'$ 是 $G$ 的一个*闭合子图*的点集，我们约定可以直接称 $V'$ 是 $G$ 的一个闭合子图。

首先，显然的是，对于图[^graph]中的一个点 $V$，一定存在**一些**[^some]对立的点，如果这个点和这些对立的点中的某些点同时被选择，将会产生矛盾。举个例子，点（对应原图中的一个强连通分量） $V$ 包含了决策 $yes_i$，另外肯定存在某个点包含了 $no_i$，这个包含了 $no_i$ 的点就被称为与 $V$ 对立的点，显然不能同时选择这两个点。

[^graph]: 如不加说明，后面的图都指缩点后的图。
[^some]: 似乎我们没法证明到底是一个还是可能有多个，我们姑且认为可能有多个吧。

接下来怎么做？好像不是很清晰。这里我直接给出构造方法。我们对图进行染色操作，**染成红色代表选择，染成蓝色代表没有选择**。前面已经说明，被选中的强连通分量必须构成闭合子图，这就意味这**染成红色的点必须构成闭合子图**。一开始，我们把**拓扑序最靠后**的点 $V$ 染成红色，显然与它对立的点 $V'$（或者点集）应该被染成蓝色。由于染成红色的点必须构成闭合子图，所有能够推导出 $V'$ 的点应该被染成蓝色，否则，如果把它们染成红色，它们将会走到蓝色的 $V'$ 上，这样染成红色的点就不构成闭合子图，因此不成立。接下来，我们选择拓扑序最大的且未被染色的点，重复以上操作，直到所有点被染色为止。这样做完后，被染成红色的点就对应这个 2-SAT 问题的解。

##### 证明

###### 条件 $2$

条件 $2$：对于被选择的点，能够被它推导出的点一定被选。

显然，选择了 $V$ 之后（把 $V$ 染成了红色），与 $V$ 对立的点或者会导致与 $V$ 对立的点被选择的点一定不会被选择（它们都会被染成蓝色），构造方法中已经给出了这么做的理由。那么我们只需要证明接下来的染色中不会出现染成红色的点能够走到染成蓝色的点就可以了。显然不可能存在一个未染色的点，使得从它出发能够走到任何一个染成蓝色的点，因为如果存在，那这个点一定已经被染成蓝色了，与假设矛盾。这就相当于使得染成红色的点构成了闭合子图（因为不会走到染成蓝色的点），因此，这么做保证了条件 $2$。

###### 条件 $1$

条件 $1$： 对于所有的决策集合，需要在其中选且仅选一个决策。换句话说，每个决策集合中有且仅有一个决策所在的强连通分量被染成红色。

显然不可能存在某个决策集合，它的两个决策所在的强连通分量同时被染成红色。因为一个决策的强连通分量被染成红色的同时另一个决策的会被染成蓝色或者已经被染成蓝色。这意味着我们只需要证明**一个决策集合不可能两个决策所在的强连通分量都被染成蓝色**。这很复杂，我们试着分析下。

------

假设我们把点（强连通分量） $V$ 染成红色，它对立的点 $V'$ 以及能够走到 $V'$ 的点都会被染成蓝色。一个决策集合的两个决策都被染成蓝色，显然有以下两种可能的情况：

1. 两个点在点 $V$ 被染成红色时被同时染成蓝色；
2. 其中一个点之前就是蓝色，另外一个点在点 $V$ 被染成红色时被染成蓝色。

&emsp;&emsp;在继续分析前，你肯定觉得我在口胡：明明我们在讨论每个决策的情况，我却用代表强连通分量的“点”来讨论。虽然说每个强连通分量是由若干个决策构成的，但是它们之间的联系似乎并不是很清晰？所以我们先来再次澄清概念，并进行分析。

------

决策：每个决策都用一个点来表示。我们用“决策”表示这个概念。

决策集合：第 $i$ 个决策集合由两个决策 $yes_i$ 和 $no_i$ 组成，对应两个决策。

强连通分量：对决策所表示的图进行缩点，缩点后的图的每个点是一个强连通分量。我们用“点”表示这一概念。

可以证明，以下结论是成立的：

1. 如果决策 $yes_i$ 能够**走到** $no_j$，那么决策 $yes_j$ 能够走到 $no_i$。

   因为存在**逆否命题**，感性地进行推广，不难验证这个结论是成立的。

2. 如果决策 $yes_i$ 和决策 $yes_j$ 属于同一个点，那么 $no_i$ 和 $no_j$ 也属于同一个点。

   同样因为存在逆否命题，这个结论成立。我们规定前者属于点 $V$，后者属于点 $V'$。

3. 对于缩点后的图，如果点 $V$ 能够走到 $U$（$U$ 是另外一个点），那么 $U'$ 也能够走到 $V'$。

   还是因为存在逆否命题，这个结论成立。



这些结论都有一个共同特点：说明了**这张图是一张对称的图**。感性地理解下，毕竟我们连的边都是对称的嘛。这会给我们带来什么呢？

------

1. 情况 $1$：两个点在点 $V$ 被染成红色时被同时染成蓝色。

   设被染成蓝色的两个点为 $U$ 和 $U'$，换句话说，$U'$ 能走到 $V'$，$U$ 也能走到 $V'$。但是，如果 $U'$ 能够走到 $V’$，我们就可以知道 $V$ 能够走到 $U$。这已经不满足拓扑序的关系了，而且，既然 $V$ 被染成了红色，那么 $U$ 应该是红色，与 $U$ 是蓝色的假设矛盾，因此不可能有两个决策同时被染成蓝色。

2. 情况 $2$：其中一个点之前就是蓝色，另外一个点在点 $V$ 被染成红色时被染成蓝色。

   设之前就是蓝色的点为 $U$，在 $V$ 被染成红色时被染成蓝色的点为 $U'$。显然 $U'$ 能够走到 $V'$，同样我们推导出了 $V$ 能走到 $U$。同样，$U$ 也应该是红色，与 $U$ 是蓝色的假设矛盾。综上，我们保证了条件 $1$。

##### 扩展

对于一般的两个元素之间的关系，我们显然可以用以上方法进行解决。但是这里有一种特殊情况：如何表示一定选择 $yes_i$ 或者一定选择 $no_i$？

按照“推导”的意义，如果我们一定选择 $yes_i$，**那么我们从 $no_i$ 向 $yes_i$ 连一条边**，直观地说，它的意思是”如果选了 $no_i$，那么一定选择 $yes_i$“。这个直观解释显然很别扭，我们如何证明这种连边方式是对的呢？

首先考虑无解的情况，显然还是可以通过强连通分量判断无解。有解时，我们必须保证 $yes_i$（所在点）被染成红色，也就是说，$yes_i$ 绝对不会被染成蓝色。如果 $yes_i$ 没有后继结点，那么显然 $yes_i$ 将会被染成红色；如果 $yes_i$ 有后继结点，设它们中的一个为 $V$。当且仅当 $V$ 的对立点 $V'$ 被染成红色时，$yes_i$ 将会被染成蓝色。可以知道 $V'$ 是能够到达 $no_i$ 的，也就是说，在 $no_i$ 被染色之前，$yes_i$ 不可能被染成蓝色。同时，如果 $no_i$ 被染成蓝色，可以知道 $yes_i$ 是不会因为 $no_i$ 被染成蓝色而被染成蓝色的，否则就说明 $yes_i$ 能够到达 $no_i$，产生矛盾。综上，我们可以知道这种连边方式是正确的。

##### e.g. [Luogu 3825 [NOI 2017] 游戏](https://www.luogu.org/problemnew/show/P3825)

###### 题目大意

给你 $n \pod {n \le 5 \times 10^4}$ 张赛车地图，有 $3$ 种可选赛车。对于每张地图，要么某一种赛车在这张地图中不能用，要么三种赛车都能用，且三种赛车都能用的地图的数量 $d \le 8$。给定 $m \pod {m \le 10^5}$ 个限制条件，形如“如果在地图 $i$ 中使用赛车 $x$ 就必须在地图 $j$ 中使用赛车 $y$”。求出任意一种合法方案，或者宣布问题无解。

###### 解决方案

如果不存在能够选 $3$ 种赛车的地图，那么这道题几乎就是一个裸的要求给出任意解问题的 2-SAT 问题。现在适合 $3$ 种赛车的地图很少，那么我们可以枚举：对于所有赛车都适合的地图，它们要么不选赛车 $a$（可以选 $b$，$c$），要么不选赛车 $b$（可以选 $a$，$c$），这样一定能覆盖所有的情况，因为每张地图选且只选一辆赛车。因此问题被转换为 2-SAT 问题。

对于题目给的限制条件，如果起点本身不能选，我们不用管它；如果终点本身不能选，说明起点只能选另外一种赛车；否则直接用 2-SAT 的方法进行连边，注意要为逆否命题连边。

注意到，使用 Tarjan 缩点时，拓扑序大的，编号（一定）反而小。另外，我们对 2-SAT 问题的编码通常是这样的：$yes$ 是 $i$，$no$ 是 $i + n$；或者 $yes$ 是 $i$，$no$ 是 $i + 1$。它们的共同点是 **$yes$ 的编号在 $no$ 的编号的前面**。这意味着，**如果 $yes_i$ 还没有被访问，那么这样的 $yes_i$ 所在点的编号都比 $no_i$ 所在点的编号小**。同时这也说明了，**如果选择所有会在手动调用 Tarjan 时访问的 $yes$（即因为该点还没有被访问过而对其调用 Tarjan 的点）构成的闭合子图，那么它就是一组合法解**。这一点是最难理解，也最难想清楚的。~~由于我也不会证明，~~我们直接得到如下构造解的方案：

1. 如果 $yes_i$ 所在点的编号比 $no_i$ 小，那么我们选择 $yes_i$；
2. 如果 $yes_i$ 所在点的编号比 $no_i$ 大，那么我们选择 $no_i$。

###### 参考代码（部分）

```c++
initTarjan();
for (int j = 1, to = n << 1; j <= to; j++)
	if (!dfn[j])
		Tarjan(j);

bool bOk = true;
for (int i = 1; i <= n; i++)
	if (belong[i] == belong[i + n])
	{
		bOk = false;
		break;
	}
if (!bOk) continue;

for (int i = 1; i <= n; i++)
{
	if (belong[i] < belong[i + n])
	{
		if (prohibit[i]) putchar('A');
		else putchar('B');
	}
	else
	{
		if (prohibit[i] == 2) putchar('B');
		else putchar('C');
	}
}
return;
```
