#####[JZOJ 5060 公路建设](https://jzoj.net/senior/#main/show/5060)

###### ①60 分做法

​	我们知道暴力算法：直接使用 Kruskal 即可。

​	Kruskal 算法需要先按边权排序，而这三个特殊的测试点并不需要。但是跑 Kruskal 肯定是不可能的，有什么好的方法吗？

​	考虑从大到小添加边，==每次添加后，如果形成了环，就删除环上的最大边。==这是加边的 MST 的套路。==**因为最多只有 n - 1 条边，所以我们用一个数组保存有哪些边即可。这种算法不需要将边保存成邻接矩阵或者邻接表的形式。**==

​	考虑询问 $[l, m]$ 的情况。只需要从 $m$ 到 $l$ 一直维护就可以了。**由于按处理的顺序边权递减，被删去的边永远不可能再被添加。**

​	所以考虑离线询问 $[l, r]$ 。加边时，如果形成了环，就重构；计算时，**只考虑 $[l, r]$ 中的已经选择的边。**可以用反证法证明这是正确的：如果需要考虑 $[l, r]$ 中已经删除了的边，而使它被删除的边是一定存在与 $[l, r]$ 的，因此不需要考虑被删除了的边。**这个做法要求边权是从小到大递增的。**

​	可以用树状数组维护添加了的边的边权和。

​	时间复杂度为 $O(mn \log m + q \log m)$。

###### ②100 分做法

​	考虑使用线段树。==**首先最重要的一点还是最多只会有 $n - 1$ 条边属于最小生成森林。**==所以我们可以对两个区间的最小生成森林的边归并排序后跑 Kruskal，得到大区间的最小生成森林。这个使用线段树来做。

​	查询的操作与初始化的操作类似。可以把结果保存在一个线段树结点中。

​	初始化的时间复杂度为 $O(\alpha(n) \, nm)$，单次查询的时间复杂度为 $O(\alpha(n) \, n \log m)$。