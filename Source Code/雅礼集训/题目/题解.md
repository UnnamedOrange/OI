##### Day1 T1

######Prüfer 序列，动态规划

​	首先要知道 Prüfer 定理。然后考虑使用**计数型动态规划**。

​	设 $f_{i, j, k}$ 表示在前 i 个数中有 j 个作为**候选名单**并且在这个候选名单中选了 $k + 2$ 个点组成了长度为 k 的 Prüfer 序列。

​	初始时 $f_{0, 0, 0} = 1$。**由于边界情况比较复杂，所以考虑“我为人人”的动规方式。**

​	考虑 $f_{i, j, k}$ 对答案的贡献。若不把第 i + 1 个数考虑进候选名单，那么会给 $f_{i + 1, j, k}$ 有 $f_{i, j, k}$ 的贡献。

​	若考虑进候选名单，那么会给 $f_{i + 1, j + 1, k + c}$ 有贡献，这里的 c 由枚举得来，要求满足度数要求（$c < a_{i + 1}$），并且满足 Prüfer 序列的要求（$k + c \le n - 2$）。

​	考虑公式 $\frac {n!} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!}$。我们先让 DP 数组中保存的树除以 $n!$，因此我们实际保存的是 $\frac {1} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!}$ **的和**。这样看上去就没有什么大的实际意义了，但我们知道，**新的和的每一项的形式是 $\frac {1} {(a_1 - 1)!(a_2 - 1)! \, ... \, (a_n - 1)!(a_{n + 1} - 1)!}$**，所以我们只需要索性让 $f_{i, j, k}$ 对 $f_{i + 1, j + 1, k + c}$ 有 $\frac {f_{i, j, k}} {c!}$ 的贡献就可以了。

​	最后还要再把 $(n - 2)!$ 乘回来，因此选 i 个作为候选名单的答案为 $f_{n, i, i - 2} * (i - 2)!$。

​	注意：这里不把 $n!$ 保存在 DP 数组中只是为了方便，但同时这样改变了我们所保存的东西的意义。如果要退回原意的话，还得再做一个连续乘法，造成了不必要的麻烦。

##### Day1 T2

######简单博弈，动态规划

​	**树上的博弈可以考虑子树上的情况。**

​	考虑状态的设计。**经验告诉我们，状态可以有四种：红必胜，蓝必胜，先手胜，后手胜。**对于这道题而言，我们需要三种状态：红必胜，蓝必胜和先手胜。

​	**考虑从叶节点开始，推广到子树，再推广到整棵树。**一开始，叶节点的状态时已知的：红色结点为红必胜，蓝色结点为蓝必胜，无色结点为先手胜。**然后考虑将操作限定在子树，**接下来就会很明显的发现，当红色结点个数大于蓝色结点个数时，红必胜；反之蓝必胜；否则先手胜。

​	**基于这么个事实：假设有一个红必胜的不在当前子树，而蓝色想要去挽回，那么蓝色就要去那里选择一个结点。但是红色的可以进行“模仿”，因此一切挽回都是徒劳的。**所以，状态就限定在了子树中。接下来考虑如何通过子树来推断上一级结点。只需要把红必胜的子树看作红色，蓝必胜的子树看成蓝色，先手胜的结点看作无色就是了。**因为最终它们都会变成它们应有的颜色。**

​	最终，问题 1 的答案就是根结点的状态。若根结点的状态为红必胜或先手胜则有解，否则无解。

​	考虑第 2 问，我们不如换一种状态设计。设红必胜子树的权值为 1，蓝必胜子树的权值为 -1，先手胜的权值为 0，则结点的状态为 $\sum 子树权值$。不难发现，$f_i = 0$ 对于上面的先手胜，$f_i > 0$ 对应红必胜，$f_i < 0$ 对应蓝必胜。而且这种描述方式**更精确了**。


​	考虑红方怎么赢。如果是红必胜，随便选一个点就好了。如果是先手胜，现在红方要选一个点，然后就成了后手了。**因此唯一的方式是这一个点使当前根结点的局面由先手胜转变为红必胜。**

​	有两个方法可以使根结点的局面从 0 变为 1。要么把根结点的子树中的一个从 -1 变成 0，要么把根结点的子树中的一个从 0 变成 1。不难发现，这是一个递归的问题，到子树上我们的做法也是一样的。所以我们可以从根结点开始遍历，仅进入 f 为 0 或 -1 的子树，走到叶结点后若该结点没有染色，就说明该结点是答案之一。问题就得到解决了。

​	**以上过程也侧面说明了为什么红必胜的第一步可以随便走：只要根节点的状态为红必胜，红的就赢定了。但可能之后红的就要更谨慎些了，因为随便选了一个位置后，（假设红方继续浪，）有可能局势就从红必胜转为了先手胜，从第 2 问来看，先手胜还得“绝顶聪明”才行。**

##### Day2 T1

###### 分析

​	很明显，当整个串不是回文串时，答案为 1。

​	然后考虑是否对于任意 $i$ 都使 $a_1$ 到 $a_i$ 和 $a_{i + 1}$ 到 $a_i$ 至少有一个是回文子串，如果不是，答案为 2。

​	现在任意前缀和对应的后缀都至少有一个是回文子串了，考虑以下情况：

​	若第一个字符等于第二个字符，有种情况是全部相同，答案为 -1。

​	若第一个字符等于第二个字符，考虑插入一个不同的字符，那么肯定会仍然满足原来的性质。但是如果这个字符不是插在中间的话，整个串就不是回文串了。所以当出现形如（aaaaabaaaaa）的字串时答案为 -1。

​	若第一个字符等于第二个字符，考虑插入多个不同的字符，始终存在一个 i 使得整个串可以分成两个非回文子串。

​	若第一个字符不等于第二个字符，考虑增量构造字符串，只能构造出形如 abababa 的形式的字串，答案为 -1。

​	特判答案为 -1 和 1 的情况，否则输出 2。

​	**要敢想，想细，写对。**

##### Day3 T1

######KMP 算法的深入理解

​	（具体的 KMP 算法，见专题）

​	对于所有 $i \ne a_i$ 的位置，通过求模得到答案。

​	对于所有 $i = a_i$ 的位置，考虑 KMP 算法的性质。**由于失配函数的含义是长度为 i 的前缀的“前缀和后缀相同”的最大长度，因此该位的 f 一定为0，否则 $i \ne a_i$**。由此可以枚举每一位填什么，然后代回去求 $f_i$（注意差一错误），如果求出来不为 0 ，则说明该字符不合法，要找下一个字符验证其是否合法，合法的话就是它了（以保证字典序最小）。由于题目保证有解，因此不用特判。
