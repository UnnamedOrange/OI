##### 1. 分块算法

​	分块算法是指，把序列上的问题分成一块一块的，然后分别维护其信息。查询时，如果待查询区间是一整块（多个整块），那么对于每一个整块就用维护好的信息 O(1) 得到答案；如果待查询区间不是一个整块（对于一个很大的查询区间，这种情况一定出现在区间两端），**就一个元素一个元素地暴力计算答案**。修改时，如果只存在单点修改，直接修改该点并维护对应块的信息即可；如果存在区间修改，则加上一个修改标记，往往这个标记是怠惰的。修改区间操作时，跟查询区间的操作类似，中间整块改，两边暴力改。

​	不难发现，如果块的大小为 $\sqrt {n}$，那么整个操作的时间复杂度将是 $O(n \sqrt {n})$ 的。**因此，用这种算法在 1 s 内能够解决 n 大约为 50000 的问题。**

#####2. [JZOJ 4243](https://jzoj.net/senior/#main/show/4243)

- [ ] 分块维护桶

######①分块

​	直接每个区间开一个桶，然后每个区间加上一个标记即可。**标记的含义为当前块的数以及桶都加上了 v。**

###### ②标记

​	**注意块标记的含义。**查询时，**暴力查询应当检查 a[i] + flag 是否在 S 中，而区间查询则查询 S[i] - flag 的个数**。修改时，**暴力修改只维护 a[i] 和桶，不管标记的事；而区间修改时只需要修改标记**。

​	**还要注意在加了标记后是否会有数组越界等问题。**

###### ③分块处理

​	一种自认为可以的做法是分两种情况处理分块。首先计算出点在哪个块中，以及 l 所在块的最后一个元素的位置和 r 所在块的第一个元素的位置。

```c++
	INT l = readIn();
	INT r = readIn();
	INT lInBlock = (l - 1) / sqrtN;
	INT lEnd = (lInBlock + 1) * sqrtN;
	INT rInBlock = (r - 1) / sqrtN;
	INT rBegin = rInBlock * sqrtN + 1;
```

​	然后分成两种情况处理。当 lInBlock = rInBlock 时，直接暴力修改 l 和 r。否则，分成三段处理，**而此时的 lEnd 和 rBegin 一定是有效的**。

```c++
	if (lInBlock == rInBlock)
	{
		for (int i = l; i <= r; i++);
	}
	else
	{
		for (int i = l; i <= lEnd; i++);
		for (int i = lInBlock + 1; i <= rInBlock - 1; i++);
		for (int i = rBegin; i <= r; i++);
	}
```

##### 3. [Luogu 3203](https://www.luogu.org/problemnew/show/3203)

###### ①分块

​	分块后，维护每一个元素跳到下一块的位置以及所需要的步数。单次跳跃的时间复杂度则为 $O(\sqrt {n})$。修改时，只需要从被修改点修改到块的开头，时间复杂度为 $O(\sqrt {n})$。

###### ②线性递推

​	更新时，不要每个点重新计算，要用递推的方式计算，这样计算的时间复杂度是线性的。

​	类似的思想在预处理时经常会遇到，只不过预处理对时间的要求一般不高，所以尝尝被我们忽视了。

##### 4. [JZOJ 4438](https://jzoj.net/senior/#main/show/4438)

###### ①分块

​	每一块保存一个标记和分块内的排序序列。

###### ②K 小数

​	二分 K 小数，然后通过计算有多少个数来进行二分操作。

​	若**小于等于 x 的数的个数小于 k，则 r = mid；否则 l = mid + 1。**

###### ③时间复杂度分析

​	修改时，区间修改的时间复杂度为 $O(\sqrt {n})$，单点修改的时间复杂度为 $O(\sqrt {n} \; \log \sqrt {n})$。

​	查询时，区间查询的时间复杂度为 $O(\sqrt {n} \; \log \sqrt {n})$，单点查询的时间复杂度为 $O(\sqrt {n})$。

​	总时间复杂度为 $O(n^{\frac {3} {2}} \log \sqrt {n})$。

##### 5. 